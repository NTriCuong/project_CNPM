[
  {
    "question": "51. ATAM là viết tắt của: ",
    "a": "Architecture Testing and Modeling.",
    "b": "Architecture Tradeoff Analysis Method .",
    "c": "Application Testing and Analysis Method.",
    "d": "Advanced Task Allocation Model.",
    "answer": "B",
    "theory": "ATAM (Architecture Tradeoff Analysis Method) là một quy trình đánh giá kiến trúc phần mềm do SEI phát triển, nhằm phân tích rủi ro và các đánh đổi giữa nhiều thuộc tính chất lượng (hiệu năng, bảo mật, khả năng thay đổi…)"
  },
  {
    "question": "52. Trong phương pháp ATAM, việc sử dụng các kịch bản (scenarios) giúp ích gì?",
    "a": "Chỉ để kiểm tra các lỗ hổng bảo mật.",
    "b": "Phân tích và đánh giá các quyết định thiết kế kiến trúc ảnh hưởng đến các thuộc tính chất lượng (quality attributes) trong các bối cảnh sử dụng cụ thể.",
    "c": "Giảm chi phí phát triển phần mềm.",
    "d": "Tối ưu hóa giao diện người dùng.",
    "answer": "B",
    "theory": "Scenarios trong ATAM là các tình huống cụ thể trích xuất từ yêu cầu chất lượng (quality attributes), mô tả kích thích (stimulus) và phản hồi (response) trong ngữ cảnh sử dụng thực tế"
  },
  {
    "question": "53.Tactics trong kiến trúc phần mềm là gì?",
    "a": "Các quy trình để thiết kế giao diện người dùng (UI).",
    "b": "Các kỹ thuật hoặc mẫu thiết kế cụ thể được sử dụng để đạt được một hoặc nhiều thuộc tính chất lượng (ví dụ: hiệu năng, bảo mật, khả năng thay đổi).",
    "c": "Các mẫu thiết kế riêng cho cơ sở dữ liệu.",
    "d": "Một tên gọi khác của các mẫu thiết kế (design patterns) nói chung",
    "answer": "B",
    "theory": "Tactics là các quyết định thiết kế cơ bản nhằm đạt được một hoặc nhiều thuộc tính chất lượng (ví dụ: hiệu năng, bảo mật, khả năng thay đổi). Chúng là khối xây dựng nguyên tử của các pattern/phương án kiến trúc phức tạp hơn, cho phép điều khiển chi tiết luồng xử lý và phản ứng hệ thống với kích thích"
  },
  {
    "question": "54. Ví dụ nào sau đây là một tactic để cải thiện hiệu năng (performance)? ",
    "a": "Sử dụng bộ nhớ đệm (Caching).",
    "b": "Ghi log (Logging) chi tiết.",
    "c": "Phân quyền người dùng (Authorization).",
    "d": "Xác thực người dùng (Authentication).",
    "answer": "A",
    "theory": "Caching là tactic lưu trữ tạm các dữ liệu hay kết quả đã truy xuất/tính toán gần đây ở vị trí truy cập nhanh hơn, nhằm giảm độ trễ và giảm tải cho hệ thống chính, từ đó tăng throughput và cải thiện thời gian phản hồi"
  },
  {
    "question": "55. Ví dụ nào sau đây là một \"tactic\" để hỗ trợ tính bảo mật (security)?",
    "a": "Tăng số lượng các lớp trong hệ thống.",
    "b": "Phân quyền truy cập (Access Control / Authorization).",
    "c": "Gộp nhiều chức năng vào một module duy nhất.",
    "d": "Sử dụng CSS để ẩn thông tin.",
    "answer": "B",
    "theory": "Access Control (Phân quyền truy cập) là tactic giới hạn hoặc từ chối truy cập đến tài nguyên dựa trên danh tính hoặc thuộc tính của người dùng, giúp ngăn chặn các hành vi trái phép và bảo vệ dữ liệu"
  },
  {
    "question": "56. Mục tiêu chính của thiết kế kiến trúc KHÔNG bao gồm",
    "a": "Đảm bảo bảo mật.",
    "b": "Viết mã nguồn nhanh hơn.",
    "c": "Lựa chọn mẫu kiến trúc phù hợp.",
    "d": "Phản ánh yêu cầu phi chức năng.",
    "answer": "B",
    "theory": "Thiết kế kiến trúc tập trung vào cấu trúc tổng thể, đáp ứng yêu cầu chức năng và phi chức năng (như bảo mật, hiệu năng...), không nhằm mục tiêu viết mã nhanh hơn. Viết mã nhanh liên quan đến hiện thực hóa, không phải mục tiêu của kiến trúc."
  },
  {
    "question": "57. Một lợi ích chính của kiến trúc phần mềm là:",
    "a": "Giảm bớt kiểm thử.",
    "b": "Bỏ qua tài liệu hóa.",
    "c": "Tăng khả năng mở rộng và bảo trì.",
    "d": "Giảm yêu cầu người dùng.",
    "answer": "C",
    "theory": "Kiến trúc rõ ràng giúp hệ thống dễ mở rộng (scalability) và dễ bảo trì (maintainability). Các lựa chọn kiến trúc tốt sẽ hỗ trợ thay đổi hoặc nâng cấp hệ thống dễ dàng hơn."
  },
  {
    "question": "58. Thiết kế kiến trúc là cầu nối giữa:",
    "a": "Giao diện người dùng và logic nghiệp vụ.",
    "b": "Phân tích yêu cầu và thiết kế chi tiết.",
    "c": "Viết mã và kiểm thử.",
    "d": "Khách hàng và người kiểm thử.",
    "answer": "B",
    "theory": "Thiết kế kiến trúc kết nối giữa việc hiểu yêu cầu (phân tích yêu cầu) và cách xây dựng chi tiết (thiết kế chi tiết/implementation). Nó là bước trung gian để định hình tổng thể hệ thống trước khi đi vào chi tiết."
  },
  {
    "question": "59. Một bước quan trọng trong quy trình thiết kế kiến trúc là:",
    "a": "Hiểu yêu cầu.",
    "b": "Tạo biểu đồ lớp UML.",
    "c": "Viết giao diện đồ họa.",
    "d": "Lập kế hoạch kiểm thử.",
    "answer": "A",
    "theory": "Không thể thiết kế kiến trúc đúng nếu không hiểu rõ yêu cầu (cả chức năng và phi chức năng). Hiểu yêu cầu là bước đầu tiên và nền tảng để đưa ra các quyết định thiết kế phù hợp."
  },
  {
    "question": "60. Trong các quyết định kiến trúc, việc phân tách module dựa vào:",
    "a": "Kích thước mã nguồn.",
    "b": "Chức năng và khả năng thay đổi độc lập.",
    "c": "Tên biến sử dụng.",
    "d": "Ngôn ngữ lập trình.",
    "answer": "B",
    "theory": "Việc phân tách module trong kiến trúc dựa trên việc nhóm các chức năng liên quan và đảm bảo mỗi module có khả năng thay đổi độc lập với các module khác. Điều này giúp dễ bảo trì, dễ mở rộng và giảm ảnh hưởng khi có thay đổi."
  },
  {
    "question": "61. Chiến lược điều phối tập trung thường sử dụng:",
    "a": "Pipe-and-Filter.",
    "b": "MVC.",
    "c": "Controller trung tâm hoặc message queue.",
    "d": "Client tự điều phối.",
    "answer": "C",
    "theory": "Điều phối tập trung (centralized control) thường dùng Controller hoặc Message Queue để quản lý việc truyền/nhận thông điệp."
  },
  {
    "question": "62. Một kiến trúc tốt giúp:",
    "a": "Viết code nhanh hơn.",
    "b": "Tránh mọi lỗi phần mềm.",
    "c": "Dễ bảo trì và mở rộng.",
    "d": "Giảm yêu cầu kỹ thuật.",
    "answer": "C",
    "theory": "Một kiến trúc tốt tập trung vào các thuộc tính chất lượng như maintainability (bảo trì) và extensibility (mở rộng)."
  },
  {
    "question": "63. Một yếu tố phi chức năng được kiến trúc phản ánh là:",
    "a": "Giao diện đồ họa.",
    "b": "Bảo mật.",
    "c": "Dữ liệu người dùng.",
    "d": "Tên hàm.",
    "answer": "B",
    "theory": "Các yêu cầu phi chức năng (non-functional requirements) gồm bảo mật, hiệu năng, khả năng mở rộng..."
  },
  {
    "question": "64. Biểu diễn “Box-and-Line” dùng để:",
    "a": "Viết thuật toán.",
    "b": "Minh họa cấu trúc hệ thống bằng hộp và đường kết nối.",
    "c": "Giao tiếp với hệ điều hành.",
    "d": "Mô phỏng giao diện.",
    "answer": "B",
    "theory": "\"Box-and-Line Diagram\" là cách trình bày sơ đồ thành phần (component diagram) bằng các khối (box) và các đường liên kết (line)."
  },
  {
    "question": "65. Mô hình 4+1 view có bao nhiêu góc nhìn chính?",
    "a": "3.",
    "b": "4.",
    "c": "5.",
    "d": "6.",
    "answer": "C",
    "theory": "Mô hình 4+1 gồm: Logical View, Development View, Process View, Physical View + Scenarios (Use Case View), tổng cộng 5 view."
  },
  {
    "question": "66. Logical View thể hiện:",
    "a": "Chức năng hệ thống với người dùng cuối.",
    "b": "Mã nguồn.",
    "c": "Cấu trúc vật lý.",
    "d": "Kiểm thử.",
    "answer": "A",
    "theory": "Logical View mô tả các chức năng hệ thống dưới góc nhìn nghiệp vụ, liên quan đến cách người dùng tương tác."
  },
  {
    "question": "67. Physical View mô tả:",
    "a": "Tài liệu hướng dẫn.",
    "b": "Ánh xạ phần mềm vào phần cứng.",
    "c": "Biểu đồ lớp.",
    "d": "Giao diện.",
    "answer": "B",
    "theory": "Physical View nói về cách hệ thống phần mềm được triển khai trên phần cứng vật lý."
  },
  {
    "question": "68. View dùng sơ đồ trạng thái và hoạt động là:",
    "a": "Logical View.",
    "b": "Process View.",
    "c": "Development View.",
    "d": "Use Case.",
    "answer": "B",
    "theory": "Process View tập trung vào hành vi động (dynamic behavior), mô tả bởi State Diagram và Activity Diagram."
  },
  {
    "question": "69. Mẫu MVC gồm mấy thành phần chính?",
    "a": "2.",
    "b": "3.",
    "c": "4.",
    "d": "5.",
    "answer": "B",
    "theory": "MVC = Model, View, Controller → tổng cộng 3 thành phần."
  },
  {
    "question": "70. Trong MVC, View đảm nhận:",
    "a": "Điều phối giữa các phần.",
    "b": "Lưu dữ liệu.",
    "c": "Hiển thị dữ liệu và nhận thao tác người dùng.",
    "d": "Thực thi mã.",
    "answer": "C",
    "theory": "Trong MVC, View (giao diện) chỉ hiển thị dữ liệu và nhận thao tác từ người dùng (click, nhập liệu), sau đó gửi về Controller xử lý."
  },
  {
    "question": "71. Kiến trúc phân tầng (Layered) chia hệ thống theo:",
    "a": "Người dùng.",
    "b": "Mức độ trừu tượng và chức năng.",
    "c": "Ngôn ngữ lập trình.",
    "d": "Giao thức.",
    "answer": "B",
    "theory": "Kiến trúc phân tầng (Layered) chia hệ thống thành các tầng theo mức độ trừu tượng và chức năng (ví dụ tầng Giao diện, tầng Logic, tầng CSDL)."
  },
  {
    "question": "72. Mẫu kiến trúc nào phù hợp cho hệ thống xử lý âm thanh?",
    "a": "MVC.",
    "b": "Layered.",
    "c": "Client-Server.",
    "d": "Pipe-and-Filter.",
    "answer": "D",
    "theory": "Pipe-and-Filter rất phù hợp cho xử lý tín hiệu liên tục như âm thanh, vì nó chia thành các bước tuần tự: lọc, biến đổi, xử lý."
  },
  {
    "question": "73. Nhược điểm của Repository là:",
    "a": "Khó bảo trì.",
    "b": "Trở thành nút cổ chai và điểm lỗi duy nhất.",
    "c": "Không lưu được dữ liệu.",
    "d": "Không dùng được cho web.",
    "answer": "B",
    "theory": "Repository (kho dữ liệu chung) có nhược điểm nút cổ chai: nếu lỗi Repository, cả hệ thống ngưng hoạt động."
  },
  {
    "question": "74. Trong Client-Server, Client thường:",
    "a": "Cung cấp dịch vụ.",
    "b": "Không có vai trò.",
    "c": "Yêu cầu và hiển thị kết quả.",
    "d": "Lưu trữ dữ liệu chính.",
    "answer": "C",
    "theory": "Trong Client-Server, Client gửi yêu cầu, Server xử lý và trả kết quả lại cho Client hiển thị."
  },
  {
    "question": "75. Mẫu Pipe-and-Filter phù hợp với:",
    "a": "Hệ thống phi tuần tự.",
    "b": "Biến đổi dữ liệu theo từng bước.",
    "c": "Giao tiếp đồng thời.",
    "d": "Giao diện phức tạp.",
    "answer": "B",
    "theory": "Pipe-and-Filter xử lý dữ liệu từng bước (mỗi filter nhận dữ liệu từ filter trước rồi xử lý)."
  },
  {
    "question": "76. Kiến trúc ứng dụng nhằm:",
    "a": "Giảm chi phí phần cứng.",
    "b": "Chuẩn hóa thiết kế cho các hệ thống cùng lĩnh vực.",
    "c": "Thay thế toàn bộ mã nguồn.",
    "d": "Giảm thời gian bảo trì.",
    "answer": "B",
    "theory": "Việc sử dụng các kiến trúc ứng dụng giúp chuẩn hóa thiết kế và cải thiện khả năng tái sử dụng."
  },
  {
    "question": "77. TPS thường được dùng trong",
    "a": "Trò chơi điện tử.",
    "b": "Phân tích hình ảnh.",
    "c": "Ngân hàng, thương mại điện tử.",
    "d": "Hệ thống nhúng.",
    "answer": "C",
    "theory": "Hệ thống xử lý giao tác thường được dùng trong các ứng dụng ngân hàng, bán lẻ, thương mại điện tử..."
  },
  {
    "question": "78. Thuộc tính ACID KHÔNG bao gồm",
    "a": "Atomicity.",
    "b": "Consistency.",
    "c": "Invisibility.",
    "d": "Durability.",
    "answer": "C",
    "theory": "Tác vụ mang tính nguyên tử, nhất quán, cách ly và bền vững (ACID) – tức là Atomicity, Consistency, Isolation, Durability."
  },
  {
    "question": "79. Hệ thống đặt vé máy bay là ví dụ của:",
    "a": "Hệ thống xử lý ngôn ngữ.",
    "b": "Kiến trúc client-side.",
    "c": "TPS.",
    "d": "Hệ thống tĩnh.",
    "answer": "C",
    "theory": "Hệ thống đặt vé máy bay là điển hình cho TPS: xử lý giao dịch theo thời gian thực, đảm bảo ACID."
  },
  {
    "question": "80. Các giai đoạn trong hệ xử lý ngôn ngữ gồm",
    "a": "Lưu trữ → Trình bày → Truy vấn.",
    "b": "Phân tích từ vựng → Cú pháp → Ngữ nghĩa → Sinh mã.",
    "c": "Lập trình → Gỡ lỗi → Cài đặt.",
    "d": "Cấu hình → Biên dịch → Gửi.",
    "answer": "B",
    "theory": "Lexical Analyzer (Phân tích từ vựng), Syntax Analyzer (Phân tích cú pháp), Semantic Analyzer (Kiểm tra ngữ nghĩa), Code Generator (Sinh mã trung gian)..."
  },
  {
    "question": "81. Mẫu kiến trúc phù hợp cho hệ thống NLP:",
    "a": "Pipe-and-Filter.",
    "b": "MVC.",
    "c": "Layered.",
    "d": "Client-Server.",
    "answer": "A",
    "theory": "NLP rất phù hợp Pipe-and-Filter: mỗi bộ lọc xử lý một bước như tokenizing, parsing, semantic analysis."
  },
  {
    "question": "82. IDE thường sử dụng mẫu kiến trúc nào?",
    "a": "MVC.",
    "b": "Pipe-and-Filter.",
    "c": "Repository.",
    "d": "Client-Server.",
    "answer": "A",
    "theory": "IDE như Eclipse, VSCode... sử dụng MVC để tách giao diện (View), xử lý (Controller) và dữ liệu (Model)."
  },
  {
    "question": "83. Kiến trúc phần mềm cần đảm bảo các yêu cầu nào sau?",
    "a": "Chức năng, bảo trì, hiệu suất, bảo mật.",
    "b": "Giao diện đẹp.",
    "c": "Phù hợp sở thích người dùng.",
    "d": "Giao tiếp mạng.",
    "answer": "A",
    "theory": "Kiến trúc phải đảm bảo các yêu cầu: chức năng, bảo trì dễ dàng, hiệu suất cao, bảo mật tốt."
  },
  {
    "question": "84. Nguyên tắc quan trọng trong phân tách module:",
    "a": "Phân chia theo sở thích cá nhân.",
    "b": "Tách theo chức năng và khả năng thay đổi độc lập.",
    "c": "Tách ngẫu nhiên.",
    "d": "Không cần phân tách.",
    "answer": "B",
    "theory": "Module nên tách theo chức năng và khả năng thay đổi độc lập, để dễ bảo trì, mở rộng mà không ảnh hưởng các phần khác."
  },
  {
    "question": "85. Yếu tố nào KHÔNG ảnh hưởng đến lựa chọn kiến trúc?",
    "a": "Hiệu năng.",
    "b": "Thời tiết.",
    "c": "Mở rộng.",
    "d": "Bảo trì.",
    "answer": "B",
    "theory": "Thời tiết hoàn toàn không liên quan đến quyết định kiến trúc phần mềm."
  },
  {
    "question": "86. Tài liệu hóa kiến trúc giúp:",
    "a": "Làm đẹp sơ đồ.",
    "b": "Lập trình nhanh hơn.",
    "c": "Truyền đạt và duy trì kiến trúc rõ ràng.",
    "d": "Giảm tài nguyên hệ thống.",
    "answer": "C",
    "theory": "Tài liệu hóa kiến trúc để truyền đạt giữa các nhóm và duy trì kiến trúc rõ ràng trong suốt vòng đời dự án."
  },
  {
    "question": "87. Cầu nối giữa yêu cầu và hiện thực kỹ thuật là vai trò của?",
    "a": "UI.",
    "b": "Database.",
    "c": "Kiến trúc phần mềm.",
    "d": "Source code.",
    "answer": "C",
    "theory": "Kiến trúc phần mềm là cầu nối giữa yêu cầu kinh doanh và các hiện thực kỹ thuật."
  },
  {
    "question": "88. Lợi ích của việc có kiến trúc phần mềm rõ ràng là:",
    "a": "Tăng chi phí phát triển.",
    "b": "Gây khó khăn trong bảo trì.",
    "c": "Cầu nối giữa yêu cầu và kỹ thuật.",
    "d": "Tăng độ phức tạp hệ thống.",
    "answer": "C",
    "theory": "Kiến trúc phần mềm giúp chuyển hóa yêu cầu thành giải pháp kỹ thuật, chứ không gây khó khăn hay tăng chi phí."
  },
  {
    "question": "89. Kiến trúc rõ ràng giúp?",
    "a": "Phát triển nhanh hơn.",
    "b": "Giao tiếp hiệu quả giữa các bên liên quan.",
    "c": "Giảm hiệu suất.",
    "d": "Tăng sự mâu thuẫn.",
    "answer": "B",
    "theory": "Kiến trúc rõ ràng giúp các nhóm phát triển, kiểm thử, khách hàng... giao tiếp hiệu quả, cùng hiểu một cách thống nhất."
  },
  {
    "question": "90. Bước đầu tiên trong quy trình thiết kế kiến trúc là?",
    "a": "Lựa chọn công nghệ.",
    "b": "Hiểu yêu cầu.",
    "c": "Đánh giá kiến trúc.",
    "d": "Tài liệu hóa kiến trúc.",
    "answer": "B",
    "theory": "Hiểu yêu cầu (business + kỹ thuật) là bước đầu tiên trước khi thiết kế kiến trúc."
  },
  {
    "question": "91. Công cụ nào thường được sử dụng để mô hình hóa kiến trúc?",
    "a": "Microsoft Word.",
    "b": "UML (sơ đồ lớp, sơ đồ triển khai, v.v.).",
    "c": "Excel.",
    "d": "PowerPoint.",
    "answer": "B",
    "theory": "Công cụ tiêu chuẩn để mô hình hóa kiến trúc là UML (Unified Modeling Language) – như sơ đồ lớp, deployment, component..."
  },
  {
    "question": "92. Quyết định nào sau đây là quan trọng trong thiết kế kiến trúc?",
    "a": "Chọn màu sắc giao diện.",
    "b": "Chọn kiến trúc phân tán hay tập trung.",
    "c": "Chỉ chọn ngôn ngữ lập trình.",
    "d": "Không cần chọn công nghệ.",
    "answer": "B",
    "theory": "Trong kiến trúc, quyết định rất lớn là chọn kiến trúc phân tán hay tập trung tùy theo yêu cầu dự án."
  },
  {
    "question": "93. Mục tiêu của việc biểu diễn kiến trúc là gì?",
    "a": "Chỉ để trang trí.",
    "b": "Truyền đạt quyết định thiết kế cho các nhóm liên quan và hỗ trợ bảo trì.",
    "c": "Chỉ để kiểm thử.",
    "d": "Không liên quan đến nhóm phát triển.",
    "answer": "B",
    "theory": "Biểu diễn kiến trúc giúp truyền đạt các quyết định thiết kế cho các nhóm (dev, QA, BA, PM...) và hỗ trợ bảo trì."
  },
  {
    "question": "94. Ký hiệu \"Box-and-Line\" đại diện cho gì?",
    "a": "Các hộp là thành phần, đường thẳng là mối quan hệ giữa chúng.",
    "b": "Các hộp là dữ liệu, đường thẳng là giao diện.",
    "c": "Các hộp là công cụ, đường thẳng là mã nguồn.",
    "d": "Các hộp là người dùng, đường thẳng là yêu cầu.",
    "answer": "A",
    "theory": "Trong \"Box-and-Line\", Box là các thành phần, Line là quan hệ giữa các thành phần (ví dụ kết nối, giao tiếp)."
  },
  {
    "question": "95. Nhược điểm của ký hiệu \"Box-and-Line\" là gì?",
    "a": "Quá chi tiết.",
    "b": "Thiếu ngữ nghĩa chính xác nếu không giải thích.",
    "c": "Không phù hợp với giao tiếp.",
    "d": "Không thể sử dụng trong thiết kế.",
    "answer": "B",
    "theory": "Nhược điểm của Box-and-Line là: nếu không giải thích, người đọc sẽ không hiểu rõ nghĩa từng box hoặc line."
  },
  {
    "question": "96. Mô hình 4+1 view do ai đề xuất?",
    "a": "Thomas Erl.",
    "b": "Philippe Kruchten.",
    "c": "Martin Fowler.",
    "d": "Robert C. Martin.",
    "answer": "B",
    "theory": "Mô hình 4+1 View do Philippe Kruchten đề xuất, gồm Logical, Process, Development, Physical và Use Case view."
  },
  {
    "question": "97. Khi thiết kế kiến trúc, việc cân bằng giữa các thuộc tính chất lượng (quality attributes) thường đối mặt với thách thức nào?",
    "a": "Các thuộc tính chất lượng luôn bổ trợ lẫn nhau một cách hoàn hảo.",
    "b": "Thường phải có sự đánh đổi (trade-offs), vì việc tối ưu một thuộc tính (ví dụ: hiệu năng) có thể ảnh hưởng tiêu cực đến thuộc tính khác (ví dụ: bảo mật, khả năng bảo trì).",
    "c": "Chỉ cần tập trung vào việc đáp ứng yêu cầu chức năng là đủ, các thuộc tính chất lượng không quan trọng bằng.",
    "d": "Các thuộc tính chất lượng chỉ quan trọng đối với giao diện người dùng.",
    "answer": "B",
    "theory": "Các thuộc tính chất lượng thường mâu thuẫn nhau, cần trade-off (ví dụ: tối ưu performance có thể làm giảm bảo mật)."
  },
  {
    "question": "98. Việc đánh giá kiến trúc (Architectural Evaluation) nên được thực hiện vào thời điểm nào trong quá trình phát triển để mang lại hiệu quả cao nhất?",
    "a": "Chỉ sau khi hệ thống đã hoàn thành và sẵn sàng triển khai.",
    "b": "Chỉ trong giai đoạn kiểm thử cuối cùng.",
    "c": "Càng sớm càng tốt trong chu trình thiết kế (ngay sau khi có bản phác thảo kiến trúc) và có thể lặp lại khi kiến trúc được tinh chỉnh.",
    "d": "Chỉ khi có vấn đề nghiêm trọng xảy ra trong quá trình phát triển.",
    "answer": "C",
    "theory": "Việc đánh giá kiến trúc nên làm càng sớm càng tốt (early architectural review), chứ không đợi đến cuối dự án."
  },
  {
    "question": "99. Hiện tượng \"Architectural Drift\" (hay \"Architectural Erosion\" - Xói mòn kiến trúc) mô tả điều gì?",
    "a": "Việc kiến trúc phần mềm trở nên quá phức tạp không cần thiết.",
    "b": "Sự sai lệch dần dần của cấu trúc hệ thống thực tế so với thiết kế kiến trúc ban đầu theo thời gian, thường do các thay đổi cục bộ không tuân thủ nguyên tắc kiến trúc.",
    "c": "Việc thay đổi hoàn toàn mẫu kiến trúc đã chọn giữa chừng dự án.",
    "d": "Việc thiếu hoàn toàn tài liệu mô tả kiến trúc.",
    "answer": "B",
    "theory": "Architectural Drift/Erosion: sự sai lệch dần giữa thiết kế kiến trúc ban đầu và hệ thống thực tế khi phát triển."
  },
  {
    "question": "100. \"Architectural Style\" (Kiểu kiến trúc) và \"Architectural Pattern\" (Mẫu kiến trúc) thường được phân biệt như thế nào?",
    "a": "Style là một giải pháp cụ thể, Pattern là một vấn đề chung chung.",
    "b": "Pattern mô tả một giải pháp đã được chứng minh cho một vấn đề thiết kế cụ thể, lặp đi lặp lại; Style mô tả một cách tiếp cận, một triết lý tổ chức hệ thống ở mức cao hơn, định hình cấu trúc tổng thể (ví dụ: Client-Server là một style, MVC là một pattern).",
    "c": "Không có sự khác biệt rõ ràng, chúng thường được dùng thay thế cho nhau.",
    "d": "Style chỉ áp dụng cho các hệ thống phân tán, Pattern áp dụng cho mọi hệ thống.",
    "answer": "B",
    "theory": "Style là triết lý tổ chức tổng thể (ví dụ: Client-Server); Pattern là giải pháp cụ thể cho vấn đề lặp đi lặp lại (ví dụ: MVC, Singleton)."
  },

  {
    "question": "1. Mô hình hóa hệ thống trong phát triển phần mềm là gì?",
    "a": "Quá trình viết mã chi tiết cho hệ thống.",
    "b": "Quá trình kiểm thử toàn bộ chức năng hệ thống.",
    "c": "Quá trình xây dựng các biểu diễn trừu tượng của hệ thống từ các góc nhìn khác nhau.",
    "d": "Quá trình triển khai hệ thống lên môi trường production.",
    "answer": "C",
    "theory": "Mô hình hóa hệ thống là quá trình tạo ra các biểu diễn trừu tượng của một hệ thống từ các góc nhìn khác nhau (ví dụ: cấu trúc, hành vi, tương tác) để hiểu rõ hơn, phân tích, thiết kế và giao tiếp về hệ thống đó."
  },
  {
    "question": "2. Tại sao mô hình hóa hệ thống lại quan trọng trong giai đoạn đầu của phát triển phần mềm?",
    "a": "Để viết tài liệu hướng dẫn sử dụng chi tiết.",
    "b": "Để giúp người phân tích hiểu chức năng hệ thống và giao tiếp hiệu quả với khách hàng.",
    "c": "Để tối ưu hóa hiệu năng cơ sở dữ liệu ngay lập tức.",
    "d": "Để lựa chọn ngôn ngữ lập trình phù hợp nhất.",
    "answer": "B",
    "theory": "Trong giai đoạn đầu, mô hình hóa giúp làm rõ yêu cầu, hiểu chức năng hệ thống và tạo ra một phương tiện giao tiếp chung giữa đội ngũ phát triển và khách hàng, đảm bảo mọi người có cùng hiểu biết về hệ thống."
  },
  {
    "question": "3. Khi mô hình hóa một hệ thống ĐÃ CÓ SẴN, mục đích chính là gì?",
    "a": "Thiết kế lại toàn bộ hệ thống từ đầu.",
    "b": "Làm rõ hệ thống hiện tại làm được gì và làm cơ sở thảo luận về điểm mạnh/yếu.",
    "c": "Chỉ tập trung vào việc sửa lỗi của hệ thống cũ.",
    "d": "Viết lại toàn bộ tài liệu kỹ thuật của hệ thống.",
    "answer": "B",
    "theory": "Mô hình hóa hệ thống đã có sẵn (as-is modeling) giúp hiểu rõ cách hệ thống hiện tại hoạt động, xác định các chức năng, điểm mạnh, điểm yếu, từ đó làm cơ sở cho việc cải tiến, bảo trì hoặc thay thế."
  },
  {
    "question": "4. Góc nhìn nào trong mô hình hóa hệ thống tập trung vào ranh giới và môi trường hoạt động của hệ thống?",
    "a": "Góc nhìn tương tác (Interaction perspective)",
    "b": "Góc nhìn cấu trúc (Structural perspective)",
    "c": "Góc nhìn hành vi (Behavioral perspective)",
    "d": "Góc nhìn bên ngoài (External perspective) / Ngữ cảnh",
    "answer": "D",
    "theory": "Góc nhìn bên ngoài (hay mô hình ngữ cảnh) xác định ranh giới của hệ thống, các thực thể bên ngoài (actors, hệ thống khác) tương tác với nó và môi trường mà hệ thống hoạt động."
  },
  {
    "question": "5. Loại biểu đồ UML nào thường được sử dụng để mô tả \"Góc nhìn bên ngoài\" (External perspective)?",
    "a": "Biểu đồ Lớp (Class Diagram)",
    "b": "Biểu đồ Tuần tự (Sequence Diagram)",
    "c": "Biểu đồ Use Case (Use Case Diagram) - thường dùng để thể hiện ngữ cảnh tương tác.",
    "d": "Biểu đồ Trạng thái (State Diagram)",
    "answer": "C",
    "theory": "Biểu đồ Use Case mô tả các chức năng của hệ thống từ góc nhìn của người dùng (actors) và cách họ tương tác với hệ thống, thể hiện rõ ràng phạm vi và ngữ cảnh của hệ thống."
  },
  {
    "question": "6. Mô hình ngữ cảnh (Context model) KHÔNG nhằm mục đích gì?",
    "a": "Cho thấy ranh giới của hệ thống đang phát triển.",
    "b": "Xác định các hệ thống hoặc tác nhân bên ngoài tương tác với hệ thống.",
    "c": "Mô tả chi tiết cấu trúc dữ liệu bên trong hệ thống.",
    "d": "Giúp hiểu phạm vi của hệ thống.",
    "answer": "C",
    "theory": "Mô hình ngữ cảnh tập trung vào việc xác định ranh giới, phạm vi của hệ thống và các tương tác của nó với môi trường bên ngoài. Nó không đi sâu vào chi tiết cấu trúc bên trong như cấu trúc dữ liệu."
  },
  {
    "question": "7. Mô hình xử lý (Process model) dùng để làm gì?",
    "a": "Mô tả chi tiết các lớp đối tượng trong hệ thống.",
    "b": "Làm nổi rõ cách hệ thống đang phát triển được sử dụng trong các quy trình nghiệp vụ.",
    "c": "Chỉ ra các trạng thái khác nhau của một đối tượng.",
    "d": "Xác định các thành phần phần cứng cần thiết.",
    "answer": "B",
    "theory": "Mô hình xử lý (thường dùng biểu đồ hoạt động) mô tả các quy trình nghiệp vụ mà hệ thống hỗ trợ, cho thấy các bước công việc, luồng dữ liệu và cách hệ thống được tích hợp vào các hoạt động đó."
  },
  {
    "question": "8. Loại biểu đồ UML nào phù hợp nhất để thể hiện Mô hình xử lý nghiệp vụ?",
    "a": "Biểu đồ Lớp (Class Diagram)",
    "b": "Biểu đồ Triển khai (Deployment Diagram)",
    "c": "Biểu đồ Hoạt động (Activity Diagram)",
    "d": "Biểu đồ Đối tượng (Object Diagram)",
    "answer": "C",
    "theory": "Biểu đồ Hoạt động (Activity Diagram) rất thích hợp để mô tả các luồng công việc (workflow) và quy trình nghiệp vụ, bao gồm các hoạt động, quyết định và luồng điều khiển."
  },
  {
    "question": "9. Góc nhìn tương tác (Interaction perspective) tập trung vào điều gì?",
    "a": "Cấu trúc tĩnh của các lớp và mối quan hệ của chúng.",
    "b": "Hành vi động của hệ thống khi phản ứng với sự kiện.",
    "c": "Sự tương tác giữa hệ thống với môi trường hoặc giữa các thành phần bên trong.",
    "d": "Cách hệ thống được triển khai trên phần cứng.",
    "answer": "C",
    "theory": "Góc nhìn tương tác mô tả cách các đối tượng hoặc thành phần của hệ thống (hoặc hệ thống với các actor bên ngoài) giao tiếp và cộng tác với nhau để thực hiện một chức năng nào đó, thường thể hiện qua việc trao đổi thông điệp."
  },
  {
    "question": "10. Hai loại biểu đồ UML chính được sử dụng để mô hình hóa tương tác là gì?",
    "a": "Biểu đồ Lớp và Biểu đồ Component",
    "b": "Biểu đồ Use Case và Biểu đồ Tuần tự",
    "c": "Biểu đồ Hoạt động và Biểu đồ Trạng thái",
    "d": "Biểu đồ Gói và Biểu đồ Triển khai",
    "answer": "B",
    "theory": "Biểu đồ Use Case mô tả các tương tác ở mức cao giữa actor và hệ thống. Biểu đồ Tuần tự (và các biểu đồ tương tác khác như Biểu đồ Giao tiếp) mô tả chi tiết trình tự các thông điệp được trao đổi giữa các đối tượng để thực hiện một use case hoặc một kịch bản cụ thể."
  },

  {
    "question": "11. Biểu đồ Use Case (Use Case Diagram) mô tả điều gì?",
    "a": "Cấu trúc chi tiết của cơ sở dữ liệu.",
    "b": "Các tương tác giữa tác nhân (actors) và hệ thống thông qua các ca sử dụng (use cases).",
    "c": "Luồng xử lý dữ liệu qua các chức năng.",
    "d": "Các trạng thái và sự chuyển đổi trạng thái của một đối tượng.",
    "answer": "B",
    "theory": "Biểu đồ Use Case mô tả chức năng của hệ thống từ góc nhìn người dùng, thể hiện các 'use cases' (ca sử dụng) mà hệ thống cung cấp và các 'actors' (tác nhân) tương tác với các use cases đó."
  },
  {
    "question": "12. Trong biểu đồ Use Case, 'actor' là gì?",
    "a": "Một chức năng cụ thể của hệ thống.",
    "b": "Một lớp đối tượng bên trong hệ thống.",
    "c": "Một người dùng, hệ thống khác, hoặc thực thể bên ngoài tương tác với hệ thống.",
    "d": "Một module phần mềm.",
    "answer": "C",
    "theory": "Actor trong biểu đồ Use Case đại diện cho một vai trò nào đó mà người dùng, hệ thống khác, hoặc một thực thể bên ngoài đóng khi tương tác với hệ thống để đạt được một mục tiêu cụ thể."
  },
  {
    "question": "13. Mục đích chính của việc mô tả chi tiết Use Case bằng văn bản là gì?",
    "a": "Thay thế hoàn toàn biểu đồ Use Case đồ họa.",
    "b": "Cung cấp thông tin chi tiết về luồng sự kiện, điều kiện, ngoại lệ mà biểu đồ không thể hiện hết.",
    "c": "Chỉ để liệt kê danh sách các actor tham gia.",
    "d": "Mô tả cấu trúc cơ sở dữ liệu liên quan.",
    "answer": "B",
    "theory": "Mô tả Use Case bằng văn bản (Use Case specification) bổ sung chi tiết cho biểu đồ, bao gồm luồng sự kiện chính, các luồng rẽ nhánh (alternative flows), điều kiện tiên quyết, hậu điều kiện, và các ngoại lệ, giúp hiểu rõ hơn cách use case được thực hiện."
  },
  {
    "question": "14. Kịch bản (Scenario) là gì trong ngữ cảnh của Use Case?",
    "a": "Một mô tả chi tiết về cấu trúc lớp.",
    "b": "Một ví dụ cụ thể về một chuỗi tương tác xảy ra khi thực hiện một Use Case.",
    "c": "Một danh sách các yêu cầu phi chức năng.",
    "d": "Một biểu đồ trạng thái của hệ thống.",
    "answer": "B",
    "theory": "Một kịch bản (scenario) là một đường đi cụ thể (instance) qua một Use Case, mô tả một chuỗi các hành động và tương tác giữa actor và hệ thống trong một tình huống cụ thể."
  },
  {
    "question": "15. Biểu đồ Tuần tự (Sequence Diagram) tập trung mô tả điều gì?",
    "a": "Cấu trúc tĩnh của hệ thống.",
    "b": "Tổ chức các gói (package) trong hệ thống.",
    "c": "Trình tự thời gian của các thông điệp (messages) được trao đổi giữa các đối tượng hoặc actor.",
    "d": "Các trạng thái khác nhau của toàn bộ hệ thống.",
    "answer": "C",
    "theory": "Biểu đồ Tuần tự (Sequence Diagram) mô tả sự tương tác động giữa các đối tượng theo trình tự thời gian. Nó thể hiện các đối tượng tham gia và các thông điệp được gửi giữa chúng theo thứ tự xảy ra."
  },
  {
    "question": "16. Trong Biểu đồ Tuần tự, đường thẳng đứng nét đứt kéo dài từ một đối tượng/actor được gọi là gì?",
    "a": "Thông điệp (Message)",
    "b": "Thanh kích hoạt (Activation bar)",
    "c": "Đường sống (Lifeline)",
    "d": "Điều kiện (Condition)",
    "answer": "C",
    "theory": "Đường sống (Lifeline) trong Biểu đồ Tuần tự đại diện cho sự tồn tại của một đối tượng hoặc actor trong suốt khoảng thời gian của tương tác được mô tả."
  },
  {
    "question": "17. Yếu tố nào trong Biểu đồ Tuần tự thể hiện một lời gọi phương thức hoặc một tín hiệu gửi đi?",
    "a": "Đường sống (Lifeline)",
    "b": "Thông điệp (Message), thường biểu diễn bằng mũi tên.",
    "c": "Thanh kích hoạt (Activation bar)",
    "d": "Ghi chú (Note)",
    "answer": "B",
    "theory": "Thông điệp (Message) trong Biểu đồ Tuần tự, thường được biểu diễn bằng mũi tên từ lifeline này sang lifeline khác, thể hiện một lời gọi phương thức, một tín hiệu, hoặc việc tạo/hủy đối tượng."
  },
  {
    "question": "18. Khối 'alt' (alternative) trong Biểu đồ Tuần tự dùng để biểu diễn điều gì?",
    "a": "Một vòng lặp các thông điệp.",
    "b": "Các luồng tương tác thay thế, tương đương cấu trúc IF-ELSE.",
    "c": "Một phần tùy chọn của tương tác (optional).",
    "d": "Sự kết thúc của một lifeline.",
    "answer": "B",
    "theory": "Khối 'alt' (alternative) trong Biểu đồ Tuần tự cho phép mô tả các luồng tương tác thay thế. Chỉ có một trong các luồng bên trong khối 'alt' sẽ được thực thi, dựa trên các điều kiện (guards) tương ứng, tương tự như cấu trúc if-else if-else."
  },
  {
    "question": "19. Khối 'opt' (optional) trong Biểu đồ Tuần tự biểu diễn điều gì?",
    "a": "Một chuỗi các thông điệp bắt buộc phải xảy ra.",
    "b": "Các luồng thay thế lẫn nhau.",
    "c": "Một đoạn tương tác chỉ xảy ra nếu một điều kiện nào đó đúng.",
    "d": "Sự khởi đầu của một tương tác song song.",
    "answer": "C",
    "theory": "Khối 'opt' (optional) trong Biểu đồ Tuần tự biểu diễn một đoạn tương tác chỉ được thực hiện nếu một điều kiện (guard) đi kèm là đúng. Nếu điều kiện sai, đoạn tương tác đó sẽ bị bỏ qua."
  },
  {
    "question": "20. Khối 'loop' trong Biểu đồ Tuần tự dùng để làm gì?",
    "a": "Biểu diễn một lựa chọn giữa hai luồng thông điệp.",
    "b": "Biểu diễn một đoạn tương tác được lặp lại nhiều lần.",
    "c": "Biểu diễn một thông điệp gửi tự đến chính nó.",
    "d": "Biểu diễn một tương tác tùy chọn.",
    "answer": "B",
    "theory": "Khối 'loop' trong Biểu đồ Tuần tự dùng để biểu diễn một đoạn các thông điệp hoặc tương tác được lặp lại nhiều lần, thường đi kèm với một điều kiện lặp."
  },
  {
    "question": "21. Sự khác biệt cơ bản giữa Biểu đồ Use Case và Biểu đồ Tuần tự là gì?",
    "a": "Use Case mô tả CÁI GÌ hệ thống làm, Tuần tự mô tả Al làm.",
    "b": "Use Case tập trung vào cấu trúc, Tuần tự tập trung vào hành vi.",
    "c": "Use Case mô tả tổng quan tương tác, Tuần tự mô tả chi tiết trình tự thời gian của tương tác đó.",
    "d": "Use Case dùng cho người dùng, Tuần tự dùng cho lập trình viên.",
    "answer": "C",
    "theory": "Biểu đồ Use Case cung cấp một cái nhìn tổng quan về các chức năng mà hệ thống cung cấp cho actors. Biểu đồ Tuần tự đi sâu vào chi tiết cách một use case cụ thể (hoặc một kịch bản của nó) được thực hiện thông qua trình tự các thông điệp trao đổi giữa các đối tượng theo thời gian."
  },
  {
    "question": "22. Góc nhìn cấu trúc (Structural perspective) trong mô hình hóa hệ thống tập trung vào yếu tố nào?",
    "a": "Luồng sự kiện và phản ứng của hệ thống.",
    "b": "Tương tác giữa người dùng và hệ thống.",
    "c": "Tổ chức tĩnh của hệ thống hoặc cấu trúc dữ liệu.",
    "d": "Môi trường hoạt động bên ngoài của hệ thống.",
    "answer": "C",
    "theory": "Góc nhìn cấu trúc mô tả các thành phần tĩnh của hệ thống và mối quan hệ giữa chúng, ví dụ như các lớp, đối tượng, thành phần, gói và cách chúng được tổ chức, hoặc cấu trúc dữ liệu của hệ thống."
  },
  {
    "question": "23. Loại biểu đồ UML nào là công cụ chính để mô tả cấu trúc tĩnh của các lớp trong hệ thống hướng đối tượng?",
    "a": "Biểu đồ Hoạt động (Activity Diagram)",
    "b": "Biểu đồ Lớp (Class Diagram)",
    "c": "Biểu đồ Tuần tự (Sequence Diagram)",
    "d": "Biểu đồ Trạng thái (State Diagram)",
    "answer": "B",
    "theory": "Biểu đồ Lớp (Class Diagram) là biểu đồ UML chính dùng để mô tả cấu trúc tĩnh của một hệ thống hướng đối tượng, bao gồm các lớp, thuộc tính, phương thức của chúng và các mối quan hệ giữa các lớp (như association, generalization, aggregation, composition)."
  },
  {
    "question": "24. Trong Biểu đồ Lớp, một 'lớp' (class) đại diện cho điều gì?",
    "a": "Một hành động cụ thể mà hệ thống thực hiện.",
    "b": "Một định nghĩa trừu tượng cho một tập hợp các đối tượng có cùng thuộc tính, hành vi và mối quan hệ.",
    "c": "Một màn hình giao diện người dùng.",
    "d": "Một quy trình nghiệp vụ.",
    "answer": "B",
    "theory": "Một lớp trong Biểu đồ Lớp là một khuôn mẫu (blueprint) hoặc một định nghĩa trừu tượng cho việc tạo ra các đối tượng. Nó mô tả các thuộc tính (dữ liệu) và hành vi (phương thức) chung mà tất cả các đối tượng của lớp đó sẽ có, cũng như các mối quan hệ với các lớp khác."
  },
  {
    "question": "25. Thành phần nào của một lớp trong Biểu đồ Lớp mô tả dữ liệu mà các đối tượng của lớp đó nắm giữ?",
    "a": "Tên lớp (Class name)",
    "b": "Thuộc tính (Attributes)",
    "c": "Phương thức/Hoạt động (Operations/Methods)",
    "d": "Mối quan hệ (Relationships)",
    "answer": "B",
    "theory": "Thuộc tính (Attributes) của một lớp trong Biểu đồ Lớp đại diện cho các đặc điểm dữ liệu hoặc trạng thái mà mỗi đối tượng của lớp đó sẽ có và lưu trữ."
  },
  {
    "question": "26. Thành phần nào của một lớp trong Biểu đồ Lớp mô tả các hành vi hoặc chức năng mà đối tượng của lớp đó có thể thực hiện?",
    "a": "Thuộc tính (Attributes)",
    "b": "Tên lớp (Class name)",
    "c": "Phương thức/Hoạt động (Operations/Methods)",
    "d": "Kiểu dữ liệu (Data types)",
    "answer": "C",
    "theory": "Phương thức (Methods) hoặc Hoạt động (Operations) của một lớp trong Biểu đồ Lớp mô tả các hành vi, chức năng hoặc các thao tác mà đối tượng của lớp đó có thể thực hiện."
  },
  {
    "question": "27. Mối quan hệ 'Generalization' (Tổng quát hóa) trong Biểu đồ Lớp thể hiện khái niệm nào trong lập trình hướng đối tượng?",
    "a": "Association (Liên kết)",
    "b": "Aggregation (Tập hợp)",
    "c": "Composition (Thành phần)",
    "d": "Inheritance (Thừa kế)",
    "answer": "D",
    "theory": "Mối quan hệ Generalization (Tổng quát hóa) trong UML tương ứng trực tiếp với khái niệm Thừa kế (Inheritance) trong lập trình hướng đối tượng, nơi một lớp con (subclass) kế thừa các thuộc tính và phương thức từ một lớp cha (superclass)."
  },
  {
    "question": "28. Trong mối quan hệ Generalization, lớp cha được gọi là gì?",
    "a": "Subclass (Lớp con)",
    "b": "Superclass (Lớp cha / Lớp cơ sở)",
    "c": "Interface (Giao diện)",
    "d": "Abstract class (Lớp trừu tượng) - có thể nhưng không phải luôn luôn.",
    "answer": "B",
    "theory": "Trong mối quan hệ Generalization (thừa kế), lớp tổng quát hơn, từ đó các lớp khác kế thừa, được gọi là Superclass (Lớp cha) hoặc Lớp cơ sở (Base class)."
  },
  {
    "question": "29. Lợi ích chính của việc sử dụng Generalization trong thiết kế là gì?",
    "a": "Tăng độ phức tạp của hệ thống.",
    "b": "Giảm khả năng tái sử dụng code.",
    "c": "Quản lý độ phức tạp bằng cách nhóm các đặc điểm chung và thúc đẩy tái sử dụng code thông qua thừa kế.",
    "d": "Làm cho việc hiểu hệ thống khó khăn hơn.",
    "answer": "C",
    "theory": "Generalization giúp quản lý độ phức tạp bằng cách trừu tượng hóa các đặc điểm chung vào lớp cha. Nó cũng thúc đẩy tái sử dụng code vì các lớp con có thể sử dụng lại các thuộc tính và phương thức của lớp cha, đồng thời mở rộng hoặc tùy chỉnh chúng."
  },
  {
    "question": "30. Mối quan hệ 'Aggregation' (Cộng gộp/Tập hợp) trong Biểu đồ Lớp mô tả điều gì?",
    "a": "Mối quan hệ \"is-a\" (là một loại của).",
    "b": "Mối quan hệ \"part-of\" (là một phần của) nhưng các thành phần có thể tồn tại độc lập với tập hợp.",
    "c": "Mối quan hệ \"uses\" (sử dụng).",
    "d": "Mối quan hệ sở hữu mạnh, thành phần không thể tồn tại nếu không có tập hợp.",
    "answer": "B",
    "theory": "Aggregation là một dạng đặc biệt của Association, biểu thị mối quan hệ \"whole-part\" (toàn thể-bộ phận) hay \"has-a\". Điểm quan trọng của Aggregation là các bộ phận (parts) có thể tồn tại độc lập với toàn thể (whole); nếu toàn thể bị hủy, các bộ phận vẫn có thể tồn tại."
  },
  {
    "question": "31. Mối quan hệ 'Composition' (Bao gộp/Thành phần) khác Aggregation như thế nào?",
    "a": "Composition là mối quan hệ yếu hơn Aggregation.",
    "b": "Composition thể hiện mối quan hệ sở hữu mạnh, vòng đời của thành phần phụ thuộc vào lớp chứa nó (nếu lớp chứa bị hủy, thành phần cũng bị hủy).",
    "c": "Aggregation chỉ dùng cho các lớp trừu tượng, Composition dùng cho lớp cụ thể.",
    "d": "Không có sự khác biệt đáng kể giữa Aggregation và Composition.",
    "answer": "B",
    "theory": "Composition là một dạng Aggregation mạnh hơn. Nó thể hiện mối quan hệ sở hữu mạnh, nghĩa là thành phần (part) không thể tồn tại độc lập với toàn thể (whole). Nếu toàn thể bị hủy, các thành phần của nó cũng bị hủy theo."
  },
  {
    "question": "32. Biểu tượng nào thường được sử dụng để biểu diễn Aggregation trong UML?",
    "a": "Mũi tên nét liền có đầu tam giác rỗng.",
    "b": "Mũi tên nét liền có đầu hình thoi rỗng.",
    "c": "Mũi tên nét liền có đầu hình thoi đặc.",
    "d": "Đường thẳng nét liền không có mũi tên.",
    "answer": "B",
    "theory": "Trong Biểu đồ Lớp UML, Aggregation được biểu diễn bằng một đường thẳng nối giữa hai lớp, với một hình thoi rỗng (không tô đen) ở phía lớp \"whole\" (toàn thể)."
  },
  {
    "question": "33. Biểu tượng nào thường được sử dụng để biểu diễn Composition trong UML?",
    "a": "Mũi tên nét liền có đầu tam giác rỗng.",
    "b": "Mũi tên nét liền có đầu hình thoi rỗng.",
    "c": "Mũi tên nét liền có đầu hình thoi đặc.",
    "d": "Đường thẳng nét đứt có mũi tên.",
    "answer": "C",
    "theory": "Trong Biểu đồ Lớp UML, Composition được biểu diễn bằng một đường thẳng nối giữa hai lớp, với một hình thoi đặc (tô đen) ở phía lớp \"whole\" (toàn thể)."
  },
  {
    "question": "34. Ví dụ nào sau đây thể hiện rõ nhất mối quan hệ Composition?",
    "a": "Một 'Thư viện' chứa nhiều 'Sách' (Sách có thể tồn tại ngoài thư viện).",
    "b": "Một 'Phòng học' là một phần của một 'Tòa nhà' (Phòng học không thể tồn tại nếu tòa nhà bị phá hủy).",
    "c": "Một 'Giáo viên' dạy nhiều 'Lớp học'.",
    "d": "Một 'Sinh viên' mượn nhiều 'Sách'.",
    "answer": "B",
    "theory": "Composition thể hiện sự sở hữu mạnh, nơi vòng đời của phần (part) phụ thuộc vào toàn thể (whole). Một phòng học không thể tồn tại nếu tòa nhà chứa nó bị phá hủy. Sách có thể tồn tại độc lập với thư viện (đây là Aggregation)."
  },
  {
    "question": "35. Góc nhìn hành vi (Behavioral perspective) mô tả điều gì?",
    "a": "Cấu trúc tĩnh của dữ liệu.",
    "b": "Mối quan hệ giữa các thành phần phần cứng.",
    "c": "Hành vi động của hệ thống và cách nó phản ứng với các tác động (stimuli).",
    "d": "Ranh giới giữa hệ thống và môi trường.",
    "answer": "C",
    "theory": "Góc nhìn hành vi tập trung vào cách hệ thống hoạt động và thay đổi theo thời gian, đặc biệt là cách nó phản ứng với các sự kiện hoặc tác động từ bên trong hoặc bên ngoài. Biểu đồ Trạng thái, Biểu đồ Hoạt động là các ví dụ."
  },
  {
    "question": "36. Hai loại tác động (stimuli) chính gây ra phản ứng trong mô hình hành vi là gì?",
    "a": "Lỗi và Ngoại lệ (Errors and Exceptions).",
    "b": "Dữ liệu và Sự kiện (Data and Events).",
    "c": "Yêu cầu và Phản hồi (Requests and Responses).",
    "d": "Tác nhân và Hệ thống (Actors and Systems).",
    "answer": "B",
    "theory": "Trong mô hình hành vi, hệ thống phản ứng với các tác động (stimuli). Các tác động này thường là sự xuất hiện của dữ liệu mới cần xử lý (data) hoặc các sự kiện (events) xảy ra (ví dụ: người dùng nhấn nút, hết thời gian)."
  },
{
    "question": "37. Mô hình hướng dữ liệu (Data-driven modeling) phù hợp với loại hệ thống nào?",
    "a": "Hệ thống thời gian thực phức tạp với nhiều sự kiện không đồng bộ.",
    "b": "Hệ thống xử lý nghiệp vụ, nơi đầu vào dữ liệu điều khiển quá trình xử lý.",
    "c": "Hệ thống nhúng điều khiển",
    "d": "Giao diện người dùng đồ hoạ phức tạp",
    "answer": "B",
    "theory": "Mô hình hướng dữ liệu (Data-driven modeling) phù hợp với các hệ thống mà luồng dữ liệu và các thao tác trên dữ liệu đóng vai trò trung tâm, chẳng hạn như hệ thống xử lý nghiệp vụ, nơi dữ liệu đầu vào điều khiển các quy trình xử lý và quyết định."
},
  {
    "question": "41. Yếu tố nào gây ra sự thay đổi từ trạng thái này sang trạng thái khác trong Biểu đồ Trạng thái?",
    "a": "Một thuộc tính (Attribute)",
    "b": "Một phương thức (Operation)",
    "c": "Một sự kiện (Event) kích hoạt sự chuyển đổi (Transition).",
    "d": "Một lớp cha (Superclass).",
    "answer": "C",
    "theory": "Trong Biểu đồ Trạng thái, sự chuyển đổi (Transition) từ một trạng thái này sang trạng thái khác thường được kích hoạt bởi một sự kiện (Event). Khi sự kiện xảy ra và điều kiện bảo vệ (guard condition) (nếu có) được thỏa mãn, đối tượng sẽ chuyển trạng thái."
  },
  {
    "question": "42. 'Transition' (Chuyển đổi) trong Biểu đồ Trạng thái thường bao gồm những thành phần nào?",
    "a": "Chỉ có tên sự kiện.",
    "b": "Sự kiện kích hoạt (Trigger), điều kiện bảo vệ (Guard), và hành động (Action/Effect).",
    "c": "Tên trạng thái nguồn và trạng thái đích.",
    "d": "Tên lớp và các thuộc tính.",
    "answer": "B",
    "theory": "Một Transition trong Biểu đồ Trạng thái thường bao gồm: Sự kiện kích hoạt (Trigger event) gây ra transition, Điều kiện bảo vệ (Guard condition) phải đúng để transition xảy ra, và Hành động (Action/Effect) được thực hiện khi transition diễn ra."
  },
  {
    "question": "43. 'Guard condition' (Điều kiện bảo vệ) trên một transition có ý nghĩa gì?",
    "a": "Là hành động được thực hiện khi transition xảy ra.",
    "b": "Là sự kiện gây ra transition.",
    "c": "Là một biểu thức logic, nếu đúng thì transition mới có thể xảy ra khi sự kiện kích hoạt xuất hiện.",
    "d": "Là tên của trạng thái đích.",
    "answer": "C",
    "theory": "Điều kiện bảo vệ (Guard condition) là một biểu thức Boolean được đánh giá khi sự kiện kích hoạt transition xảy ra. Transition chỉ diễn ra nếu điều kiện bảo vệ là đúng."
  },
  {
    "question": "44. Khái niệm 'Superstate' trong Biểu đồ Trạng thái dùng để làm gì?",
    "a": "Đại diện cho trạng thái khởi đầu của hệ thống.",
    "b": "Đại diện cho trạng thái kết thúc.",
    "c": "Gói gọn một nhóm các trạng thái con có chung các transition hoặc hành vi, giúp đơn giản hóa biểu đồ.",
    "d": "Chỉ ra một trạng thái không bao giờ đạt tới.",
    "answer": "C",
    "theory": "Superstate (hay composite state) là một trạng thái chứa các trạng thái con (substates). Nó giúp tổ chức và đơn giản hóa các biểu đồ trạng thái phức tạp bằng cách nhóm các trạng thái có liên quan và các transition chung."
  },
  {
    "question": "45. Loại biểu đồ nào mô tả luồng công việc (workflow) hoặc luồng xử lý dữ liệu bằng cách tập trung vào các hoạt động và sự chuyển tiếp giữa chúng?",
    "a": "Biểu đồ Trạng thái (State Diagram)",
    "b": "Biểu đồ Hoạt động (Activity Diagram)",
    "c": "Biểu đồ Tuần tự (Sequence Diagram)",
    "d": "Biểu đồ Lớp (Class Diagram)",
    "answer": "B",
    "theory": "Biểu đồ Hoạt động (Activity Diagram) mô tả các luồng công việc hoặc quy trình bằng cách hiển thị các hoạt động (actions), các điểm quyết định (decision nodes), và sự chuyển tiếp (control flows) giữa chúng."
  },
  {
    "question": "46. Trong Biểu đồ Hoạt động, hình thoi (diamond shape) thường biểu diễn điều gì?",
    "a": "Một hành động (Action)",
    "b": "Điểm bắt đầu hoặc kết thúc luồng (Initial/Final node)",
    "c": "Điểm quyết định (Decision node) hoặc điểm hợp nhất (Merge node).",
    "d": "Luồng song song (Fork/Join node).",
    "answer": "C",
    "theory": "Hình thoi trong Biểu đồ Hoạt động thường đại diện cho Điểm quyết định (Decision node), nơi luồng điều khiển rẽ nhánh dựa trên một điều kiện, hoặc Điểm hợp nhất (Merge node), nơi các luồng rẽ nhánh hội tụ lại."
  },
  {
    "question": "47. Trong Biểu đồ Hoạt động, thanh ngang dày (thick horizontal bar) dùng để biểu diễn điều gì?",
    "a": "Một hoạt động đơn lẻ.",
    "b": "Một quyết định rẽ nhánh.",
    "c": "Sự bắt đầu hoặc kết thúc của luồng hoạt động.",
    "d": "Sự chia tách luồng thành các nhánh song song (Fork) hoặc hợp nhất các nhánh song song (Join).",
    "answer": "D",
    "theory": "Thanh ngang dày trong Biểu đồ Hoạt động đại diện cho Fork node (chia một luồng thành nhiều luồng song song) hoặc Join node (hợp nhất nhiều luồng song song thành một luồng)."
  },
  {
    "question": "48. So sánh Biểu đồ Hoạt động và Biểu đồ Trạng thái, điểm khác biệt chính là gì?",
    "a": "Hoạt động mô tả luồng công việc/xử lý, Trạng thái mô tả vòng đời/trạng thái của một đối tượng.",
    "b": "Hoạt động chỉ dùng cho nghiệp vụ, Trạng thái chỉ dùng cho kỹ thuật.",
    "c": "Hoạt động không có rẽ nhánh, Trạng thái có.",
    "d": "Hoạt động tập trung vào sự kiện, Trạng thái tập trung vào dữ liệu.",
    "answer": "A",
    "theory": "Biểu đồ Hoạt động tập trung vào luồng các hoạt động và xử lý trong một quy trình. Biểu đồ Trạng thái tập trung vào các trạng thái khác nhau của một đối tượng cụ thể và sự chuyển đổi giữa các trạng thái đó trong suốt vòng đời của nó."
  },
  {
    "question": "49. Mục đích của việc sử dụng nhiều loại biểu đồ UML khác nhau để mô hình hóa một hệ thống là gì?",
    "a": "Làm cho tài liệu trở nên phức tạp và khó hiểu hơn.",
    "b": "Cung cấp các góc nhìn khác nhau, bổ sung cho nhau để hiểu rõ hơn về hệ thống cả về cấu trúc tĩnh và hành vi động.",
    "c": "Chỉ để đáp ứng yêu cầu của quy trình phát triển phần mềm.",
    "d": "Thay thế hoàn toàn việc viết mô tả bằng văn bản.",
    "answer": "B",
    "theory": "Mỗi loại biểu đồ UML tập trung vào một khía cạnh cụ thể của hệ thống. Sử dụng nhiều loại biểu đồ giúp cung cấp một cái nhìn toàn diện, từ các góc độ khác nhau (cấu trúc, hành vi, tương tác, triển khai), giúp hiểu rõ hơn và đầy đủ hơn về hệ thống."
  },
  {
    "question": "50. Mối liên hệ giữa Biểu đồ Use Case và Biểu đồ Tuần tự thường là gì?",
    "a": "Một Biểu đồ Tuần tự mô tả chi tiết cách thực hiện một Use Case cụ thể hoặc một kịch bản trong Use Case đó.",
    "b": "Biểu đồ Use Case là một phần của Biểu đồ Tuần tự.",
    "c": "Chúng hoàn toàn độc lập và không liên quan đến nhau.",
    "d": "Biểu đồ Tuần tự định nghĩa các Actor cho Biểu đồ Use Case.",
    "answer": "A",
    "theory": "Một Use Case mô tả một chức năng từ góc nhìn người dùng. Một Biểu đồ Tuần tự thường được sử dụng để chi tiết hóa cách một Use Case (hoặc một kịch bản cụ thể của nó) được hiện thực hóa thông qua sự tương tác giữa các đối tượng theo thời gian."
  },
  {
    "question": "51. Mối liên hệ giữa Biểu đồ Tuần tự và Biểu đồ Lớp thường là gì?",
    "a": "Biểu đồ Lớp xác định các trạng thái cho Biểu đồ Tuần tự.",
    "b": "Các đối tượng và lớp xuất hiện trong Biểu đồ Tuần tự thường được định nghĩa chi tiết trong Biểu đồ Lớp (thuộc tính, phương thức).",
    "c": "Chúng mô tả cùng một khía cạnh của hệ thống.",
    "d": "Biểu đồ Tuần tự mô tả mối quan hệ thừa kế, Biểu đồ Lớp mô tả thông điệp.",
    "answer": "B",
    "theory": "Biểu đồ Tuần tự cho thấy các đối tượng (instances) tương tác với nhau. Các lớp của những đối tượng này, cùng với thuộc tính và phương thức của chúng (được gọi trong các thông điệp), thường được định nghĩa và mô tả chi tiết trong Biểu đồ Lớp."
  },
  {
    "question": "52. Mối liên hệ giữa Biểu đồ Lớp và Biểu đồ Trạng thái thường là gì?",
    "a": "Biểu đồ Lớp là một trạng thái đặc biệt trong Biểu đồ Trạng thái.",
    "b": "Biểu đồ Trạng thái thường mô tả vòng đời hoặc hành vi của các đối tượng thuộc một Lớp cụ thể được định nghĩa trong Biểu đồ Lớp.",
    "c": "Biểu đồ Trạng thái xác định các phương thức cho Biểu đồ Lớp.",
    "d": "Không có mối liên hệ trực tiếp nào.",
    "answer": "B",
    "theory": "Biểu đồ Trạng thái mô tả các trạng thái và sự chuyển đổi trạng thái của một đối tượng. Lớp của đối tượng đó, cùng với các thuộc tính và phương thức liên quan đến các trạng thái và hành động, được định nghĩa trong Biểu đồ Lớp."
  },
  {
    "question": "53. Việc mô hình hóa hệ thống thường là một quá trình:",
    "a": "Tuyến tính, thực hiện một lần duy nhất từ đầu đến cuối.",
    "b": "Lặp đi lặp lại (iterative) và tăng trưởng (incremental), các mô hình được xây dựng và tinh chỉnh dần.",
    "c": "Chỉ thực hiện sau khi đã viết xong toàn bộ code.",
    "d": "Hoàn toàn tự động bởi các công cụ CASE.",
    "answer": "B",
    "theory": "Mô hình hóa hệ thống là một quá trình lặp đi lặp lại và tăng trưởng. Các mô hình ban đầu có thể ở mức trừu tượng cao và sau đó được tinh chỉnh, bổ sung chi tiết qua nhiều vòng lặp khi hiểu biết về hệ thống tăng lên."
  },
  {
    "question": "54. Ưu điểm của việc sử dụng ký hiệu đồ họa chuẩn hóa như UML là gì?",
    "a": "Làm cho mô hình khó hiểu đối với người không chuyên.",
    "b": "Tạo ra sự giao tiếp rõ ràng, nhất quán giữa các thành viên trong nhóm phát triển và với khách hàng.",
    "c": "Hạn chế khả năng biểu diễn các khía cạnh phức tạp của hệ thống.",
    "d": "Chỉ phù hợp với các dự án quy mô nhỏ.",
    "answer": "B",
    "theory": "Sử dụng một ngôn ngữ mô hình hóa chuẩn như UML giúp đảm bảo rằng tất cả các bên liên quan (nhà phát triển, nhà phân tích, khách hàng) có một cách hiểu chung và nhất quán về các mô hình, giảm thiểu hiểu lầm và cải thiện giao tiếp."
  },
  {
    "question": "55. Đâu KHÔNG phải là một góc nhìn hệ thống phổ biến được đề cập trong tài liệu?",
    "a": "Góc nhìn bên ngoài (External perspective)",
    "b": "Góc nhìn tương tác (Interaction perspective)",
    "c": "Góc nhìn tài chính (Financial perspective)",
    "d": "Góc nhìn cấu trúc (Structural perspective)",
    "answer": "C",
    "theory": "Các góc nhìn hệ thống phổ biến trong mô hình hóa thường bao gồm góc nhìn bên ngoài (ngữ cảnh), tương tác, cấu trúc và hành vi. Góc nhìn tài chính không phải là một góc nhìn kỹ thuật trực tiếp của mô hình hóa hệ thống theo UML."
  },
  {
    "question": "56. Trong Biểu đồ Tuần tự, thứ tự các thông điệp từ trên xuống dưới thể hiện điều gì?",
    "a": "Mức độ ưu tiên của thông điệp.",
    "b": "Trình tự thời gian xảy ra của các tương tác.",
    "c": "Mối quan hệ kế thừa giữa các đối tượng.",
    "d": "Cấu trúc phân cấp của hệ thống.",
    "answer": "B",
    "theory": "Trục thời gian trong Biểu đồ Tuần tự chạy từ trên xuống dưới. Do đó, thứ tự các thông điệp được vẽ từ trên xuống dưới thể hiện trình tự thời gian mà các thông điệp đó được gửi và nhận."
  },
  {
    "question": "57. Để mô tả cách các thành phần phần mềm vật lý (ví dụ: file .exe, .dll, thư viện) được tổ chức và phụ thuộc lẫn nhau, loại biểu đồ nào phù hợp? (Mở rộng từ Study Guide)",
    "a": "Biểu đồ Lớp (Class Diagram)",
    "b": "Biểu đồ Component (Component Diagram)",
    "c": "Biểu đồ Trạng thái (State Diagram)",
    "d": "Biểu đồ Use Case (Use Case Diagram)",
    "answer": "B",
    "theory": "Biểu đồ Component mô tả cách hệ thống được chia thành các thành phần (components) vật lý, có thể triển khai được (như file .exe, .dll, thư viện) và các mối quan hệ phụ thuộc giữa chúng."
  },
  {
    "question": "58. Để mô tả cách các thành phần phần mềm và phần cứng được triển khai và kết nối vật lý với nhau (ví dụ: server, client, database server), loại biểu đồ nào phù hợp? (Mở rộng từ Study Guide)",
    "a": "Biểu đồ Hoạt động (Activity Diagram)",
    "b": "Biểu đồ Triển khai (Deployment Diagram)",
    "c": "Biểu đồ Tuần tự (Sequence Diagram)",
    "d": "Biểu đồ Lớp (Class Diagram)",
    "answer": "B",
    "theory": "Biểu đồ Triển khai (Deployment Diagram) mô tả cấu trúc vật lý của hệ thống, bao gồm các nút (nodes) phần cứng (như server, client) và cách các thành phần phần mềm (artifacts) được triển khai lên các nút đó, cũng như các kết nối vật lý giữa chúng."
  },
  {
    "question": "59. Mối quan hệ <<include>> giữa hai Use Case có ý nghĩa gì? (Mở rộng từ Study Guide)",
    "a": "Use Case này là một trường hợp đặc biệt của Use Case kia.",
    "b": "Use Case gốc bắt buộc phải bao gồm hành vi của Use Case được chỉ tới tại một điểm xác định.",
    "c": "Use Case gốc có thể tùy chọn mở rộng hành vi của Use Case được chỉ tới.",
    "d": "Hai Use Case này hoàn toàn giống nhau.",
    "answer": "B",
    "theory": "Mối quan hệ <<include>> chỉ ra rằng hành vi của Use Case được bao gồm (included use case) là một phần bắt buộc của Use Case bao gồm (base use case). Use Case gốc sẽ không hoàn chỉnh nếu không thực hiện hành vi của Use Case được include."
  },
  {
    "question": "60. Mối quan hệ <<extend>> giữa hai Use Case có ý nghĩa gì? (Mở rộng từ Study Guide)",
    "a": "Use Case gốc luôn luôn thực hiện hành vi của Use Case mở rộng.",
    "b": "Use Case mở rộng bổ sung hành vi tùy chọn (optional) vào Use Case gốc tại một hoặc nhiều điểm mở rộng (extension points).",
    "c": "Đây là mối quan hệ thừa kế giữa các Use Case.",
    "d": "Use Case mở rộng là điều kiện tiên quyết để thực hiện Use Case gốc.",
    "answer": "B",
    "theory": "Mối quan hệ <<extend>> cho phép một Use Case (extending use case) bổ sung hành vi tùy chọn cho một Use Case khác (base use case) tại các điểm mở rộng (extension points) xác định. Hành vi mở rộng chỉ xảy ra khi một điều kiện nhất định được thỏa mãn."
  },
  {
    "question": "61. Khi nào nên sử dụng mối quan hệ <<include>>?",
    "a": "Khi một hành vi lặp lại ở nhiều Use Case và muốn tách ra để tái sử dụng.",
    "b": "Khi muốn mô tả một luồng xử lý ngoại lệ.",
    "c": "Khi một Use Case quá phức tạp và muốn chia nhỏ.",
    "d": "Khi một Use Case là tùy chọn.",
    "answer": "A",
    "theory": "Mối quan hệ <<include>> rất hữu ích khi một đoạn hành vi chung được sử dụng bởi nhiều Use Case. Bằng cách tách hành vi chung đó thành một Use Case riêng và include nó vào các Use Case khác, ta có thể tránh lặp lại và tăng tính tái sử dụng."
  },
  {
    "question": "62. Khi nào nên sử dụng mối quan hệ <<extend>>?",
    "a": "Khi muốn mô tả hành vi cốt lõi của Use Case.",
    "b": "Khi muốn mô tả một hành vi tùy chọn hoặc một luồng phụ chỉ xảy ra trong một số điều kiện nhất định.",
    "c": "Khi muốn gộp nhiều Use Case nhỏ thành một Use Case lớn.",
    "d": "Khi hai Use Case có cùng Actor.",
    "answer": "B",
    "theory": "Mối quan hệ <<extend>> được sử dụng để mô hình hóa các hành vi tùy chọn, các biến thể hoặc các luồng phụ của một Use Case cơ sở. Hành vi mở rộng này không phải lúc nào cũng xảy ra, mà phụ thuộc vào điều kiện cụ thể."
  },
  {
    "question": "63. Trong hệ thống \"Máy ATM\", hành động \"Xác thực thẻ và mã PIN\" là bắt buộc cho mọi giao dịch rút tiền, chuyển khoản. Mối quan hệ nào phù hợp để mô tả điều này?",
    "a": "Generalization",
    "b": "Extend",
    "c": "Include (ví dụ: Rút tiền <<include>> Xác thực thẻ)",
    "d": "Association",
    "answer": "C",
    "theory": "Vì \"Xác thực thẻ và mã PIN\" là hành vi bắt buộc và chung cho nhiều giao dịch như rút tiền, chuyển khoản, nên nó được mô hình hóa như một Use Case riêng và được <<include>> bởi các Use Case giao dịch đó."
  },
  {
    "question": "64. Trong hệ thống \"Đặt hàng Online\", Use Case \"Thanh toán\" có thể được thực hiện bằng \"Thẻ tín dụng\" hoặc \"Ví điện tử\". Mối quan hệ nào phù hợp để mô tả các phương thức thanh toán này với Use Case \"Thanh toán\"?",
    "a": "Include",
    "b": "Generalization (Thanh toán bằng Thẻ và Thanh toán bằng Ví là các dạng cụ thể của Thanh toán)",
    "c": "Extend",
    "d": "Aggregation",
    "answer": "B",
    "theory": "Nếu \"Thanh toán bằng Thẻ tín dụng\" và \"Thanh toán bằng Ví điện tử\" là các cách thức cụ thể, chuyên biệt hóa của hành vi \"Thanh toán\" chung, thì mối quan hệ Generalization là phù hợp. \"Thanh toán\" sẽ là Use Case cha (tổng quát), và các phương thức kia là các Use Case con (cụ thể)."
  },
  {
    "question": "65. Trong hệ thống \"Soạn thảo văn bản\", chức năng \"Kiểm tra chính tả\" có thể được người dùng kích hoạt tùy chọn. Mối quan hệ nào mô tả tốt nhất giữa \"Soạn thảo\" và \"Kiểm tra chính tả\"?",
    "a": "Include",
    "b": "Extend (Soạn thảo <<extend>> Kiểm tra chính tả)",
    "c": "Generalization",
    "d": "Composition",
    "answer": "B",
    "theory": "Vì \"Kiểm tra chính tả\" là một chức năng tùy chọn, không phải lúc nào cũng được thực hiện khi \"Soạn thảo\", nên mối quan hệ <<extend>> là phù hợp. Use Case \"Soạn thảo\" là base use case, và \"Kiểm tra chính tả\" là extending use case."
  },
  {
    "question": "66. Data Flow Diagram (DFD) khác UML chủ yếu ở điểm nào? (Mở rộng từ Study Guide)",
    "a": "DFD tập trung vào luồng dữ liệu qua các quy trình, UML có nhiều loại biểu đồ mô tả các khía cạnh khác nhau (cấu trúc, hành vi, tương tác).",
    "b": "DFD là chuẩn quốc tế, UML chỉ dùng nội bộ.",
    "c": "DFD mô tả hướng đối tượng, UML mô tả hướng chức năng.",
    "d": "DFD chỉ dùng cho hệ thống nhỏ, UML dùng cho hệ thống lớn.",
    "answer": "A",
    "theory": "DFD (Biểu đồ Luồng Dữ liệu) là một kỹ thuật mô hình hóa truyền thống, tập trung vào cách dữ liệu di chuyển qua hệ thống và được xử lý bởi các quy trình. UML là một ngôn ngữ mô hình hóa hướng đối tượng, cung cấp một bộ sưu tập phong phú các biểu đồ để mô tả các khía cạnh khác nhau của hệ thống."
  },
  {
    "question": "67. Khi nào việc sử dụng DFD có thể phù hợp hơn UML? (Mở rộng từ Study Guide)",
    "a": "Khi cần mô tả chi tiết các lớp và thừa kế.",
    "b": "Khi cần mô tả trạng thái của đối tượng.",
    "c": "Khi hệ thống chủ yếu là xử lý dữ liệu và muốn tập trung vào việc dữ liệu di chuyển và biến đổi như thế nào qua các quy trình.",
    "d": "Khi cần mô tả tương tác người dùng chi tiết theo thời gian.",
    "answer": "C",
    "theory": "DFD đặc biệt hữu ích cho các hệ thống có luồng dữ liệu phức tạp, nơi việc hiểu cách dữ liệu được nhập, xử lý, lưu trữ và xuất ra là quan trọng. Nó cung cấp một cái nhìn tổng quan tốt về dòng chảy dữ liệu trong hệ thống."
  },
  {
    "question": "68. Việc liên kết thông tin giữa các biểu đồ UML (ví dụ: Use Case -> Sequence -> Class) nhằm mục đích gì? (Mở rộng từ Study Guide)",
    "a": "Tạo ra sự dư thừa thông tin không cần thiết.",
    "b": "Đảm bảo tính nhất quán, đầy đủ và khả năng truy vết nguồn gốc yêu cầu qua các giai đoạn phân tích, thiết kế.",
    "c": "Chỉ để làm cho bộ tài liệu trông đầy đặn hơn.",
    "d": "Gây khó khăn cho việc bảo trì mô hình.",
    "answer": "B",
    "theory": "Liên kết thông tin giữa các biểu đồ UML (ví dụ: một Use Case được hiện thực hóa bởi một số Sequence Diagrams, các đối tượng trong Sequence Diagram là instances của các Classes) giúp đảm bảo tính nhất quán và đầy đủ của mô hình. Nó cũng cho phép truy vết yêu cầu từ các mô hình mức cao đến các mô hình chi tiết hơn."
  },
  {
    "question": "69. Đâu là một công cụ phổ biến hỗ trợ vẽ sơ đồ UML? (Mở rộng từ Study Guide)",
    "a": "Microsoft Word",
    "b": "Visual Paradigm / Enterprise Architect / StarUML / Lucidchart",
    "c": "Adobe Photoshop",
    "d": "Notepad++",
    "answer": "B",
    "theory": "Có nhiều công cụ CASE (Computer-Aided Software Engineering) hỗ trợ vẽ và quản lý mô hình UML. Các công cụ phổ biến bao gồm Visual Paradigm, Enterprise Architect, StarUML, Lucidchart, Draw.io, và nhiều công cụ khác."
  },
  {
    "question": "70. Việc đánh giá và kiểm tra mô hình UML (ví dụ: qua trao đổi nhóm) quan trọng vì sao? (Mở rộng từ Study Guide)",
    "a": "Để tìm ra lỗi sai, sự thiếu nhất quán, hoặc các điểm cần cải thiện trong mô hình trước khi chuyển sang giai đoạn hiện thực.",
    "b": "Chỉ là một thủ tục hình thức không có giá trị thực tế.",
    "c": "Để xác định ai là người vẽ mô hình tốt nhất.",
    "d": "Để kéo dài thời gian dự án.",
    "answer": "A",
    "theory": "Đánh giá và kiểm tra mô hình UML (ví dụ: thông qua walkthroughs, inspections) giúp phát hiện sớm các lỗi, thiếu sót, hoặc sự không nhất quán trong thiết kế. Việc này giúp cải thiện chất lượng mô hình và giảm chi phí sửa lỗi ở các giai đoạn sau."
  },
  {
    "question": "71. Mô hình hóa giúp ích gì trong việc chuyển đổi từ giai đoạn phân tích yêu cầu sang thiết kế chi tiết? (Mở rộng từ Study Guide)",
    "a": "Cung cấp một cầu nối trực quan, cấu trúc hóa các yêu cầu thành các thành phần thiết kế ban đầu (lớp, module, tương tác).",
    "b": "Không có vai trò gì trong việc chuyển đổi này.",
    "c": "Chỉ giúp xác định yêu cầu, không liên quan đến thiết kế.",
    "d": "Làm phức tạp hóa quá trình chuyển đổi.",
    "answer": "A",
    "theory": "Các mô hình được tạo ra trong giai đoạn phân tích (ví dụ: Use Case, mô hình khái niệm) cung cấp đầu vào và cơ sở để phát triển các mô hình thiết kế chi tiết hơn (ví dụ: Biểu đồ Lớp chi tiết, Biểu đồ Tuần tự). Mô hình hóa giúp cấu trúc hóa quá trình chuyển đổi này."
  },
  {
    "question": "72. Việc sử dụng Al (Trí tuệ nhân tạo) trong mô hình hóa hệ thống có tiềm năng gì? (Mở rộng từ Study Guide)",
    "a": "Tự động tạo mô hình UML từ mô tả ngôn ngữ tự nhiên, kiểm tra tính nhất quán, đề xuất cải tiến.",
    "b": "Thay thế hoàn toàn vai trò của kỹ sư phần mềm.",
    "c": "Chỉ dùng để vẽ các biểu đồ đẹp hơn.",
    "d": "Làm tăng chi phí mô hình hóa mà không mang lại lợi ích.",
    "answer": "A",
    "theory": "AI có tiềm năng hỗ trợ mô hình hóa bằng cách tự động hóa một số tác vụ như tạo mô hình từ văn bản, phân tích tính nhất quán của mô hình, gợi ý các mẫu thiết kế, hoặc thậm chí tối ưu hóa thiết kế dựa trên các ràng buộc."
  },
  {
    "question": "73. Đâu KHÔNG phải là lợi ích của việc mô hình hóa hệ thống?",
    "a": "Cải thiện giao tiếp giữa các bên liên quan.",
    "b": "Giúp hiểu rõ hơn về hệ thống.",
    "c": "Hỗ trợ phân tích và thiết kế hệ thống.",
    "d": "Đảm bảo 100% không có lỗi trong phần mềm cuối cùng.",
    "answer": "D",
    "theory": "Mô hình hóa là một công cụ mạnh mẽ giúp hiểu, phân tích, thiết kế và giao tiếp về hệ thống. Tuy nhiên, nó không thể đảm bảo 100% rằng phần mềm cuối cùng sẽ không có lỗi. Chất lượng phần mềm còn phụ thuộc vào nhiều yếu tố khác như hiện thực, kiểm thử."
  },
  {
    "question": "74. Khi mô hình hóa tương tác người dùng, yếu tố nào là quan trọng nhất cần xem xét?",
    "a": "Ngôn ngữ lập trình sẽ sử dụng.",
    "b": "Cách người dùng thực hiện các nhiệm vụ của họ thông qua hệ thống (luồng công việc, các bước).",
    "c": "Cấu trúc cơ sở dữ liệu chi tiết.",
    "d": "Thuật toán sắp xếp được sử dụng bên trong.",
    "answer": "B",
    "theory": "Khi mô hình hóa tương tác người dùng (ví dụ: bằng Use Cases, Sequence Diagrams, Activity Diagrams), việc hiểu rõ các nhiệm vụ (tasks) mà người dùng muốn thực hiện và các bước họ đi qua trong hệ thống để hoàn thành các nhiệm vụ đó là rất quan trọng."
  },
  {
    "question": "75. Mô hình nào tập trung vào \"ai làm gì\" và \"khi nào\"?",
    "a": "Biểu đồ Lớp (Class Diagram)",
    "b": "Biểu đồ Tuần tự (Sequence Diagram)",
    "c": "Biểu đồ Component (Component Diagram)",
    "d": "Biểu đồ Trạng thái (State Diagram)",
    "answer": "B",
    "theory": "Biểu đồ Tuần tự mô tả các đối tượng (ai) thực hiện các hành động (gửi thông điệp - làm gì) theo một trình tự thời gian cụ thể (khi nào)."
  },
  {
    "question": "76. Mô hình nào tập trung vào \"cái gì tồn tại\" và \"mối quan hệ tĩnh giữa chúng\"?",
    "a": "Biểu đồ Lớp (Class Diagram)",
    "b": "Biểu đồ Tuần tự (Sequence Diagram)",
    "c": "Biểu đồ Hoạt động (Activity Diagram)",
    "d": "Biểu đồ Use Case (Use Case Diagram)",
    "answer": "A",
    "theory": "Biểu đồ Lớp mô tả các loại thực thể (lớp - cái gì tồn tại) trong hệ thống và các mối quan hệ tĩnh (như association, generalization) giữa chúng, không phụ thuộc vào thời gian."
  },
  {
    "question": "77. Mô hình nào tập trung vào \"hành vi của một đối tượng thay đổi như thế nào theo thời gian\"?",
    "a": "Biểu đồ Lớp (Class Diagram)",
    "b": "Biểu đồ Triển khai (Deployment Diagram)",
    "c": "Biểu đồ Trạng thái (State Machine Diagram)",
    "d": "Biểu đồ Gói (Package Diagram)",
    "answer": "C",
    "theory": "Biểu đồ Trạng thái mô tả vòng đời của một đối tượng, cho thấy các trạng thái khác nhau mà nó có thể trải qua và các sự kiện gây ra sự chuyển đổi giữa các trạng thái đó theo thời gian."
  },
  {
    "question": "78. Trong ví dụ về hệ thống MHC-PMS, \"Patient Record System\" đóng vai trò gì trong mô hình ngữ cảnh?",
    "a": "Là một phần bên trong của MHC-PMS.",
    "b": "Là một actor (hệ thống bên ngoài) tương tác với MHC-PMS.",
    "c": "Là một quy trình nghiệp vụ.",
    "d": "Là một lớp dữ liệu.",
    "answer": "B",
    "theory": "Trong mô hình ngữ cảnh, nếu \"Patient Record System\" là một hệ thống riêng biệt mà MHC-PMS cần tương tác (ví dụ: để lấy hoặc cập nhật thông tin bệnh nhân), thì nó sẽ được coi là một actor (hệ thống bên ngoài)."
  },
  {
    "question": "79. Trong Biểu đồ Lớp của MHC-PMS (slide 204), mối quan hệ giữa \"Patient\" và \"Consultation\" thể hiện điều gì?",
    "a": "Một Patient có thể có một hoặc nhiều (1..*) Consultation.",
    "b": "Một Consultation chỉ thuộc về một Patient.",
    "c": "Patient kế thừa từ Consultation.",
    "d": "Consultation là một phần không thể tách rời của Patient (Composition).",
    "answer": "A",
    "theory": "Số lượng (multiplicity) 1..* ở phía Consultation trong mối quan hệ với Patient có nghĩa là một đối tượng Patient có thể liên kết với một hoặc nhiều đối tượng Consultation."
  },
  {
    "question": "80. Trong Biểu đồ Lớp của MHC-PMS (slide 204), mối quan hệ giữa \"Hospital Doctor\" và \"Doctor\" là loại quan hệ gì?",
    "a": "Aggregation",
    "b": "Composition",
    "c": "Association",
    "d": "Generalization (Hospital Doctor là một loại Doctor)",
    "answer": "D",
    "theory": "Nếu \"Hospital Doctor\" là một loại hình cụ thể hơn của \"Doctor\", kế thừa các đặc điểm chung của \"Doctor\" và có thể có thêm các đặc điểm riêng, thì đây là mối quan hệ Generalization."
  },
  {
    "question": "81. Mô hình hóa cấu trúc giúp trả lời câu hỏi nào sau đây?",
    "a": "Hệ thống phản ứng với sự kiện X như thế nào?",
    "b": "Các thành phần chính của hệ thống là gì và chúng liên kết với nhau ra sao?",
    "c": "Người dùng A tương tác với hệ thống để thực hiện tác vụ B như thế nào?",
    "d": "Hệ thống được sử dụng trong quy trình nghiệp vụ C như thế nào?",
    "answer": "B",
    "theory": "Mô hình hóa cấu trúc (ví dụ: Biểu đồ Lớp, Biểu đồ Component) tập trung vào việc xác định các thành phần chính của hệ thống (ví dụ: lớp, module) và cách chúng được tổ chức, liên kết tĩnh với nhau."
  },
  {
    "question": "82. Mô hình hóa hành vi giúp trả lời câu hỏi nào sau đây?",
    "a": "Hệ thống được tạo thành từ những lớp nào?",
    "b": "Dữ liệu được lưu trữ ở đâu?",
    "c": "Hệ thống thay đổi trạng thái hoặc thực hiện hành động gì khi có một sự kiện xảy ra?",
    "d": "Ai là người dùng chính của hệ thống?",
    "answer": "C",
    "theory": "Mô hình hóa hành vi (ví dụ: Biểu đồ Trạng thái, Biểu đồ Hoạt động) tập trung vào cách hệ thống hoạt động và phản ứng với các sự kiện, mô tả sự thay đổi trạng thái hoặc các chuỗi hành động được thực hiện."
  },
  {
    "question": "83. Việc định nghĩa rõ ràng \"ranh giới hệ thống\" trong mô hình ngữ cảnh có lợi ích gì?",
    "a": "Giúp xác định phạm vi công việc, những gì cần phát triển và những gì là tương tác bên ngoài.",
    "b": "Giúp xác định chi tiết các thuật toán bên trong.",
    "c": "Giúp lựa chọn màu sắc cho giao diện người dùng.",
    "d": "Giúp tối ưu hóa code ngay từ đầu.",
    "answer": "A",
    "theory": "Mô hình ngữ cảnh giúp xác định rõ ràng ranh giới của hệ thống, từ đó làm rõ phạm vi (scope) của dự án: những gì nằm bên trong hệ thống cần được phát triển và những gì nằm bên ngoài (actors, hệ thống khác) mà hệ thống cần tương tác."
  },
  {
    "question": "84. Nếu một hệ thống có yêu cầu cao về độ tin cậy và khả năng chịu lỗi, mô hình tương tác giữa các thành phần cần phân tích kỹ điều gì?",
    "a": "Màu sắc của các thành phần.",
    "b": "Cách các thành phần xử lý lỗi, các kịch bản dự phòng khi một thành phần gặp sự cố.",
    "c": "Số lượng lớp trong mỗi thành phần.",
    "d": "Tên của các lập trình viên phát triển từng thành phần.",
    "answer": "B",
    "theory": "Đối với hệ thống yêu cầu độ tin cậy cao, việc phân tích mô hình tương tác (ví dụ: Biểu đồ Tuần tự) cần chú trọng đến cách các thành phần giao tiếp trong các tình huống lỗi, cách chúng phát hiện lỗi, xử lý ngoại lệ, và các cơ chế dự phòng để đảm bảo hệ thống vẫn hoạt động ổn định."
  },
  {
    "question": "85. Trong Biểu đồ Trạng thái của lò vi sóng (slide 218), sự kiện \"Door Open\" khi đang ở trạng thái \"Operation\" sẽ dẫn đến trạng thái nào?",
    "a": "Full Power",
    "b": "Waiting",
    "c": "Disabled",
    "d": "Enabled",
    "answer": "C",
    "theory": "Dựa trên logic thông thường của lò vi sóng và các biểu đồ trạng thái tương tự, khi cửa lò được mở trong lúc đang hoạt động (Operation), lò sẽ chuyển sang trạng thái không hoạt động hoặc bị vô hiệu hóa (Disabled) để đảm bảo an toàn."
  },
  {
    "question": "86. Trong Biểu đồ Trạng thái của lò vi sóng (slide 218), hành động \"Do: Set Power = 600\" thuộc về trạng thái nào?",
    "a": "Waiting",
    "b": "Half Power",
    "c": "Full Power",
    "d": "Set Time",
    "answer": "B",
    "theory": "Hành động \"Do: Set Power = 600\" là một hoạt động được thực hiện liên tục khi đối tượng đang ở trong một trạng thái cụ thể. Trong ví dụ lò vi sóng, đây có thể là trạng thái \"Half Power\" nếu 600W tương ứng với nửa công suất."
  },
  {
    "question": "87. Mô hình hóa hệ thống có thể giúp phát hiện sớm các yêu cầu mâu thuẫn hoặc không đầy đủ không?",
    "a": "Không, mô hình hóa chỉ dùng để vẽ.",
    "b": "Có, việc trực quan hóa và phân tích các tương tác, cấu trúc, hành vi giúp dễ dàng nhận ra các điểm bất hợp lý.",
    "c": "Chỉ giúp phát hiện yêu cầu mâu thuẫn, không phát hiện yêu cầu thiếu.",
    "d": "Chỉ giúp khi hệ thống đã được lập trình xong.",
    "answer": "B",
    "theory": "Quá trình mô hình hóa đòi hỏi phải suy nghĩ kỹ lưỡng về các khía cạnh của hệ thống. Việc trực quan hóa này giúp dễ dàng phát hiện các mâu thuẫn logic, các yêu cầu không đầy đủ hoặc các tình huống chưa được xem xét, từ đó cải thiện chất lượng yêu cầu."
  },
  {
    "question": "88. Tại sao việc hiểu các \"stakeholder\" (bên liên quan) khác nhau lại quan trọng khi mô hình hóa?",
    "a": "Mỗi stakeholder có thể có những yêu cầu và góc nhìn khác nhau về hệ thống, cần được xem xét để tạo ra mô hình phù hợp.",
    "b": "Chỉ để biết ai sẽ trả tiền cho dự án.",
    "c": "Để xác định ai sẽ là người kiểm thử cuối cùng.",
    "d": "Không quan trọng, chỉ cần tập trung vào yêu cầu kỹ thuật.",
    "answer": "A",
    "theory": "Các stakeholder khác nhau (người dùng, quản lý, nhà phát triển, khách hàng) có những mối quan tâm và góc nhìn khác nhau đối với hệ thống. Hiểu rõ các stakeholder giúp tạo ra các mô hình đáp ứng được nhu cầu đa dạng và đảm bảo hệ thống thành công."
  },
  {
    "question": "89. Sự khác biệt giữa mô hình hóa trong giai đoạn phân tích và mô hình hóa trong giai đoạn thiết kế là gì?",
    "a": "Phân tích tập trung vào CÁI GÌ (yêu cầu), thiết kế tập trung vào CÁCH THỨC (giải pháp). Mô hình phân tích thường trừu tượng hơn, mô hình thiết kế chi tiết hơn.",
    "b": "Phân tích dùng UML, thiết kế dùng DFD.",
    "c": "Phân tích do khách hàng làm, thiết kế do lập trình viên làm.",
    "d": "Không có sự khác biệt nào.",
    "answer": "A",
    "theory": "Mô hình hóa trong giai đoạn phân tích tập trung vào việc hiểu và đặc tả yêu cầu của hệ thống (CÁI GÌ hệ thống nên làm). Mô hình hóa trong giai đoạn thiết kế tập trung vào việc xác định giải pháp kỹ thuật để hiện thực hóa các yêu cầu đó (CÁCH THỨC hệ thống sẽ làm). Mô hình thiết kế thường chi tiết hơn và gần với việc hiện thực hơn."
  },
  {
    "question": "90. Mô hình hóa có vai trò gì trong việc bảo trì và tiến hóa phần mềm?",
    "a": "Không có vai trò gì, chỉ dùng lúc phát triển ban đầu.",
    "b": "Giúp người bảo trì hiểu cấu trúc và hành vi của hệ thống hiện tại, đánh giá tác động của thay đổi dễ dàng hơn.",
    "c": "Chỉ giúp xác định lỗi cần sửa.",
    "d": "Làm cho việc bảo trì khó khăn hơn vì phải cập nhật mô hình.",
    "answer": "B",
    "theory": "Các mô hình hệ thống (đặc biệt là các mô hình \"as-is\" và mô hình thiết kế) là tài liệu quý giá cho việc bảo trì và tiến hóa. Chúng giúp đội ngũ bảo trì nhanh chóng hiểu được cấu trúc, hành vi của hệ thống, từ đó đánh giá tác động của các thay đổi và thực hiện sửa lỗi hoặc nâng cấp hiệu quả hơn."
  },
  {
    "question": "91. Đâu là hạn chế tiềm ẩn của việc quá phụ thuộc vào mô hình hóa?",
    "a": "Mô hình có thể trở nên quá phức tạp, khó bảo trì và tốn nhiều thời gian để tạo ra mà không tương xứng với lợi ích.",
    "b": "Mô hình luôn luôn đơn giản và dễ hiểu.",
    "c": "Mô hình luôn đảm bảo chất lượng code tốt.",
    "d": "Mô hình giúp giảm thời gian phát triển trong mọi trường hợp.",
    "answer": "A",
    "theory": "Nếu không được kiểm soát, việc mô hình hóa có thể dẫn đến tạo ra các mô hình quá chi tiết, phức tạp (over-modeling), gây tốn kém thời gian, công sức để tạo và duy trì mà không mang lại lợi ích tương xứng. Cần có sự cân bằng và lựa chọn mức độ chi tiết phù hợp."
  },
  {
    "question": "92. Khi một lớp A \"biết\" về lớp B (ví dụ: có một thuộc tính kiểu B), đây là loại mối quan hệ nào trong Biểu đồ Lớp?",
    "a": "Generalization",
    "b": "Association (Liên kết)",
    "c": "Dependency (Phụ thuộc - nếu chỉ sử dụng B trong phương thức)",
    "d": "Realization (Hiện thực hóa - thường với Interface)",
    "answer": "B",
    "theory": "Nếu lớp A có một thuộc tính (instance variable) kiểu lớp B, điều này có nghĩa là mỗi đối tượng của lớp A sẽ có một tham chiếu hoặc chứa một đối tượng của lớp B. Đây là một dạng của mối quan hệ Association (liên kết) giữa A và B, cụ thể hơn có thể là Aggregation hoặc Composition tùy thuộc vào ngữ nghĩa."
  },
  {
    "question": "93. Việc chọn mức độ chi tiết phù hợp cho một mô hình UML phụ thuộc vào yếu tố nào?",
    "a": "Luôn phải vẽ chi tiết nhất có thể.",
    "b": "Chỉ cần vẽ ở mức tổng quan nhất.",
    "c": "Mục đích của mô hình và đối tượng người xem (ví dụ: mô hình cho khách hàng khác mô hình cho lập trình viên).",
    "d": "Số lượng lớp trong hệ thống.",
    "answer": "C",
    "theory": "Mức độ chi tiết của một mô hình UML nên được quyết định bởi mục đích sử dụng mô hình đó (ví dụ: để giao tiếp với khách hàng, để hướng dẫn lập trình, để phân tích rủi ro) và đối tượng sẽ xem mô hình đó. Không phải lúc nào chi tiết hơn cũng tốt hơn."
  },
  {
    "question": "94. Biểu đồ nào thể hiện tốt nhất sự phân cấp chức năng hoặc tổ chức các thành phần lớn của hệ thống?",
    "a": "Biểu đồ Trạng thái",
    "b": "Biểu đồ Gói (Package Diagram) hoặc Biểu đồ Component",
    "c": "Biểu đồ Tuần tự",
    "d": "Biểu đồ Thời gian (Timing Diagram)",
    "answer": "B",
    "theory": "Biểu đồ Gói (Package Diagram) dùng để tổ chức các phần tử của mô hình (như lớp, use case) thành các nhóm có ngữ nghĩa, thể hiện sự phân cấp và phụ thuộc giữa các gói. Biểu đồ Component cũng thể hiện sự tổ chức của các thành phần lớn và giao diện của chúng."
  },
  {
    "question": "95. Trong các góc nhìn hệ thống, góc nhìn nào quan tâm nhất đến hiệu năng và xử lý đồng thời?",
    "a": "Góc nhìn cấu trúc (Structural perspective)",
    "b": "Góc nhìn hành vi (Behavioral perspective) - đặc biệt qua Biểu đồ Hoạt động.",
    "c": "Góc nhìn tương tác (Interaction perspective) - qua Biểu đồ Tuần tự cũng thể hiện phần nào.",
    "d": "Góc nhìn ngữ cảnh (Context perspective)",
    "answer": "B",
    "theory": "Góc nhìn hành vi, đặc biệt thông qua Biểu đồ Hoạt động với các luồng song song (fork/join) hoặc Biểu đồ Tuần tự với các thông điệp không đồng bộ, có thể giúp phân tích các vấn đề liên quan đến hiệu năng và xử lý đồng thời. Góc nhìn triển khai cũng liên quan đến hiệu năng."
  },
  {
    "question": "96. Mô hình hóa hành vi giúp xác định các yêu cầu phi chức năng nào?",
    "a": "Yêu cầu về giao diện người dùng.",
    "b": "Yêu cầu về hiệu năng (performance), thời gian đáp ứng (response time).",
    "c": "Yêu cầu về khả năng bảo trì.",
    "d": "Yêu cầu về ngôn ngữ lập trình.",
    "answer": "B",
    "theory": "Mô hình hóa hành vi (ví dụ: Biểu đồ Tuần tự có thể chú thích thời gian, Biểu đồ Hoạt động có thể phân tích thông lượng) có thể giúp làm rõ và phân tích các yêu cầu phi chức năng liên quan đến hiệu năng, thời gian đáp ứng, và khả năng xử lý đồng thời."
  },
  {
    "question": "97. Việc sử dụng \"Stereotype\" (ví dụ: <<system>>, <<interface>>) trong UML nhằm mục đích gì?",
    "a": "Làm cho biểu đồ khó đọc hơn.",
    "b": "Mở rộng ngữ nghĩa của các phần tử UML chuẩn để biểu diễn các khái niệm cụ thể hơn.",
    "c": "Chỉ để trang trí cho biểu đồ.",
    "d": "Thay thế hoàn toàn các phần tử UML cơ bản.",
    "answer": "B",
    "theory": "Stereotype là một cơ chế mở rộng của UML, cho phép người dùng định nghĩa các loại phần tử mới dựa trên các phần tử UML hiện có. Nó giúp tùy biến UML để phù hợp hơn với một miền vấn đề cụ thể hoặc một phương pháp luận cụ thể bằng cách thêm ngữ nghĩa mới."
  },
  {
    "question": "98. Nếu cần mô tả một quy trình có sự tham gia của nhiều bộ phận/vai trò khác nhau và muốn làm rõ trách nhiệm của từng bên, nên sử dụng yếu tố nào trong Biểu đồ Hoạt động?",
    "a": "Decision node (Nút quyết định)",
    "b": "Fork/Join node (Nút rẽ/hợp nhất luồng song song)",
    "c": "Swimlanes (Làn bơi - phân chia theo vai trò/bộ phận)",
    "d": "Initial node (Nút bắt đầu)",
    "answer": "C",
    "theory": "Swimlanes (Làn bơi) trong Biểu đồ Hoạt động được sử dụng để phân chia các hoạt động theo các vai trò, bộ phận hoặc actor chịu trách nhiệm thực hiện chúng, giúp làm rõ trách nhiệm và sự phối hợp giữa các bên."
  },
  {
    "question": "99. Ưu điểm của việc mô hình hóa cấu trúc dữ liệu (ví dụ: dùng Biểu đồ Lớp chỉ với thuộc tính) là gì?",
    "a": "Giúp thiết kế giao diện người dùng hiệu quả.",
    "b": "Giúp hiểu rõ cách dữ liệu được tổ chức, lưu trữ và mối quan hệ giữa các thực thể dữ liệu, làm cơ sở cho thiết kế CSDL.",
    "c": "Giúp xác định các sự kiện hệ thống.",
    "d": "Giúp tối ưu hóa thuật toán tìm kiếm.",
    "answer": "B",
    "theory": "Mô hình hóa cấu trúc dữ liệu, ví dụ bằng Biểu đồ Lớp chỉ tập trung vào các lớp và thuộc tính của chúng (đôi khi được gọi là conceptual model hoặc domain model), giúp làm rõ các thực thể dữ liệu quan trọng, các thuộc tính của chúng và mối quan hệ giữa chúng. Đây là đầu vào quan trọng cho việc thiết kế cơ sở dữ liệu."
  },
  {
    "question": "100. Mô hình hóa hệ thống là một kỹ năng quan trọng đối với vai trò nào trong đội ngũ phát triển phần mềm?",
    "a": "Chỉ Lập trình viên (Programmer).",
    "b": "Chỉ Người kiểm thử (Tester).",
    "c": "Chỉ Quản lý dự án (Project Manager).",
    "d": "Kỹ sư phần mềm, Nhà phân tích nghiệp vụ, Kiến trúc sư hệ thống (Software Engineer, Business Analyst, System Architect).",
    "answer": "D",
    "theory": "Mô hình hóa hệ thống là một kỹ năng cần thiết cho nhiều vai trò trong phát triển phần mềm. Nhà phân tích nghiệp vụ sử dụng mô hình để hiểu và đặc tả yêu cầu. Kiến trúc sư hệ thống sử dụng mô hình để thiết kế cấu trúc tổng thể. Kỹ sư phần mềm (developers) sử dụng và tạo ra các mô hình chi tiết hơn để hướng dẫn việc hiện thực. Testers cũng có thể sử dụng mô hình để thiết kế test case."
  },
  {
    "question": "1. Kiến trúc phần mềm được định nghĩa đúng nhất là gì?",
    "a": "Mô tả chi tiết mã nguồn của hệ thống.",
    "b": "Mô hình cấu trúc cấp cao mô tả các thành phần chính, vai trò và cách chúng tương tác.",
    "c": "Tài liệu hướng dẫn sử dụng phần mềm.",
    "d": "Giao diện người dùng của phần mềm.",
    "answer": "B",
    "theory": "Kiến trúc phần mềm tập trung vào cấu trúc tổng thể ở mức cao của hệ thống, bao gồm các thành phần chính, các mối quan hệ và tương tác giữa chúng, cùng với các nguyên tắc và hướng dẫn chi phối thiết kế và sự tiến hóa của hệ thống."
  },
  {
    "question": "2. Theo định nghĩa của IEEE, kiến trúc phần mềm mô tả điều gì?",
    "a": "Chỉ là sơ đồ mô tả dữ liệu.",
    "b": "Các thành phần hệ thống, mối quan hệ giữa chúng và các nguyên tắc chi phối thiết kế và sự tiến hóa của chúng.",
    "c": "Giao diện người dùng của hệ thống.",
    "d": "Cấu trúc thư mục mã nguồn.",
    "answer": "B",
    "theory": "Định nghĩa của IEEE (Std 1471-2000, nay là ISO/IEC/IEEE 42010) nhấn mạnh rằng kiến trúc phần mềm bao gồm các thành phần cơ bản của hệ thống, mối quan hệ của chúng với nhau và với môi trường, và các nguyên tắc chi phối thiết kế và sự tiến hóa của chúng."
  },
  {
    "question": "3. Kiến trúc phần mềm bao gồm những yếu tố nào?",
    "a": "Chỉ yếu tố tĩnh (ví dụ: cấu trúc module, lớp).",
    "b": "Chỉ yếu tố động (ví dụ: luồng dữ liệu, tương tác).",
    "c": "Cả yếu tố tĩnh và yếu tố động.",
    "d": "Chỉ các yếu tố liên quan đến bảo mật.",
    "answer": "C",
    "theory": "Kiến trúc phần mềm mô tả cả khía cạnh tĩnh (cấu trúc các thành phần, cách chúng được tổ chức) và khía cạnh động (cách các thành phần tương tác với nhau khi hệ thống chạy, luồng dữ liệu và điều khiển)."
  },
  {
    "question": "4. Yếu tố tĩnh trong kiến trúc phần mềm thường bao gồm:",
    "a": "Luồng dữ liệu (Data flow).",
    "b": "Cấu trúc các thành phần như module, lớp, connector.",
    "c": "Trạng thái hoạt động của người dùng.",
    "d": "Hành vi tương tác của hệ thống.",
    "answer": "B",
    "theory": "Yếu tố tĩnh của kiến trúc mô tả cách hệ thống được cấu thành từ các thành phần (modules, classes, components) và các kết nối (connectors) giữa chúng, mà không xét đến hành vi lúc chạy."
  },
  {
    "question": "5. Yếu tố động trong kiến trúc phần mềm thể hiện qua:",
    "a": "Sơ đồ lớp (Class Diagram).",
    "b": "Luồng dữ liệu, luồng điều khiển và cách các thành phần tương tác khi hệ thống chạy.",
    "c": "Cấu trúc thư mục dự án.",
    "d": "Các module và thành phần.",
    "answer": "B",
    "theory": "Yếu tố động của kiến trúc mô tả hành vi của hệ thống khi nó thực thi, bao gồm cách các thành phần tương tác, luồng dữ liệu và luồng điều khiển di chuyển giữa các thành phần."
  },
  {
    "question": "6. Vai trò chính và quan trọng nhất của kiến trúc phần mềm là gì?",
    "a": "Thiết kế chi tiết giao diện người dùng.",
    "b": "Làm cầu nối giữa yêu cầu (cả chức năng và phi chức năng) và việc hiện thực kỹ thuật.",
    "c": "Xác định đặc tả phần cứng cần thiết.",
    "d": "Quản lý ngân sách và tiến độ dự án.",
    "answer": "B",
    "theory": "Kiến trúc phần mềm đóng vai trò then chốt trong việc chuyển hóa các yêu cầu (đặc biệt là các yêu cầu phi chức năng như hiệu năng, bảo mật, khả năng mở rộng) thành một cấu trúc hệ thống có thể hiện thực được. Nó là nền tảng cho việc thiết kế chi tiết và hiện thực."
  },
  {
    "question": "7. Điều nào sau đây KHÔNG phải là mục tiêu hoặc lợi ích chính của việc xác định kiến trúc phần mềm rõ ràng?",
    "a": "Cải thiện giao tiếp giữa các bên liên quan (stakeholders).",
    "b": "Hỗ trợ đáp ứng các yêu cầu phi chức năng (như hiệu suất, bảo mật, khả năng mở rộng).",
    "c": "Loại bỏ hoàn toàn nhu cầu kiểm thử phần mềm.",
    "d": "Giảm thiểu rủi ro trong quá trình phát triển và tạo cơ sở cho việc bảo trì, mở rộng.",
    "answer": "C",
    "theory": "Kiến trúc phần mềm tốt giúp đáp ứng yêu cầu phi chức năng, cải thiện giao tiếp, giảm rủi ro và hỗ trợ bảo trì. Tuy nhiên, nó không loại bỏ nhu cầu kiểm thử; kiểm thử vẫn là một phần quan trọng để đảm bảo chất lượng."
  },
  {
    "question": "8. Kiến trúc phần mềm hỗ trợ bảo trì lâu dài như thế nào?",
    "a": "Bằng cách làm tăng độ phức tạp của mã nguồn.",
    "b": "Bằng cách cung cấp một cấu trúc rõ ràng, module hóa, dễ hiểu và dễ thay đổi.",
    "c": "Bằng cách tránh việc phải viết tài liệu.",
    "d": "Bằng cách chỉ tập trung vào các yêu cầu chức năng ban đầu.",
    "answer": "B",
    "theory": "Một kiến trúc được thiết kế tốt thường có tính module hóa cao, các thành phần có trách nhiệm rõ ràng và giao diện được xác định tốt. Điều này làm cho hệ thống dễ hiểu, dễ khoanh vùng lỗi, dễ thay đổi và mở rộng, từ đó hỗ trợ việc bảo trì lâu dài."
  },
  {
    "question": "9. Kiến trúc phần mềm khác với thiết kế chi tiết phần mềm ở điểm nào?",
    "a": "Không có sự khác biệt đáng kể.",
    "b": "Thiết kế chi tiết là mức cao hơn, trừu tượng hơn kiến trúc.",
    "c": "Kiến trúc là mức cao hơn, mô tả tổng thể hệ thống; thiết kế chi tiết mô tả cách hiện thực các thành phần cụ thể.",
    "d": "Thiết kế chi tiết tập trung vào phần cứng nhiều hơn.",
    "answer": "C",
    "theory": "Kiến trúc phần mềm tập trung vào các quyết định thiết kế ở mức độ vĩ mô, cấu trúc tổng thể, các thành phần chính và tương tác giữa chúng. Thiết kế chi tiết đi sâu vào cách hiện thực từng thành phần, thuật toán, cấu trúc dữ liệu cụ thể."
  },
  {
    "question": "10. Trong kiến trúc phần mềm, \"stakeholders\" (các bên liên quan) là ai?",
    "a": "Chỉ những người viết mã (lập trình viên).",
    "b": "Chỉ người dùng cuối của sản phẩm.",
    "c": "Chỉ người quản lý dự án.",
    "d": "Tất cả các bên có quyền lợi hoặc ảnh hưởng đến hệ thống (người dùng, nhà phát triển, quản lý, khách hàng, người vận hành,...).",
    "answer": "D",
    "theory": "Stakeholders là bất kỳ cá nhân, nhóm hoặc tổ chức nào có thể ảnh hưởng, bị ảnh hưởng bởi, hoặc tự nhận thấy mình bị ảnh hưởng bởi một quyết định, hoạt động hoặc kết quả của dự án/hệ thống. Kiến trúc phải xem xét mối quan tâm của các stakeholder khác nhau."
  },
  {
    "question": "11. Yêu cầu nào sau đây thường được xem là yêu cầu phi chức năng (non-functional requirement) và được giải quyết chủ yếu bởi kiến trúc phần mềm?",
    "a": "Chức năng đăng nhập người dùng.",
    "b": "Khả năng mở rộng (scalability) và hiệu năng (performance) của hệ thống.",
    "c": "Cấu trúc cụ thể của một bảng trong cơ sở dữ liệu.",
    "d": "Màu sắc của các nút bấm trên giao diện người dùng.",
    "answer": "B",
    "theory": "Các yêu cầu phi chức năng (hay thuộc tính chất lượng) như khả năng mở rộng, hiệu năng, bảo mật, khả năng bảo trì thường bị ảnh hưởng mạnh mẽ bởi các quyết định kiến trúc. Kiến trúc phải được thiết kế để đáp ứng các yêu cầu này."
  },
  {
    "question": "12. Quy trình thiết kế kiến trúc thường bắt đầu bằng bước nào?",
    "a": "Viết mã nguồn cho các chức năng chính.",
    "b": "Hiểu rõ các yêu cầu phần mềm (cả chức năng và phi chức năng) và các ràng buộc.",
    "c": "Tối ưu hóa cơ sở dữ liệu.",
    "d": "Lựa chọn ngay một framework cụ thể.",
    "answer": "B",
    "theory": "Bước đầu tiên và quan trọng nhất trong thiết kế kiến trúc là hiểu rõ các yêu cầu của hệ thống, đặc biệt là các yêu cầu phi chức năng và các ràng buộc (constraints) vì chúng sẽ định hình các quyết định kiến trúc."
  },
  {
    "question": "13. Bước cuối cùng trong quy trình thiết kế kiến trúc thường là gì?",
    "a": "Lựa chọn ngôn ngữ lập trình.",
    "b": "Viết tài liệu đặc tả kiến trúc và đánh giá lại.",
    "c": "Thiết kế giao diện người dùng.",
    "d": "Kiểm thử đơn vị (Unit test).",
    "answer": "B",
    "theory": "Sau khi các quyết định kiến trúc được đưa ra và một hoặc nhiều phương án kiến trúc được phát triển, việc tài liệu hóa kiến trúc đó (ví dụ: sử dụng các view khác nhau) và đánh giá nó (ví dụ: qua ATAM) để đảm bảo nó đáp ứng yêu cầu là bước quan trọng."
  },
  {
    "question": "14. Việc tài liệu hóa kiến trúc phần mềm có vai trò quan trọng gì?",
    "a": "Chỉ làm phức tạp hóa quá trình phát triển.",
    "b": "Ghi chép lại cấu trúc, các quyết định thiết kế quan trọng và các giả định để hỗ trợ giao tiếp, phân tích, phát triển và bảo trì.",
    "c": "Có thể thay thế hoàn toàn mã nguồn.",
    "d": "Chỉ phục vụ cho mục đích kiểm thử.",
    "answer": "B",
    "theory": "Tài liệu kiến trúc là một phương tiện giao tiếp quan trọng giữa các stakeholder. Nó ghi lại các quyết định thiết kế, các lý do đằng sau chúng, và cấu trúc tổng thể của hệ thống, giúp cho việc phát triển, bảo trì và tiến hóa hệ thống sau này."
  },
  {
    "question": "15. Mẫu kiến trúc phân tầng (Layered Architecture) thường chia hệ thống thành các tầng nào?",
    "a": "Tầng Giao diện người dùng (UI/Presentation), Tầng Logic nghiệp vụ (Business Logic), Tầng Truy cập dữ liệu (Data Access).",
    "b": "Tầng Mạng (Networking Layer), Tầng Ứng dụng (Application Layer).",
    "c": "Tầng Cache, Tầng Web Server, Tầng Database.",
    "d": "Tầng Phần cứng (Hardware Layer), Tầng Hệ điều hành (OS Layer).",
    "answer": "A",
    "theory": "Kiến trúc phân tầng cổ điển thường bao gồm Tầng Trình diễn (Presentation Layer) chịu trách nhiệm giao diện người dùng, Tầng Nghiệp vụ (Business Logic Layer) chứa logic xử lý chính, và Tầng Truy cập Dữ liệu (Data Access Layer) chịu trách nhiệm tương tác với cơ sở dữ liệu."
  },
  {
    "question": "16. Ưu điểm chính của kiến trúc phân tầng là gì?",
    "a": "Hiệu năng luôn cao nhất.",
    "b": "Các tầng có thể được phát triển và thay đổi độc lập tương đối, tăng khả năng bảo trì và tái sử dụng.",
    "c": "Giảm số lượng mã nguồn cần viết.",
    "d": "Không cần quan tâm đến bảo mật.",
    "answer": "B",
    "theory": "Kiến trúc phân tầng giúp tách biệt các mối quan tâm (separation of concerns). Mỗi tầng có trách nhiệm riêng và giao tiếp với các tầng khác qua các giao diện được xác định rõ. Điều này cho phép các tầng được phát triển, kiểm thử và thay đổi độc lập hơn, cải thiện khả năng bảo trì và tái sử dụng."
  },
  {
    "question": "17. Trong kiến trúc phân tầng, tầng nào chịu trách nhiệm tương tác trực tiếp với người dùng?",
    "a": "Tầng Truy cập dữ liệu (Data Access Layer).",
    "b": "Tầng Logic nghiệp vụ (Business Logic Layer).",
    "c": "Tầng Trình diễn/Giao diện người dùng (Presentation/UI Layer).",
    "d": "Tầng Dịch vụ (Service Layer).",
    "answer": "C",
    "theory": "Tầng Trình diễn (Presentation Layer) hay Tầng Giao diện người dùng (UI Layer) chịu trách nhiệm hiển thị thông tin cho người dùng và nhận đầu vào từ người dùng."
  },
  {
    "question": "18. Trong kiến trúc phân tầng, tầng nào chịu trách nhiệm xử lý các quy tắc và logic cốt lõi của ứng dụng?",
    "a": "Tầng Giao diện người dùng (Presentation Layer).",
    "b": "Tầng Logic nghiệp vụ (Business Logic Layer).",
    "c": "Tầng Truy cập dữ liệu (Data Access Layer).",
    "d": "Tầng Cơ sở hạ tầng (Infrastructure Layer).",
    "answer": "B",
    "theory": "Tầng Logic nghiệp vụ (Business Logic Layer) hay Tầng Miền (Domain Layer) chứa đựng các quy tắc, logic xử lý chính và các thực thể nghiệp vụ cốt lõi của ứng dụng."
  },
  {
    "question": "19. Trong kiến trúc phân tầng, nếu các tầng được thiết kế tách biệt tốt, việc thay đổi giao diện người dùng (UI) có ảnh hưởng lớn đến tầng logic nghiệp vụ không?",
    "a": "Có, ảnh hưởng đến tất cả các tầng khác.",
    "b": "Không, hoặc ảnh hưởng rất ít nếu giao diện (interface) giữa các tầng được giữ ổn định.",
    "c": "Chỉ ảnh hưởng trực tiếp đến tầng truy cập dữ liệu.",
    "d": "Luôn luôn ảnh hưởng đến hiệu năng toàn hệ thống.",
    "answer": "B",
    "theory": "Một trong những ưu điểm của kiến trúc phân tầng là giảm sự phụ thuộc. Nếu các tầng được tách biệt tốt và giao tiếp qua các interface ổn định, việc thay đổi hiện thực của một tầng (ví dụ: thay đổi UI) sẽ ít hoặc không ảnh hưởng đến các tầng khác, miễn là interface không thay đổi."
  },
  {
    "question": "20. Mẫu kiến trúc Client-Server mô tả mối quan hệ nào?",
    "a": "Giữa các module xử lý dữ liệu tuần tự.",
    "b": "Giữa thành phần yêu cầu dịch vụ (Client) và thành phần cung cấp dịch vụ (Server).",
    "c": "Giữa các lớp trong lập trình hướng đối tượng.",
    "d": "Giữa người dùng và giao diện đồ họa.",
    "answer": "B",
    "theory": "Mẫu kiến trúc Client-Server mô tả một mô hình tương tác phân tán trong đó Client (máy khách) gửi yêu cầu dịch vụ đến Server (máy chủ), và Server xử lý yêu cầu đó rồi gửi kết quả trả về cho Client."
  },
  {
    "question": "21. Nhược điểm tiềm ẩn của kiến trúc Client-Server tập trung là gì?",
    "a": "Khó quản lý và bảo trì tập trung.",
    "b": "Nếu Server gặp sự cố hoặc quá tải, toàn bộ hệ thống có thể bị ảnh hưởng (single point of failure).",
    "c": "Khó khăn trong việc chia sẻ dữ liệu giữa các Client.",
    "d": "Không thể nâng cấp phần cứng cho Server.",
    "answer": "B",
    "theory": "Trong mô hình Client-Server truyền thống với một Server tập trung, nếu Server đó gặp sự cố (phần cứng, phần mềm) hoặc bị quá tải, nó có thể trở thành một điểm lỗi đơn (single point of failure), khiến toàn bộ hệ thống không thể hoạt động hoặc hoạt động kém hiệu quả."
  },
  {
    "question": "22. Mẫu kiến trúc Model-View-Controller (MVC) tách ứng dụng thành ba thành phần chính nào?",
    "a": "Model (Dữ liệu & Logic xử lý), View (Hiển thị), Controller (Điều khiển luồng & xử lý yêu cầu).",
    "b": "Module, Variable, Constant.",
    "c": "Main, View, Component.",
    "d": "Method, Variable, Class.",
    "answer": "A",
    "theory": "MVC là một mẫu kiến trúc phổ biến, đặc biệt cho các ứng dụng có giao diện người dùng. Nó chia ứng dụng thành ba thành phần: Model (quản lý dữ liệu và logic nghiệp vụ), View (hiển thị dữ liệu cho người dùng), và Controller (nhận đầu vào từ người dùng và điều phối tương tác giữa Model và View)."
  },
  {
    "question": "23. Trong MVC, thành phần nào chịu trách nhiệm hiển thị dữ liệu cho người dùng?",
    "a": "Model.",
    "b": "View.",
    "c": "Controller.",
    "d": "Database.",
    "answer": "B",
    "theory": "View trong MVC chịu trách nhiệm trình bày dữ liệu (thường lấy từ Model) cho người dùng dưới một dạng thức phù hợp (ví dụ: trang web, cửa sổ ứng dụng)."
  },
  {
    "question": "24. Trong MVC, thành phần nào nhận yêu cầu từ người dùng và điều phối xử lý?",
    "a": "Model.",
    "b": "View.",
    "c": "Controller.",
    "d": "Service Layer.",
    "answer": "C",
    "theory": "Controller trong MVC nhận các yêu cầu (input) từ người dùng (thường thông qua View), xử lý các yêu cầu đó bằng cách tương tác với Model (ví dụ: cập nhật dữ liệu, thực hiện logic nghiệp vụ), và sau đó chọn View thích hợp để hiển thị kết quả."
  },
  {
    "question": "25. Mẫu kiến trúc Pipe-and-Filter phù hợp nhất với loại ứng dụng nào?",
    "a": "Hệ thống quản lý cơ sở dữ liệu quan hệ.",
    "b": "Ứng dụng xử lý dữ liệu theo chuỗi các bước độc lập (ví dụ: trình biên dịch, xử lý ảnh/âm thanh).",
    "c": "Hệ thống mạng xã hội thời gian thực.",
    "d": "Game online nhiều người chơi.",
    "answer": "B",
    "theory": "Mẫu Pipe-and-Filter phù hợp với các hệ thống mà việc xử lý dữ liệu có thể được chia thành một chuỗi các bước (filters) độc lập, nơi đầu ra của một filter này là đầu vào của filter kế tiếp thông qua các kênh (pipes). Ví dụ: trình biên dịch (lexical analysis -> syntax analysis -> ...), hệ thống xử lý luồng dữ liệu."
  },
  {
    "question": "26. Trong mẫu Pipe-and-Filter, \"Pipe\" đại diện cho gì?",
    "a": "Thành phần xử lý dữ liệu (Filter).",
    "b": "Kênh truyền dữ liệu giữa các Filter.",
    "c": "Nguồn dữ liệu đầu vào.",
    "d": "Đích dữ liệu đầu ra.",
    "answer": "B",
    "theory": "Trong kiến trúc Pipe-and-Filter, Pipe là kênh truyền dữ liệu, mang dữ liệu từ đầu ra của một Filter này đến đầu vào của Filter kế tiếp."
  },
  {
    "question": "27. Nhược điểm của mẫu Pipe-and-Filter có thể là gì?",
    "a": "Khó khăn trong việc thêm các bước xử lý mới.",
    "b": "Tăng độ trễ (latency) nếu dữ liệu cần chuyển đổi định dạng nhiều lần giữa các Filter hoặc xử lý tương tác phức tạp.",
    "c": "Không phù hợp cho xử lý batch (xử lý lô).",
    "d": "Yêu cầu tất cả Filter phải được viết bằng cùng một ngôn ngữ.",
    "answer": "B",
    "theory": "Nếu mỗi Filter thực hiện một phép biến đổi dữ liệu nhỏ và dữ liệu phải qua nhiều Filter, hoặc nếu có sự không tương thích về định dạng dữ liệu giữa các Filter đòi hỏi chuyển đổi, điều này có thể làm tăng độ trễ tổng thể của hệ thống. Cũng khó khăn cho các tương tác phức tạp qua lại."
  },
  {
    "question": "28. Mẫu kiến trúc Repository (hay Blackboard) phù hợp khi nào?",
    "a": "Khi các thành phần cần xử lý dữ liệu tuần tự.",
    "b": "Khi nhiều thành phần cần truy cập và thao tác trên một kho dữ liệu trung tâm chung.",
    "c": "Khi cần tách biệt rõ ràng giao diện và logic.",
    "d": "Khi hệ thống có tính tương tác cao giữa client và server.",
    "answer": "B",
    "theory": "Mẫu Repository (còn gọi là Blackboard) phù hợp với các hệ thống mà nhiều thành phần tính toán độc lập cần cộng tác để giải quyết một vấn đề phức tạp bằng cách chia sẻ và thao tác trên một kho dữ liệu trung tâm (repository/blackboard)."
  },
  {
    "question": "29. Ưu điểm của kiến trúc Repository là gì?",
    "a": "Dễ dàng quản lý và đồng bộ dữ liệu dùng chung giữa các thành phần.",
    "b": "Luôn đảm bảo hiệu năng cao nhất.",
    "c": "Giảm thiểu sự phụ thuộc vào kho dữ liệu trung tâm.",
    "d": "Phù hợp với các tác vụ xử lý thời gian thực nghiêm ngặt.",
    "answer": "A",
    "theory": "Ưu điểm chính của kiến trúc Repository là nó cung cấp một cơ chế tập trung để lưu trữ và quản lý dữ liệu chung. Các thành phần tương tác gián tiếp thông qua kho dữ liệu này, giúp đơn giản hóa việc quản lý và đồng bộ dữ liệu."
  },
  {
    "question": "30. Kiến trúc Microservices là gì?",
    "a": "Một ứng dụng lớn, nguyên khối duy nhất.",
    "b": "Một kiến trúc chia ứng dụng thành tập hợp các dịch vụ nhỏ, độc lập, có thể triển khai riêng lẻ.",
    "c": "Một cách tổ chức cơ sở dữ liệu.",
    "d": "Một mẫu thiết kế giao diện người dùng.",
    "answer": "B",
    "theory": "Kiến trúc Microservices là một phương pháp phát triển ứng dụng bằng cách xây dựng nó như một tập hợp các dịch vụ nhỏ, mỗi dịch vụ chạy trong quy trình riêng của nó và giao tiếp với các dịch vụ khác thông qua các cơ chế nhẹ (thường là API HTTP). Mỗi dịch vụ có thể được triển khai, nâng cấp và mở rộng độc lập."
  },
  {
    "question": "31. Ưu điểm chính của kiến trúc Microservices là gì?",
    "a": "Đơn giản hóa việc triển khai và quản lý toàn bộ hệ thống.",
    "b": "Tăng khả năng mở rộng (scalability), cho phép phát triển và triển khai độc lập các dịch vụ, linh hoạt về công nghệ.",
    "c": "Giảm độ phức tạp trong giao tiếp mạng giữa các dịch vụ.",
    "d": "Không cần cơ chế quản lý và giám sát phức tạp.",
    "answer": "B",
    "theory": "Microservices mang lại nhiều ưu điểm như khả năng mở rộng từng dịch vụ một cách độc lập, cho phép các nhóm phát triển tự chủ và sử dụng các công nghệ khác nhau cho từng dịch vụ, và cải thiện khả năng phục hồi lỗi (nếu một dịch vụ lỗi, các dịch vụ khác vẫn có thể hoạt động)."
  },
  {
    "question": "32. Đối với một hệ thống thương mại điện tử lớn, phức tạp, kiến trúc nào thường được ưu tiên lựa chọn để đảm bảo khả năng mở rộng và phát triển linh hoạt?",
    "a": "Monolithic (Kiến trúc nguyên khối).",
    "b": "Microservices.",
    "c": "Pipe-and-Filter.",
    "d": "Repository.",
    "answer": "B",
    "theory": "Đối với các hệ thống lớn và phức tạp như thương mại điện tử, kiến trúc Microservices thường được ưa chuộng vì nó cho phép chia nhỏ hệ thống thành các dịch vụ dễ quản lý hơn, có thể mở rộng độc lập từng phần, và cho phép các nhóm phát triển làm việc song song trên các dịch vụ khác nhau."
  },
  {
    "question": "33. Hệ thống xử lý giao dịch (Transaction Processing System - TPS) thường được tìm thấy ở đâu?",
    "a": "Ứng dụng xem video trực tuyến.",
    "b": "Trình soạn thảo văn bản cá nhân.",
    "c": "Hệ thống đặt vé máy bay, hệ thống ngân hàng, hệ thống bán lẻ.",
    "d": "Công cụ phân tích dữ liệu lớn (Big Data).",
    "answer": "C",
    "theory": "TPS là các hệ thống xử lý một lượng lớn các giao dịch nghiệp vụ lặp đi lặp lại, đòi hỏi tính toàn vẹn dữ liệu cao và thời gian đáp ứng nhanh. Ví dụ điển hình là hệ thống ngân hàng (chuyển tiền), đặt vé, quản lý kho hàng trong bán lẻ."
  },
  {
    "question": "34. Đặc điểm quan trọng của một TPS là gì?",
    "a": "Chỉ xử lý các tác vụ đơn giản, không cần độ tin cậy cao.",
    "b": "Hỗ trợ nhiều người dùng đồng thời, đảm bảo tính toàn vẹn dữ liệu thông qua các đặc tính ACID.",
    "c": "Không yêu cầu tính bảo mật cao.",
    "d": "Thường hoạt động ở chế độ offline.",
    "answer": "B",
    "theory": "TPS phải đảm bảo các giao dịch được xử lý một cách đáng tin cậy, nhất quán và toàn vẹn, ngay cả khi có nhiều người dùng truy cập đồng thời. Các thuộc tính ACID (Atomicity, Consistency, Isolation, Durability) là nền tảng cho việc này."
  },
  {
    "question": "35. Các thuộc tính ACID trong hệ thống TPS là viết tắt của:",
    "a": "Active - Control - Input - Data.",
    "b": "Atomicity (Nguyên tử) - Consistency (Nhất quán) - Isolation (Cách ly) - Durability (Bền vững).",
    "c": "Action - Computation - Integration - Design.",
    "d": "Access - Change - Integrity - Database.",
    "answer": "B",
    "theory": "ACID là tập hợp các thuộc tính đảm bảo tính toàn vẹn của giao dịch: Atomicity (giao dịch hoặc thành công hoàn toàn hoặc thất bại hoàn toàn), Consistency (giao dịch đưa cơ sở dữ liệu từ trạng thái nhất quán này sang trạng thái nhất quán khác), Isolation (các giao dịch đồng thời không ảnh hưởng lẫn nhau), Durability (khi giao dịch đã commit, dữ liệu sẽ không bị mất ngay cả khi có sự cố)."
  },
  {
    "question": "36. Kiến trúc nào thường được áp dụng cho việc xây dựng trình biên dịch (compiler) hoặc hệ thống xử lý ngôn ngữ tự nhiên?",
    "a": "Client-Server.",
    "b": "Pipe-and-Filter (với các giai đoạn như Lexical Analysis, Syntax Analysis, Semantic Analysis, Code Generation).",
    "c": "MVC.",
    "d": "Microservices.",
    "answer": "B",
    "theory": "Quá trình biên dịch một chương trình thường bao gồm nhiều giai đoạn xử lý tuần tự: phân tích từ vựng, phân tích cú pháp, phân tích ngữ nghĩa, tạo mã trung gian, tối ưu hóa mã, và sinh mã đích. Kiến trúc Pipe-and-Filter rất phù hợp để mô hình hóa chuỗi các giai đoạn này."
  },
  {
    "question": "37. Trong hệ thống xử lý ngôn ngữ (như trình biên dịch), giai đoạn đầu tiên thường là gì?",
    "a": "Semantic Analysis (Phân tích ngữ nghĩa).",
    "b": "Syntax Analysis (Phân tích cú pháp).",
    "c": "Lexical Analysis (Phân tích từ vựng).",
    "d": "Code Generation (Sinh mã).",
    "answer": "C",
    "theory": "Giai đoạn đầu tiên trong quá trình biên dịch là Phân tích từ vựng (Lexical Analysis hay Scanning), nơi mã nguồn đầu vào được đọc và chia thành các đơn vị từ vựng (tokens) như từ khóa, định danh, toán tử, hằng số."
  },
  {
    "question": "38. Trong hệ thống xử lý ngôn ngữ, thành phần nào chịu trách nhiệm kiểm tra ý nghĩa và logic của chương trình (ví dụ: kiểm tra kiểu dữ liệu, phạm vi biến)?",
    "a": "Lexical Analyzer (Bộ phân tích từ vựng).",
    "b": "Syntax Analyzer (Bộ phân tích cú pháp).",
    "c": "Semantic Analyzer (Bộ phân tích ngữ nghĩa).",
    "d": "Code Generator (Bộ sinh mã).",
    "answer": "C",
    "theory": "Phân tích ngữ nghĩa (Semantic Analysis) kiểm tra xem chương trình có ý nghĩa logic hay không, ví dụ như kiểm tra kiểu dữ liệu có tương thích trong các phép toán, các biến có được khai báo trước khi sử dụng, phạm vi của biến có hợp lệ."
  },
  {
    "question": "39. Môi trường phát triển tích hợp (IDE) thường áp dụng mẫu kiến trúc nào để quản lý các công cụ và dữ liệu dự án (như mã nguồn, cấu hình)?",
    "a": "Pipe-and-Filter.",
    "b": "Repository (Kho chứa trung tâm).",
    "c": "Client-Server đơn giản.",
    "d": "Layered Architecture cơ bản.",
    "answer": "B",
    "theory": "Các IDE hiện đại thường sử dụng một dạng của mẫu Repository (hoặc một kiến trúc dựa trên plugin) để quản lý các công cụ (trình soạn thảo, trình biên dịch, debugger, công cụ quản lý phiên bản) và dữ liệu dự án (mã nguồn, file cấu hình, thông tin build). Các công cụ này truy cập và thao tác trên một kho dữ liệu dự án chung."
  },
  {
    "question": "40. Mô hình xem kiến trúc 4+1 (4+1 View Model) của Philippe Kruchten bao gồm những khung nhìn (view) nào?",
    "a": "Chỉ có một khung nhìn duy nhất.",
    "b": "Logical View, Process View, Development View, Physical View, và Scenarios/Use Case View (+1).",
    "c": "Data View, Network View, Security View, UI View.",
    "d": "Top View, Side View, Front View, Back View, Bottom View.",
    "answer": "B",
    "theory": "Mô hình 4+1 của Kruchten đề xuất sử dụng 5 khung nhìn để mô tả kiến trúc phần mềm: Logical View (chức năng), Process View (đồng thời, hiệu năng), Development View (tổ chức module), Physical View (triển khai vật lý), và Scenarios/Use Case View (minh họa và kiểm chứng các view kia)."
  },
  {
    "question": "41. Trong mô hình 4+1, Logical View (Khung nhìn Logic) tập trung mô tả điều gì?",
    "a": "Cách hệ thống được triển khai lên phần cứng vật lý.",
    "b": "Các tiến trình và luồng thực thi (concurrency, performance).",
    "c": "Cấu trúc tĩnh của hệ thống dưới góc độ chức năng cung cấp cho người dùng cuối (ví dụ: các lớp, gói, mối quan hệ).",
    "d": "Cách mã nguồn được tổ chức thành các module, component bởi đội phát triển.",
    "answer": "C",
    "theory": "Logical View tập trung vào việc mô tả chức năng mà hệ thống cung cấp cho người dùng cuối. Nó thường bao gồm các thành phần chính của hệ thống (như các lớp, gói) và mối quan hệ giữa chúng dưới góc độ logic và chức năng."
  },
  {
    "question": "42. Trong mô hình 4+1, Development View (Khung nhìn Phát triển) mô tả điều gì?",
    "a": "Cấu trúc tĩnh của phần mềm dưới góc độ của người lập trình (ví dụ: các component, module, thư viện, cách tổ chức mã nguồn).",
    "b": "Cách hệ thống đáp ứng các yêu cầu phi chức năng.",
    "c": "Các kịch bản sử dụng chính của hệ thống.",
    "d": "Cấu trúc vật lý của hệ thống.",
    "answer": "A",
    "theory": "Development View (còn gọi là Implementation View) mô tả cách phần mềm được tổ chức thành các module, component, thư viện dưới góc độ của người lập trình. Nó quan tâm đến việc quản lý mã nguồn, build, và tái sử dụng."
  },
  {
    "question": "43. Trong mô hình 4+1, Process View (Khung nhìn Tiến trình) tập trung vào:",
    "a": "Cấu trúc lớp và gói.",
    "b": "Các khía cạnh động của hệ thống như các luồng thực thi, tiến trình, vấn đề đồng bộ và hiệu năng.",
    "c": "Cách triển khai phần mềm lên phần cứng.",
    "d": "Cách tổ chức mã nguồn.",
    "answer": "B",
    "theory": "Process View tập trung vào các khía cạnh động của hệ thống, đặc biệt là các vấn đề về đồng thời (concurrency), phân phối (distribution), hiệu năng (performance), và khả năng mở rộng (scalability). Nó mô tả các tiến trình, luồng và cách chúng giao tiếp."
  },
  {
    "question": "44. Trong mô hình 4+1, Physical View (Khung nhìn Vật lý) mô tả:",
    "a": "Logic nghiệp vụ của ứng dụng.",
    "b": "Cách hệ thống được triển khai trên cơ sở hạ tầng phần cứng và mạng máy tính.",
    "c": "Các trường hợp sử dụng (use cases).",
    "d": "Mối quan hệ giữa các lớp (class).",
    "answer": "B",
    "theory": "Physical View (còn gọi là Deployment View) mô tả cách các thành phần phần mềm được ánh xạ lên các tài nguyên phần cứng (như máy chủ, thiết bị mạng) và cách chúng được kết nối vật lý với nhau."
  },
  {
    "question": "45. Thành phần \"+1\" (Scenarios/Use Case View) trong mô hình 4+1 dùng để làm gì?",
    "a": "Mô tả chi tiết phần cứng.",
    "b": "Mô tả tầng dữ liệu.",
    "c": "Mô tả và kiểm chứng kiến trúc thông qua các kịch bản hoặc tình huống sử dụng quan trọng, đảm bảo kiến trúc đáp ứng yêu cầu.",
    "d": "Mô tả mã nguồn chi tiết.",
    "answer": "C",
    "theory": "Scenarios/Use Case View (thành phần \"+1\") dùng để minh họa và kiểm chứng tính đầy đủ và nhất quán của các view khác. Nó mô tả các kịch bản sử dụng quan trọng của hệ thống, giúp đảm bảo rằng kiến trúc được thiết kế có thể đáp ứng các yêu cầu chức năng và phi chức năng chính."
  },
  {
    "question": "46. Sơ đồ lớp (Class Diagram) và Sơ đồ tuần tự (Sequence Diagram) thường được sử dụng trong khung nhìn nào của mô hình 4+1?",
    "a": "Physical View.",
    "b": "Logical View (để mô tả cấu trúc tĩnh và hành vi tương tác logic).",
    "c": "Development View.",
    "d": "Process View.",
    "answer": "B",
    "theory": "Trong Logical View, Sơ đồ lớp được dùng để mô tả cấu trúc tĩnh của các lớp và mối quan hệ giữa chúng. Sơ đồ tuần tự (hoặc các sơ đồ tương tác khác) được dùng để mô tả hành vi tương tác logic giữa các đối tượng để thực hiện các chức năng."
  },
  {
    "question": "47. Sơ đồ thành phần (Component Diagram) thường được sử dụng trong khung nhìn nào của mô hình 4+1?",
    "a": "Logical View.",
    "b": "Development View (để thể hiện cách tổ chức mã nguồn thành các thành phần).",
    "c": "Physical View.",
    "d": "Process View.",
    "answer": "B",
    "theory": "Sơ đồ thành phần (Component Diagram) thường được sử dụng trong Development View (Implementation View) để mô tả cách hệ thống được chia thành các thành phần phần mềm có thể triển khai và các mối quan hệ phụ thuộc giữa chúng."
  },
  {
    "question": "48. Sơ đồ triển khai (Deployment Diagram) thuộc về khung nhìn nào trong mô hình 4+1?",
    "a": "Logical View.",
    "b": "Process View.",
    "c": "Physical View (mô tả cách các thành phần phần mềm được phân bố trên các nút phần cứng).",
    "d": "Development View.",
    "answer": "C",
    "theory": "Sơ đồ triển khai (Deployment Diagram) là công cụ chính để thể hiện Physical View, mô tả cách các thành phần phần mềm (artifacts) được triển khai và phân bố trên các nút (nodes) phần cứng vật lý của hệ thống."
  },
  {
    "question": "49. Sơ đồ hoạt động (Activity Diagram) thường được dùng để mô tả luồng công việc hoặc quy trình, nó có thể hữu ích trong khung nhìn nào?",
    "a": "Development View.",
    "b": "Physical View.",
    "c": "Process View (để mô tả luồng xử lý) hoặc Logical View (mô tả logic nghiệp vụ) hoặc Scenarios.",
    "d": "Chỉ dùng trong Physical View.",
    "answer": "C",
    "theory": "Sơ đồ hoạt động có thể hữu ích trong nhiều khung nhìn. Trong Process View, nó mô tả luồng xử lý và tương tác giữa các tiến trình. Trong Logical View, nó có thể mô tả logic nghiệp vụ phức tạp. Nó cũng có thể được dùng để minh họa các kịch bản trong Scenarios/Use Case View."
  },
  {
    "question": "50. Phương pháp đánh giá kiến trúc phần mềm phổ biến bao gồm:",
    "a": "MVC, REST.",
    "b": "SAAM (Software Architecture Analysis Method), ATAM (Architecture Tradeoff Analysis Method).",
    "c": "ERD (Entity-Relationship Diagram).",
    "d": "CSS, HTML.",
    "answer": "B",
    "theory": "SAAM và ATAM là hai phương pháp đánh giá kiến trúc phần mềm nổi tiếng. ATAM, được phát triển bởi SEI, tập trung vào việc phân tích các đánh đổi (tradeoffs) giữa các thuộc tính chất lượng (quality attributes) dựa trên các kịch bản (scenarios)."
  },
  {
    "question": "51. ATAM là viết tắt của:",
    "a": "Architecture Testing and Modeling.",
    "b": "Architecture Tradeoff Analysis Method (Phương pháp Phân tích Đánh đổi Kiến trúc).",
    "c": "Application Testing and Analysis Method.",
    "d": "Advanced Task Allocation Model.",
    "answer": "B",
    "theory": "ATAM là viết tắt của Architecture Tradeoff Analysis Method. Đây là một phương pháp có hệ thống để đánh giá kiến trúc phần mềm, tập trung vào việc xác định các rủi ro, điểm nhạy cảm và các đánh đổi liên quan đến việc đạt được các thuộc tính chất lượng."
  },
  {
    "question": "52. Trong phương pháp ATAM, việc sử dụng các kịch bản (scenarios) giúp ích gì?",
    "a": "Chỉ để kiểm tra các lỗ hổng bảo mật.",
    "b": "Phân tích và đánh giá các quyết định thiết kế kiến trúc ảnh hưởng đến các thuộc tính chất lượng (quality attributes) trong các bối cảnh sử dụng cụ thể.",
    "c": "Giảm chi phí phát triển phần mềm.",
    "d": "Tối ưu hóa giao diện người dùng.",
    "answer": "B",
    "theory": "Kịch bản trong ATAM là các mô tả ngắn gọn về cách hệ thống được sử dụng, hoặc các tình huống thay đổi, lỗi có thể xảy ra. Chúng giúp làm rõ các yêu cầu về thuộc tính chất lượng và làm cơ sở để phân tích xem kiến trúc có đáp ứng được các yêu cầu đó hay không."
  },
  {
    "question": "53. \"Tactics\" (chiến thuật) trong kiến trúc phần mềm là gì?",
    "a": "Các quy trình để thiết kế giao diện người dùng (UI).",
    "b": "Các kỹ thuật hoặc mẫu thiết kế cụ thể được sử dụng để đạt được một hoặc nhiều thuộc tính chất lượng (ví dụ: hiệu năng, bảo mật, khả năng thay đổi).",
    "c": "Các mẫu thiết kế riêng cho cơ sở dữ liệu.",
    "d": "Một tên gọi khác của các mẫu thiết kế (design patterns) nói chung.",
    "answer": "B",
    "theory": "Architectural tactics là các quyết định thiết kế cơ bản, các kỹ thuật hoặc mẫu đã được chứng minh là có ảnh hưởng đến một hoặc nhiều thuộc tính chất lượng. Ví dụ, để cải thiện hiệu năng, có thể sử dụng tactic \"Increase computational efficiency\" hoặc \"Reduce demand\"."
  },
  {
    "question": "54. Ví dụ nào sau đây là một \"tactic\" để cải thiện hiệu năng (performance)?",
    "a": "Sử dụng bộ nhớ đệm (Caching).",
    "b": "Ghi log (Logging) chi tiết.",
    "c": "Phân quyền người dùng (Authorization).",
    "d": "Xác thực người dùng (Authentication).",
    "answer": "A",
    "theory": "Sử dụng bộ nhớ đệm (Caching) là một tactic phổ biến để cải thiện hiệu năng bằng cách lưu trữ các dữ liệu hoặc kết quả tính toán thường xuyên truy cập ở một nơi có tốc độ truy cập nhanh hơn, giảm thiểu việc phải tính toán lại hoặc truy cập nguồn dữ liệu chậm."
  },
  {
    "question": "55. Ví dụ nào sau đây là một \"tactic\" để hỗ trợ tính bảo mật (security)?",
    "a": "Tăng số lượng các lớp trong hệ thống.",
    "b": "Phân quyền truy cập (Access Control / Authorization).",
    "c": "Gộp nhiều chức năng vào một module duy nhất.",
    "d": "Sử dụng CSS để ẩn thông tin.",
    "answer": "B",
    "theory": "Phân quyền truy cập (Access Control hay Authorization) là một tactic bảo mật quan trọng, đảm bảo rằng người dùng hoặc các thành phần hệ thống chỉ có thể truy cập vào những tài nguyên và thực hiện những hành động mà họ được phép."
  },
  {
    "question": "56. Mục tiêu chính của thiết kế kiến trúc KHÔNG bao gồm:",
    "a": "Đảm bảo bảo mật.",
    "b": "Viết mã nguồn nhanh hơn.",
    "c": "Lựa chọn mẫu kiến trúc phù hợp.",
    "d": "Phản ánh yêu cầu phi chức năng.",
    "answer": "B",
    "theory": "Thiết kế kiến trúc tập trung vào việc đáp ứng các yêu cầu (đặc biệt là phi chức năng), lựa chọn cấu trúc và các mẫu phù hợp để đảm bảo chất lượng hệ thống. Việc \"viết mã nguồn nhanh hơn\" có thể là một hệ quả của kiến trúc tốt (dễ hiểu, module hóa), nhưng không phải là mục tiêu chính trực tiếp của thiết kế kiến trúc."
  },
  {
    "question": "57. Một lợi ích chính của kiến trúc phần mềm là:",
    "a": "Giảm bớt kiểm thử.",
    "b": "Bỏ qua tài liệu hóa.",
    "c": "Tăng khả năng mở rộng và bảo trì.",
    "d": "Giảm yêu cầu người dùng.",
    "answer": "C",
    "theory": "Một kiến trúc được thiết kế tốt giúp hệ thống dễ dàng mở rộng để đáp ứng nhu cầu tăng trưởng và dễ dàng bảo trì (sửa lỗi, cải tiến) trong suốt vòng đời của nó."
  },
  {
    "question": "58. Thiết kế kiến trúc là cầu nối giữa:",
    "a": "Giao diện người dùng và logic nghiệp vụ.",
    "b": "Phân tích yêu cầu và thiết kế chi tiết.",
    "c": "Viết mã và kiểm thử.",
    "d": "Khách hàng và người kiểm thử.",
    "answer": "B",
    "theory": "Thiết kế kiến trúc lấy đầu vào từ giai đoạn phân tích yêu cầu (bao gồm các yêu cầu chức năng và phi chức năng) và tạo ra một cấu trúc ở mức cao, làm nền tảng và hướng dẫn cho giai đoạn thiết kế chi tiết và hiện thực."
  },
  {
    "question": "59. Một bước quan trọng trong quy trình thiết kế kiến trúc là:",
    "a": "Hiểu yêu cầu.",
    "b": "Tạo biểu đồ lớp UML.",
    "c": "Viết giao diện đồ họa.",
    "d": "Lập kế hoạch kiểm thử.",
    "answer": "A",
    "theory": "Hiểu rõ các yêu cầu của hệ thống, bao gồm cả yêu cầu chức năng, phi chức năng và các ràng buộc, là bước khởi đầu và là nền tảng không thể thiếu cho việc thiết kế kiến trúc phù hợp."
  },
  {
    "question": "60. Trong các quyết định kiến trúc, việc phân tách module dựa vào:",
    "a": "Kích thước mã nguồn.",
    "b": "Chức năng và khả năng thay đổi độc lập.",
    "c": "Tên biến sử dụng.",
    "d": "Ngôn ngữ lập trình.",
    "answer": "B",
    "theory": "Việc phân tách hệ thống thành các module (hay component) nên dựa trên sự gắn kết chức năng (functional cohesion) - mỗi module thực hiện một tập hợp các chức năng liên quan chặt chẽ - và khớp nối lỏng (loose coupling) để các module có thể được phát triển, kiểm thử và thay đổi một cách độc lập."
  },
  {
    "question": "61. Chiến lược điều phối tập trung thường sử dụng:",
    "a": "Pipe-and-Filter.",
    "b": "MVC.",
    "c": "Controller trung tâm hoặc message queue.",
    "d": "Client tự điều phối.",
    "answer": "C",
    "theory": "Trong kiến trúc với điều phối tập trung, có một thành phần trung tâm (ví dụ: một controller, một message broker/queue, một event bus) chịu trách nhiệm điều phối sự tương tác và luồng công việc giữa các thành phần khác."
  },
  {
    "question": "62. Một kiến trúc tốt giúp:",
    "a": "Viết code nhanh hơn.",
    "b": "Tránh mọi lỗi phần mềm.",
    "c": "Dễ bảo trì và mở rộng.",
    "d": "Giảm yêu cầu kỹ thuật.",
    "answer": "C",
    "theory": "Kiến trúc tốt tạo ra một hệ thống có cấu trúc rõ ràng, dễ hiểu, các thành phần có trách nhiệm cụ thể và ít phụ thuộc lẫn nhau. Điều này giúp cho việc bảo trì (sửa lỗi, nâng cấp) và mở rộng (thêm chức năng mới) trở nên dễ dàng hơn."
  },
  {
    "question": "63. Một yếu tố phi chức năng được kiến trúc phản ánh là:",
    "a": "Giao diện đồ họa.",
    "b": "Bảo mật.",
    "c": "Dữ liệu người dùng.",
    "d": "Tên hàm.",
    "answer": "B",
    "theory": "Các yêu cầu phi chức năng như bảo mật, hiệu năng, khả năng mở rộng, độ tin cậy là những yếu tố quan trọng mà kiến trúc phần mềm phải được thiết kế để đáp ứng. Ví dụ, lựa chọn kiến trúc phân tầng với các lớp bảo mật riêng biệt, hoặc sử dụng các tactic mã hóa, xác thực."
  },
  {
    "question": "64. Biểu diễn “Box-and-Line” dùng để:",
    "a": "Viết thuật toán.",
    "b": "Minh họa cấu trúc hệ thống bằng hộp và đường kết nối.",
    "c": "Giao tiếp với hệ điều hành.",
    "d": "Mô phỏng giao diện.",
    "answer": "B",
    "theory": "Sơ đồ \"Box-and-Line\" là một cách biểu diễn trực quan đơn giản, sử dụng các hộp (boxes) để đại diện cho các thành phần hoặc module của hệ thống và các đường kẻ (lines) để đại diện cho các mối quan hệ hoặc tương tác giữa chúng. Đây là một dạng cơ bản của mô tả kiến trúc."
  },
  {
    "question": "65. Mô hình 4+1 view có bao nhiêu góc nhìn chính?",
    "a": "3.",
    "b": "4.",
    "c": "5.",
    "d": "6.",
    "answer": "C",
    "theory": "Mô hình 4+1 view của Philippe Kruchten bao gồm 4 view chính (Logical, Process, Development, Physical) và 1 view bổ sung (+1) là Scenarios/Use Case View, tổng cộng là 5 view."
  },
  {
    "question": "66. Logical View thể hiện:",
    "a": "Chức năng hệ thống với người dùng cuối.",
    "b": "Mã nguồn.",
    "c": "Cấu trúc vật lý.",
    "d": "Kiểm thử.",
    "answer": "A",
    "theory": "Logical View mô tả các chức năng mà hệ thống cung cấp cho người dùng cuối. Nó thường được thể hiện qua các sơ đồ lớp, sơ đồ gói, và các sơ đồ tương tác mô tả logic nghiệp vụ."
  },
  {
    "question": "67. Physical View mô tả:",
    "a": "Tài liệu hướng dẫn.",
    "b": "Ánh xạ phần mềm vào phần cứng.",
    "c": "Biểu đồ lớp.",
    "d": "Giao diện.",
    "answer": "B",
    "theory": "Physical View (hay Deployment View) mô tả cách các thành phần phần mềm được triển khai và phân bố trên cơ sở hạ tầng phần cứng vật lý và mạng máy tính."
  },
  {
    "question": "68. View dùng sơ đồ trạng thái và hoạt động là:",
    "a": "Logical View.",
    "b": "Process View.",
    "c": "Development View.",
    "d": "Use Case.",
    "answer": "B",
    "theory": "Process View tập trung vào các khía cạnh động và đồng thời của hệ thống. Sơ đồ trạng thái có thể mô tả vòng đời của các tiến trình, và sơ đồ hoạt động có thể mô tả luồng công việc và sự tương tác giữa các tiến trình."
  },
  {
    "question": "69. Mẫu MVC gồm mấy thành phần chính?",
    "a": "2.",
    "b": "3.",
    "c": "4.",
    "d": "5.",
    "answer": "B",
    "theory": "Mẫu kiến trúc Model-View-Controller (MVC) bao gồm ba thành phần chính: Model, View, và Controller."
  },
  {
    "question": "70. Trong MVC, View đảm nhận:",
    "a": "Điều phối giữa các phần.",
    "b": "Lưu dữ liệu.",
    "c": "Hiển thị dữ liệu và nhận thao tác người dùng.",
    "d": "Thực thi mã.",
    "answer": "C",
    "theory": "View trong MVC chịu trách nhiệm hiển thị dữ liệu (thường từ Model) cho người dùng và nhận các thao tác đầu vào từ người dùng để chuyển cho Controller xử lý."
  },
  {
    "question": "71. Kiến trúc phân tầng (Layered) chia hệ thống theo:",
    "a": "Người dùng.",
    "b": "Mức độ trừu tượng và chức năng.",
    "c": "Ngôn ngữ lập trình.",
    "d": "Giao thức.",
    "answer": "B",
    "theory": "Kiến trúc phân tầng chia hệ thống thành các lớp (layers) ngang, mỗi lớp cung cấp một tập hợp các dịch vụ và có một mức độ trừu tượng nhất định. Các lớp được sắp xếp theo thứ tự, và một lớp thường chỉ sử dụng dịch vụ của lớp ngay bên dưới nó."
  },
  {
    "question": "72. Mẫu kiến trúc nào phù hợp cho hệ thống xử lý âm thanh?",
    "a": "MVC.",
    "b": "Layered.",
    "c": "Client-Server.",
    "d": "Pipe-and-Filter.",
    "answer": "D",
    "theory": "Hệ thống xử lý âm thanh thường bao gồm nhiều bước xử lý tuần tự (ví dụ: đọc file, giải mã, áp dụng hiệu ứng, mã hóa, ghi file). Mẫu Pipe-and-Filter, nơi dữ liệu âm thanh đi qua một chuỗi các bộ lọc (filters), rất phù hợp cho loại ứng dụng này."
  },
  {
    "question": "73. Nhược điểm của Repository là:",
    "a": "Khó bảo trì.",
    "b": "Trở thành nút cổ chai và điểm lỗi duy nhất.",
    "c": "Không lưu được dữ liệu.",
    "d": "Không dùng được cho web.",
    "answer": "B",
    "theory": "Trong kiến trúc Repository, kho dữ liệu trung tâm có thể trở thành một nút cổ chai (bottleneck) nếu có quá nhiều thành phần truy cập đồng thời. Nó cũng có thể là một điểm lỗi đơn (single point of failure) - nếu kho dữ liệu gặp sự cố, toàn bộ hệ thống có thể bị ảnh hưởng."
  },
  {
    "question": "74. Trong Client-Server, Client thường:",
    "a": "Cung cấp dịch vụ.",
    "b": "Không có vai trò.",
    "c": "Yêu cầu và hiển thị kết quả.",
    "d": "Lưu trữ dữ liệu chính.",
    "answer": "C",
    "theory": "Trong mô hình Client-Server, Client là thành phần khởi tạo yêu cầu dịch vụ đến Server và sau đó nhận, hiển thị kết quả do Server trả về."
  },
  {
    "question": "75. Mẫu Pipe-and-Filter phù hợp với:",
    "a": "Hệ thống phi tuần tự.",
    "b": "Biến đổi dữ liệu theo từng bước.",
    "c": "Giao tiếp đồng thời.",
    "d": "Giao diện phức tạp.",
    "answer": "B",
    "theory": "Pipe-and-Filter rất phù hợp cho các hệ thống mà dữ liệu được xử lý và biến đổi qua một chuỗi các bước (filters), nơi đầu ra của bước này là đầu vào của bước kế tiếp."
  },
  {
    "question": "76. Kiến trúc ứng dụng nhằm:",
    "a": "Giảm chi phí phần cứng.",
    "b": "Chuẩn hóa thiết kế cho các hệ thống cùng lĩnh vực.",
    "c": "Thay thế toàn bộ mã nguồn.",
    "d": "Giảm thời gian bảo trì.",
    "answer": "B",
    "theory": "Kiến trúc ứng dụng (Application Architecture) thường đề cập đến các mẫu và cấu trúc đã được chuẩn hóa hoặc đã được chứng minh là hiệu quả cho một loại ứng dụng hoặc một lĩnh vực cụ thể, giúp đảm bảo tính nhất quán và chất lượng."
  },
  {
    "question": "77. TPS thường được dùng trong:",
    "a": "Trò chơi điện tử.",
    "b": "Phân tích hình ảnh.",
    "c": "Ngân hàng, thương mại điện tử.",
    "d": "Hệ thống nhúng.",
    "answer": "C",
    "theory": "Hệ thống xử lý giao dịch (TPS) phổ biến trong các lĩnh vực như ngân hàng (chuyển khoản, rút tiền), thương mại điện tử (đặt hàng, thanh toán), hệ thống đặt vé, nơi cần xử lý một lượng lớn giao dịch một cách đáng tin cậy."
  },
  {
    "question": "78. Thuộc tính ACID KHÔNG bao gồm:",
    "a": "Atomicity.",
    "b": "Consistency.",
    "c": "Invisibility.",
    "d": "Durability.",
    "answer": "C",
    "theory": "ACID là viết tắt của Atomicity, Consistency, Isolation, và Durability. \"Invisibility\" không phải là một thuộc tính của ACID."
  },
  {
    "question": "79. Hệ thống đặt vé máy bay là ví dụ của:",
    "a": "Hệ thống xử lý ngôn ngữ.",
    "b": "Kiến trúc client-side.",
    "c": "TPS.",
    "d": "Hệ thống tĩnh.",
    "answer": "C",
    "theory": "Hệ thống đặt vé máy bay là một ví dụ điển hình của Hệ thống xử lý giao dịch (TPS) vì nó xử lý nhiều giao dịch đặt vé, yêu cầu tính toàn vẹn dữ liệu và khả năng phục vụ nhiều người dùng đồng thời."
  },
  {
    "question": "80. Các giai đoạn trong hệ xử lý ngôn ngữ gồm:",
    "a": "Lưu trữ → Trình bày → Truy vấn.",
    "b": "Phân tích từ vựng → Cú pháp → Ngữ nghĩa → Sinh mã.",
    "c": "Lập trình → Gỡ lỗi → Cài đặt.",
    "d": "Cấu hình → Biên dịch → Gửi.",
    "answer": "B",
    "theory": "Một quy trình xử lý ngôn ngữ điển hình (như trong trình biên dịch) bao gồm các giai đoạn chính: Phân tích từ vựng (Lexical Analysis), Phân tích cú pháp (Syntax Analysis), Phân tích ngữ nghĩa (Semantic Analysis), và Sinh mã (Code Generation)."
  },
  {
    "question": "81. Mẫu kiến trúc phù hợp cho hệ thống NLP:",
    "a": "Pipe-and-Filter.",
    "b": "MVC.",
    "c": "Layered.",
    "d": "Client-Server.",
    "answer": "A",
    "theory": "Hệ thống Xử lý Ngôn ngữ Tự nhiên (NLP) thường bao gồm nhiều bước xử lý văn bản tuần tự (ví dụ: tách từ, gán nhãn từ loại, phân tích cú pháp, trích xuất thực thể). Mẫu Pipe-and-Filter phù hợp để mô hình hóa chuỗi các bước xử lý này."
  },
  {
    "question": "82. IDE thường sử dụng mẫu kiến trúc nào?",
    "a": "MVC.",
    "b": "Pipe-and-Filter.",
    "c": "Repository.",
    "d": "Client-Server.",
    "answer": "C",
    "theory": "IDE (Môi trường phát triển tích hợp) thường sử dụng kiến trúc Repository (hoặc kiến trúc dựa trên plugin) để quản lý và tích hợp nhiều công cụ (trình soạn thảo, trình biên dịch, debugger) hoạt động trên một kho dữ liệu dự án chung."
  },
  {
    "question": "83. Kiến trúc phần mềm cần đảm bảo các yêu cầu nào sau?",
    "a": "Chức năng, bảo trì, hiệu suất, bảo mật.",
    "b": "Giao diện đẹp.",
    "c": "Phù hợp sở thích người dùng.",
    "d": "Giao tiếp mạng.",
    "answer": "A",
    "theory": "Một kiến trúc phần mềm tốt phải được thiết kế để đáp ứng cả các yêu cầu chức năng (hệ thống làm gì) và các yêu cầu phi chức năng (thuộc tính chất lượng như khả năng bảo trì, hiệu suất, bảo mật, khả năng mở rộng...)."
  },
  {
    "question": "84. Nguyên tắc quan trọng trong phân tách module:",
    "a": "Phân chia theo sở thích cá nhân.",
    "b": "Tách theo chức năng và khả năng thay đổi độc lập.",
    "c": "Tách ngẫu nhiên.",
    "d": "Không cần phân tách.",
    "answer": "B",
    "theory": "Nguyên tắc quan trọng khi phân tách hệ thống thành các module là đảm bảo tính gắn kết cao (high cohesion) - các phần tử trong một module liên quan chặt chẽ về chức năng - và tính khớp nối thấp (low coupling) - sự phụ thuộc giữa các module là tối thiểu. Điều này giúp các module có thể thay đổi độc lập."
  },
  {
    "question": "85. Yếu tố nào KHÔNG ảnh hưởng đến lựa chọn kiến trúc?",
    "a": "Hiệu năng.",
    "b": "Thời tiết.",
    "c": "Mở rộng.",
    "d": "Bảo trì.",
    "answer": "B",
    "theory": "Lựa chọn kiến trúc phụ thuộc vào nhiều yếu tố kỹ thuật và nghiệp vụ như yêu cầu về hiệu năng, khả năng mở rộng, khả năng bảo trì, chi phí, thời gian phát triển, công nghệ sẵn có. Thời tiết không phải là một yếu tố ảnh hưởng."
  },
  {
    "question": "86. Tài liệu hóa kiến trúc giúp:",
    "a": "Làm đẹp sơ đồ.",
    "b": "Lập trình nhanh hơn.",
    "c": "Truyền đạt và duy trì kiến trúc rõ ràng.",
    "d": "Giảm tài nguyên hệ thống.",
    "answer": "C",
    "theory": "Tài liệu hóa kiến trúc giúp truyền đạt các quyết định thiết kế, cấu trúc hệ thống cho các thành viên trong nhóm và các stakeholder khác. Nó cũng là cơ sở để duy trì và tiến hóa kiến trúc theo thời gian."
  },
  {
    "question": "87. Cầu nối giữa yêu cầu và hiện thực kỹ thuật là vai trò của?",
    "a": "UI.",
    "b": "Database.",
    "c": "Kiến trúc phần mềm.",
    "d": "Source code.",
    "answer": "C",
    "theory": "Kiến trúc phần mềm đóng vai trò là cầu nối quan trọng, chuyển hóa các yêu cầu (cả chức năng và phi chức năng) thành một cấu trúc hệ thống có thể được hiện thực bằng các kỹ thuật và công nghệ cụ thể."
  },
  {
    "question": "88. Lợi ích của việc có kiến trúc phần mềm rõ ràng là:",
    "a": "Tăng chi phí phát triển.",
    "b": "Gây khó khăn trong bảo trì.",
    "c": "Cầu nối giữa yêu cầu và kỹ thuật.",
    "d": "Tăng độ phức tạp hệ thống.",
    "answer": "C",
    "theory": "Một kiến trúc rõ ràng giúp định hướng cho việc phát triển, đảm bảo các quyết định kỹ thuật phù hợp với yêu cầu, và tạo điều kiện cho việc giao tiếp và phối hợp hiệu quả trong đội ngũ."
  },
  {
    "question": "89. Kiến trúc rõ ràng giúp?",
    "a": "Phát triển nhanh hơn.",
    "b": "Giao tiếp hiệu quả giữa các bên liên quan.",
    "c": "Giảm hiệu suất.",
    "d": "Tăng sự mâu thuẫn.",
    "answer": "B",
    "theory": "Một kiến trúc được định nghĩa và tài liệu hóa rõ ràng cung cấp một ngôn ngữ chung và một sự hiểu biết chung về hệ thống cho tất cả các bên liên quan, từ đó cải thiện giao tiếp và giảm thiểu hiểu lầm."
  },
  {
    "question": "90. Bước đầu tiên trong quy trình thiết kế kiến trúc là?",
    "a": "Lựa chọn công nghệ.",
    "b": "Hiểu yêu cầu.",
    "c": "Đánh giá kiến trúc.",
    "d": "Tài liệu hóa kiến trúc.",
    "answer": "B",
    "theory": "Việc hiểu rõ các yêu cầu (đặc biệt là yêu cầu phi chức năng và các ràng buộc) là bước đầu tiên và quan trọng nhất, làm nền tảng cho tất cả các quyết định thiết kế kiến trúc sau này."
  },
  {
    "question": "91. Công cụ nào thường được sử dụng để mô hình hóa kiến trúc?",
    "a": "Microsoft Word.",
    "b": "UML (sơ đồ lớp, sơ đồ triển khai, v.v.).",
    "c": "Excel.",
    "d": "PowerPoint.",
    "answer": "B",
    "theory": "UML (Unified Modeling Language) cung cấp một tập hợp các loại biểu đồ (như Biểu đồ Lớp, Biểu đồ Component, Biểu đồ Triển khai) rất hữu ích để mô tả các khía cạnh khác nhau của kiến trúc phần mềm một cách trực quan và chuẩn hóa."
  },
  {
    "question": "92. Quyết định nào sau đây là quan trọng trong thiết kế kiến trúc?",
    "a": "Chọn màu sắc giao diện.",
    "b": "Chọn kiến trúc phân tán hay tập trung.",
    "c": "Chỉ chọn ngôn ngữ lập trình.",
    "d": "Không cần chọn công nghệ.",
    "answer": "B",
    "theory": "Quyết định về việc hệ thống sẽ được xây dựng theo kiến trúc phân tán (ví dụ: microservices, client-server) hay tập trung (ví dụ: monolithic) là một quyết định kiến trúc quan trọng, ảnh hưởng lớn đến nhiều thuộc tính chất lượng như khả năng mở rộng, độ phức tạp, hiệu năng."
  },
  {
    "question": "93. Mục tiêu của việc biểu diễn kiến trúc là gì?",
    "a": "Chỉ để trang trí.",
    "b": "Truyền đạt quyết định thiết kế cho các nhóm liên quan và hỗ trợ bảo trì.",
    "c": "Chỉ để kiểm thử.",
    "d": "Không liên quan đến nhóm phát triển.",
    "answer": "B",
    "theory": "Việc biểu diễn kiến trúc (thường qua các sơ đồ và tài liệu) nhằm mục đích truyền đạt các quyết định thiết kế quan trọng, cấu trúc hệ thống cho đội ngũ phát triển, đội ngũ vận hành, và các stakeholder khác, cũng như làm cơ sở cho việc bảo trì và tiến hóa hệ thống."
  },
  {
    "question": "94. Ký hiệu \"Box-and-Line\" đại diện cho gì?",
    "a": "Các hộp là thành phần, đường thẳng là mối quan hệ giữa chúng.",
    "b": "Các hộp là dữ liệu, đường thẳng là giao diện.",
    "c": "Các hộp là công cụ, đường thẳng là mã nguồn.",
    "d": "Các hộp là người dùng, đường thẳng là yêu cầu.",
    "answer": "A",
    "theory": "Trong sơ đồ \"Box-and-Line\", các \"boxes\" thường đại diện cho các thành phần, module hoặc các đơn vị cấu trúc của hệ thống, và các \"lines\" thể hiện các mối quan hệ, liên kết hoặc luồng tương tác giữa các thành phần đó."
  },
  {
    "question": "95. Nhược điểm của ký hiệu \"Box-and-Line\" là gì?",
    "a": "Quá chi tiết.",
    "b": "Thiếu ngữ nghĩa chính xác nếu không giải thích.",
    "c": "Không phù hợp với giao tiếp.",
    "d": "Không thể sử dụng trong thiết kế.",
    "answer": "B",
    "theory": "Sơ đồ \"Box-and-Line\" rất linh hoạt nhưng cũng có nhược điểm là ngữ nghĩa của các hộp và đường kẻ có thể không rõ ràng nếu không có giải thích đi kèm. Các ngôn ngữ mô hình hóa chuẩn như UML cung cấp ngữ nghĩa rõ ràng hơn cho các ký hiệu."
  },
  {
    "question": "96. Mô hình 4+1 view do ai đề xuất?",
    "a": "Thomas Erl.",
    "b": "Philippe Kruchten.",
    "c": "Martin Fowler.",
    "d": "Robert C. Martin.",
    "answer": "B",
    "theory": "Mô hình 4+1 View Model để mô tả kiến trúc phần mềm được đề xuất bởi Philippe Kruchten vào năm 1995."
  },
  {
    "question": "97. Khi thiết kế kiến trúc, việc cân bằng giữa các thuộc tính chất lượng (quality attributes) thường đối mặt với thách thức nào?",
    "a": "Các thuộc tính chất lượng luôn bổ trợ lẫn nhau một cách hoàn hảo.",
    "b": "Thường phải có sự đánh đổi (trade-offs), vì việc tối ưu một thuộc tính (ví dụ: hiệu năng) có thể ảnh hưởng tiêu cực đến thuộc tính khác (ví dụ: bảo mật, khả năng bảo trì).",
    "c": "Chỉ cần tập trung vào việc đáp ứng yêu cầu chức năng là đủ, các thuộc tính chất lượng không quan trọng bằng.",
    "d": "Các thuộc tính chất lượng chỉ quan trọng đối với giao diện người dùng.",
    "answer": "B",
    "theory": "Trong thiết kế kiến trúc, việc cố gắng tối ưu một thuộc tính chất lượng (ví dụ: tăng hiệu năng) thường dẫn đến sự đánh đổi với các thuộc tính chất lượng khác (ví dụ: có thể làm tăng độ phức tạp, giảm khả năng bảo trì hoặc tăng chi phí). Các kiến trúc sư phải tìm cách cân bằng các đánh đổi này."
  },
  {
    "question": "98. Việc đánh giá kiến trúc (Architectural Evaluation) nên được thực hiện vào thời điểm nào trong quá trình phát triển để mang lại hiệu quả cao nhất?",
    "a": "Chỉ sau khi hệ thống đã hoàn thành và sẵn sàng triển khai.",
    "b": "Chỉ trong giai đoạn kiểm thử cuối cùng.",
    "c": "Càng sớm càng tốt trong chu trình thiết kế (ngay sau khi có bản phác thảo kiến trúc) và có thể lặp lại khi kiến trúc được tinh chỉnh.",
    "d": "Chỉ khi có vấn đề nghiêm trọng xảy ra trong quá trình phát triển.",
    "answer": "C",
    "theory": "Đánh giá kiến trúc nên được thực hiện càng sớm càng tốt trong vòng đời phát triển, ngay khi có các bản phác thảo kiến trúc ban đầu. Việc phát hiện và sửa chữa các vấn đề kiến trúc sớm sẽ tốn ít chi phí hơn nhiều so với việc sửa chúng ở các giai đoạn sau."
  },
  {
    "question": "99. Hiện tượng \"Architectural Drift\" (hay \"Architectural Erosion\" - Xói mòn kiến trúc) mô tả điều gì?",
    "a": "Việc kiến trúc phần mềm trở nên quá phức tạp không cần thiết.",
    "b": "Sự sai lệch dần dần của cấu trúc hệ thống thực tế so với thiết kế kiến trúc ban đầu theo thời gian, thường do các thay đổi cục bộ không tuân thủ nguyên tắc kiến trúc.",
    "c": "Việc thay đổi hoàn toàn mẫu kiến trúc đã chọn giữa chừng dự án.",
    "d": "Việc thiếu hoàn toàn tài liệu mô tả kiến trúc.",
    "answer": "B",
    "theory": "Xói mòn kiến trúc (Architectural Drift/Erosion) là hiện tượng cấu trúc thực tế của hệ thống ngày càng sai lệch so với thiết kế kiến trúc ban đầu qua thời gian. Điều này thường xảy ra do các thay đổi, sửa lỗi, hoặc bổ sung tính năng được thực hiện mà không tuân thủ chặt chẽ các nguyên tắc và ràng buộc của kiến trúc đã định."
  },
  {
    "question": "100. \"Architectural Style\" (Kiểu kiến trúc) và \"Architectural Pattern\" (Mẫu kiến trúc) thường được phân biệt như thế nào?",
    "a": "Style là một giải pháp cụ thể, Pattern là một vấn đề chung chung.",
    "b": "Pattern mô tả một giải pháp đã được chứng minh cho một vấn đề thiết kế cụ thể, lặp đi lặp lại; Style mô tả một cách tiếp cận, một triết lý tổ chức hệ thống ở mức cao hơn, định hình cấu trúc tổng thể (ví dụ: Client-Server là một style, MVC là một pattern).",
    "c": "Không có sự khác biệt rõ ràng, chúng thường được dùng thay thế cho nhau.",
    "d": "Style chỉ áp dụng cho các hệ thống phân tán, Pattern áp dụng cho mọi hệ thống.",
    "answer": "B",
    "theory": "Architectural Style (Kiểu kiến trúc) là một tập hợp các nguyên tắc và ràng buộc về cách tổ chức hệ thống ở mức cao (ví dụ: Client-Server, Layered, Pipe-and-Filter). Architectural Pattern (Mẫu kiến trúc) là một giải pháp đã được kiểm chứng cho một vấn đề thiết kế cụ thể, thường có phạm vi nhỏ hơn Style (ví dụ: MVC, Repository). Một Style có thể được hiện thực hóa bằng nhiều Pattern khác nhau."
  },

  {
    "question": "1. Hoạt động sáng tạo nhằm xác định các thành phần của phần mềm và mối liên kết giữa chúng, dựa trên yêu cầu khách hàng được gọi là gì?",
    "a": "Hiện thực (Implementation)",
    "b": "Kiểm thử (Testing)",
    "c": "Thiết kế (Design)",
    "d": "Bảo trì (Maintenance)",
    "answer": "C",
    "theory": "Thiết kế phần mềm là quá trình định nghĩa kiến trúc, các thành phần, module, giao diện, và dữ liệu cho một hệ thống phần mềm để đáp ứng các yêu cầu đã được xác định."
  },
  {
    "question": "2. Quá trình hiện thực hóa thiết kế thành chương trình chạy được gọi là gì?",
    "a": "Phân tích yêu cầu (Requirements Analysis)",
    "b": "Thiết kế (Design)",
    "c": "Hiện thực (Implementation)",
    "d": "Đặc tả (Specification)",
    "answer": "C",
    "theory": "Hiện thực (Implementation) hay lập trình (coding) là quá trình chuyển đổi các đặc tả thiết kế thành mã nguồn có thể thực thi được bằng một ngôn ngữ lập trình cụ thể."
  },
  {
    "question": "3. Mối quan hệ giữa Thiết kế và Hiện thực trong phát triển phần mềm thường như thế nào?",
    "a": "Là hai giai đoạn hoàn toàn tách biệt, tuyến tính.",
    "b": "Hiện thực luôn diễn ra trước Thiết kế.",
    "c": "Là các hoạt động đan xen, lặp đi lặp lại.",
    "d": "Thiết kế chỉ cần thiết cho các dự án lớn.",
    "answer": "C",
    "theory": "Trong các quy trình phát triển hiện đại, thiết kế và hiện thực thường là các hoạt động lặp đi lặp lại và đan xen. Thiết kế ban đầu có thể được hiện thực một phần, sau đó dựa trên phản hồi và hiểu biết mới, thiết kế lại được tinh chỉnh và hiện thực tiếp."
  },
  {
    "question": "4. Phương pháp chính được đề cập trong outline để cấu trúc phần mềm là gì?",
    "a": "Lập trình hướng thủ tục (Procedural Programming)",
    "b": "Thiết kế hướng đối tượng (Object-Oriented Design - OOD) sử dụng UML",
    "c": "Phát triển dựa trên component (Component-Based Development)",
    "d": "Lập trình Agile (Agile Programming)",
    "answer": "B",
    "theory": "Thiết kế hướng đối tượng (OOD) là một phương pháp thiết kế phần mềm tập trung vào việc xác định các lớp và đối tượng, cùng với các thuộc tính, hành vi và mối quan hệ của chúng. UML là một ngôn ngữ mô hình hóa thường được sử dụng để biểu diễn các thiết kế OOD."
  },
  {
    "question": "5. Giai đoạn đầu tiên trong quy trình thiết kế OOD thường là gì?",
    "a": "Nhận diện lớp/đối tượng chính.",
    "b": "Thiết kế kiến trúc hệ thống.",
    "c": "Phát triển mô hình thiết kế chi tiết.",
    "d": "Xác định ngữ cảnh và tương tác của hệ thống.",
    "answer": "D",
    "theory": "Trước khi đi vào thiết kế chi tiết, một bước quan trọng trong OOD là hiểu rõ ngữ cảnh mà hệ thống sẽ hoạt động (ví dụ: thông qua mô hình ngữ cảnh, use cases) và cách nó sẽ tương tác với các thực thể bên ngoài. Điều này giúp xác định các yêu cầu và ràng buộc ban đầu."
  },
  {
    "question": "6. Việc hiểu môi trường hoạt động và cách hệ thống tương tác với các hệ thống khác/người dùng (Xác định ngữ cảnh và tương tác) thường sử dụng công cụ/mô hình nào?",
    "a": "Chỉ Biểu đồ lớp (Class Diagram).",
    "b": "Chỉ Biểu đồ trạng thái (State Diagram).",
    "c": "Mô hình ngữ cảnh (Context Model) và Biểu đồ Use Case.",
    "d": "Mô hình triển khai (Deployment Diagram).",
    "answer": "C",
    "theory": "Mô hình ngữ cảnh giúp xác định ranh giới và các tương tác bên ngoài của hệ thống. Biểu đồ Use Case mô tả các chức năng mà hệ thống cung cấp cho người dùng (actors) và cách họ tương tác với hệ thống, giúp làm rõ ngữ cảnh sử dụng."
  },
  {
    "question": "7. Mục đích chính của giai đoạn \"Thiết kế kiến trúc hệ thống\" trong OOD là gì?",
    "a": "Viết mã chi tiết cho từng lớp.",
    "b": "Xác định các thành phần chính (subsystems), cách chúng giao tiếp và lựa chọn mẫu kiến trúc phù hợp.",
    "c": "Thu thập yêu cầu từ khách hàng.",
    "d": "Kiểm thử giao diện người dùng.",
    "answer": "B",
    "theory": "Thiết kế kiến trúc hệ thống trong OOD tập trung vào việc xác định cấu trúc tổng thể của hệ thống, bao gồm việc chia hệ thống thành các thành phần lớn (subsystems hoặc packages), xác định giao diện và cách chúng tương tác, và lựa chọn các mẫu kiến trúc (architectural patterns) phù hợp."
  },
  {
    "question": "8. Các mẫu kiến trúc nào thường được xem xét trong giai đoạn thiết kế kiến trúc hệ thống?",
    "a": "Chỉ MVC.",
    "b": "Chỉ Pipe-and-Filter.",
    "c": "Client-Server, Phân tầng (Layered), MVC, Repository, v.v.",
    "d": "Chỉ Microservices.",
    "answer": "C",
    "theory": "Trong giai đoạn thiết kế kiến trúc, các nhà thiết kế sẽ xem xét và lựa chọn các mẫu kiến trúc phù hợp với yêu cầu và đặc điểm của hệ thống. Các mẫu phổ biến bao gồm Client-Server, Layered, Model-View-Controller (MVC), Repository, Pipe-and-Filter, Microservices, v.v."
  },
  {
    "question": "9. Phương pháp nào KHÔNG được đề cập trong outline để nhận diện lớp/đối tượng chính?",
    "a": "Phân tích ngữ pháp dựa trên mô tả hệ thống.",
    "b": "Nhận diện các thực thể hữu hình trong phạm vi ứng dụng.",
    "c": "Phân tích hành vi và các đối tượng tham gia.",
    "d": "Phân tích hiệu năng hệ thống.",
    "answer": "D",
    "theory": "Các phương pháp phổ biến để nhận diện lớp/đối tượng bao gồm phân tích ngữ pháp (tìm danh từ, động từ), nhận diện các khái niệm và thực thể trong miền vấn đề, và phân tích các hành vi/tương tác. Phân tích hiệu năng thường liên quan đến đánh giá kiến trúc hoặc thiết kế, không phải là phương pháp chính để nhận diện lớp."
  },
  {
    "question": "10. Giai đoạn \"Phát triển mô hình thiết kế\" trong OOD tập trung vào việc gì?",
    "a": "Chỉ xác định yêu cầu phi chức năng.",
    "b": "Chỉ vẽ mô hình ngữ cảnh.",
    "c": "Chi tiết hóa cấu trúc (mô hình tĩnh) và hành vi (mô hình động) của hệ thống.",
    "d": "Lựa chọn ngôn ngữ lập trình.",
    "answer": "C",
    "theory": "Sau khi có kiến trúc tổng thể, giai đoạn phát triển mô hình thiết kế tập trung vào việc chi tiết hóa các thành phần. Mô hình tĩnh (ví dụ: Biểu đồ Lớp chi tiết) mô tả cấu trúc các lớp, thuộc tính, phương thức, mối quan hệ. Mô hình động (ví dụ: Biểu đồ Tuần tự, Biểu đồ Trạng thái) mô tả hành vi và tương tác của các đối tượng."
  },
  {
    "question": "11. Mô hình tĩnh trong thiết kế OOD thường được thể hiện bằng biểu đồ UML nào?",
    "a": "Biểu đồ Hoạt động (Activity Diagram).",
    "b": "Biểu đồ Tuần tự (Sequence Diagram).",
    "c": "Biểu đồ Lớp (Class Diagram).",
    "d": "Biểu đồ Use Case (Use Case Diagram).",
    "answer": "C",
    "theory": "Biểu đồ Lớp (Class Diagram) là công cụ chính để mô tả mô hình tĩnh trong OOD, thể hiện các lớp, thuộc tính, phương thức và các mối quan hệ tĩnh giữa chúng."
  },
  {
    "question": "12. Biểu đồ lớp (Class Diagram) KHÔNG thể hiện thông tin nào sau đây?",
    "a": "Tên các lớp đối tượng.",
    "b": "Các thuộc tính của lớp.",
    "c": "Trình tự tương tác theo thời gian giữa các đối tượng.",
    "d": "Các phương thức của lớp và mối quan hệ giữa các lớp.",
    "answer": "C",
    "theory": "Biểu đồ Lớp mô tả cấu trúc tĩnh. Trình tự tương tác theo thời gian giữa các đối tượng là một khía cạnh động, thường được mô tả bằng Biểu đồ Tuần tự hoặc các biểu đồ tương tác khác."
  },
  {
    "question": "13. Các loại mối quan hệ nào thường được biểu diễn trong Biểu đồ lớp?",
    "a": "Chỉ thừa kế (Generalization).",
    "b": "Chỉ liên kết (Association).",
    "c": "Association, Aggregation, Composition, Generalization.",
    "d": "Chỉ phụ thuộc (Dependency).",
    "answer": "C",
    "theory": "Biểu đồ Lớp có thể biểu diễn nhiều loại mối quan hệ tĩnh giữa các lớp, bao gồm: Association (liên kết chung), Aggregation (cộng gộp), Composition (bao gộp/thành phần), Generalization (thừa kế), và Dependency (phụ thuộc)."
  },
  {
    "question": "14. Mô hình động trong thiết kế OOD mô tả khía cạnh nào của hệ thống?",
    "a": "Cấu trúc tổ chức các module mã nguồn.",
    "b": "Cách các đối tượng tương tác với nhau theo thời gian hoặc thay đổi trạng thái.",
    "c": "Cách triển khai hệ thống lên phần cứng.",
    "d": "Mối quan hệ tĩnh giữa các lớp.",
    "answer": "B",
    "theory": "Mô hình động trong OOD tập trung vào hành vi của hệ thống khi nó chạy, bao gồm cách các đối tượng tương tác (ví dụ: gửi thông điệp), trình tự các tương tác, và sự thay đổi trạng thái của các đối tượng theo thời gian."
  },
  {
    "question": "15. Biểu đồ UML nào dùng để mô tả tương tác theo thời gian giữa các đối tượng?",
    "a": "Biểu đồ Lớp (Class Diagram).",
    "b": "Biểu đồ Trạng thái (State Diagram).",
    "c": "Biểu đồ Hoạt động (Activity Diagram).",
    "d": "Biểu đồ Tuần tự (Sequence Diagram).",
    "answer": "D",
    "theory": "Biểu đồ Tuần tự (Sequence Diagram) là một loại biểu đồ tương tác, được sử dụng để mô tả cách các đối tượng giao tiếp với nhau bằng cách gửi và nhận thông điệp theo một trình tự thời gian cụ thể."
  },
  {
    "question": "16. Biểu đồ UML nào dùng để mô tả sự thay đổi trạng thái của một đối tượng khi phản ứng với sự kiện?",
    "a": "Biểu đồ Lớp (Class Diagram).",
    "b": "Biểu đồ Tuần tự (Sequence Diagram).",
    "c": "Biểu đồ Trạng thái (State Diagram).",
    "d": "Biểu đồ Component (Component Diagram).",
    "answer": "C",
    "theory": "Biểu đồ Trạng thái (State Machine Diagram) mô tả các trạng thái khác nhau mà một đối tượng có thể trải qua trong vòng đời của nó, các sự kiện gây ra sự chuyển đổi giữa các trạng thái, và các hành động được thực hiện."
  },
  {
    "question": "17. \"Đặc tả giao diện đối tượng\" (Interface Specification) quan trọng vì sao?",
    "a": "Chỉ để tăng số lượng tài liệu.",
    "b": "Cho phép các đối tượng/component được thiết kế và phát triển song song, độc lập.",
    "c": "Chỉ cần thiết cho các hệ thống nhỏ.",
    "d": "Để mô tả chi tiết thuật toán bên trong.",
    "answer": "B",
    "theory": "Đặc tả giao diện (interface) định nghĩa \"hợp đồng\" về cách một đối tượng hoặc component có thể được sử dụng bởi các đối tượng/component khác, mà không cần biết chi tiết hiện thực bên trong. Điều này cho phép phát triển song song, độc lập và dễ dàng thay thế các hiện thực."
  },
  {
    "question": "18. Mẫu thiết kế (Design Pattern) là gì?",
    "a": "Một đoạn mã nguồn cụ thể giải quyết một vấn đề.",
    "b": "Một cách tái sử dụng kiến thức trừu tượng về một vấn đề thiết kế thường gặp và giải pháp đã được kiểm chứng.",
    "c": "Một quy trình quản lý dự án.",
    "d": "Một công cụ vẽ sơ đồ UML.",
    "answer": "B",
    "theory": "Mẫu thiết kế là một giải pháp chung, có thể tái sử dụng cho một vấn đề thường gặp trong một ngữ cảnh thiết kế phần mềm cụ thể. Nó không phải là một đoạn code cụ thể mà là một mô tả hoặc template về cách giải quyết vấn đề."
  },
  {
    "question": "19. Các thành phần cơ bản của một mô tả mẫu thiết kế thường bao gồm:",
    "a": "Chỉ Tên và Mã nguồn ví dụ.",
    "b": "Chỉ Mục đích và Ưu điểm.",
    "c": "Tên, Mô tả vấn đề, Mô tả giải pháp (template), Hệ quả (Consequences).",
    "d": "Tên lớp, Thuộc tính, Phương thức.",
    "answer": "C",
    "theory": "Một mô tả mẫu thiết kế đầy đủ thường bao gồm: Tên mẫu, Bối cảnh/Vấn đề mà mẫu giải quyết, Giải pháp (cấu trúc, các thành phần tham gia, và sự tương tác của chúng), và Hệ quả (ưu điểm, nhược điểm, và các đánh đổi khi áp dụng mẫu)."
  },
  {
    "question": "20. Mục đích chính của mẫu Observer là gì?",
    "a": "Đơn giản hóa việc truy cập một hệ thống con phức tạp.",
    "b": "Tách rời việc biểu diễn trạng thái (View) khỏi đối tượng dữ liệu (Model) để dễ dàng cập nhật và thay đổi cách hiển thị.",
    "c": "Cung cấp cách duyệt qua các phần tử của một tập hợp mà không cần biết cấu trúc bên trong.",
    "d": "Thêm chức năng mới vào đối tượng một cách linh hoạt.",
    "answer": "B",
    "theory": "Mẫu Observer định nghĩa một mối quan hệ phụ thuộc một-nhiều giữa các đối tượng, sao cho khi một đối tượng (Subject/Model) thay đổi trạng thái, tất cả các đối tượng phụ thuộc (Observers/Views) của nó sẽ được thông báo và cập nhật tự động. Điều này giúp tách rời Subject và Observers."
  },
  {
    "question": "21. Trong mẫu Observer, thành phần nào chịu trách nhiệm lưu trữ trạng thái và thông báo cho các thành phần khác khi trạng thái thay đổi?",
    "a": "Observer (trừu tượng).",
    "b": "ConcreteObserver (cụ thể).",
    "c": "Subject (trừu tượng) / ConcreteSubject (cụ thể).",
    "d": "Controller.",
    "answer": "C",
    "theory": "Subject (hay Observable) là thành phần nắm giữ trạng thái và có danh sách các Observers. Khi trạng thái của Subject thay đổi, nó sẽ thông báo cho tất cả các Observers đã đăng ký."
  },
  {
    "question": "22. Trong mẫu Observer, thành phần nào chịu trách nhiệm nhận thông báo và cập nhật cách hiển thị của nó?",
    "a": "Subject (trừu tượng).",
    "b": "ConcreteSubject (cụ thể).",
    "c": "Observer (trừu tượng) / ConcreteObserver (cụ thể).",
    "d": "Model.",
    "answer": "C",
    "theory": "Observer là thành phần đăng ký với Subject để nhận thông báo khi trạng thái của Subject thay đổi. Khi nhận được thông báo, Observer sẽ cập nhật trạng thái hoặc cách hiển thị của chính nó."
  },
  {
    "question": "23. Ưu điểm chính của mẫu Observer là gì?",
    "a": "Luôn cải thiện hiệu năng hệ thống.",
    "b": "Giảm sự phụ thuộc giữa đối tượng dữ liệu và các đối tượng hiển thị nó.",
    "c": "Cấu trúc code luôn đơn giản nhất.",
    "d": "Loại bỏ hoàn toàn việc cập nhật không cần thiết.",
    "answer": "B",
    "theory": "Mẫu Observer giúp giảm sự khớp nối (coupling) giữa Subject và Observers. Subject không cần biết chi tiết về các Observers, chỉ cần biết chúng có một interface chung để nhận thông báo. Điều này làm tăng tính linh hoạt và khả năng tái sử dụng."
  },
  {
    "question": "24. Nhược điểm tiềm ẩn của mẫu Observer là gì?",
    "a": "Khó thêm các cách hiển thị mới.",
    "b": "Tăng sự phụ thuộc giữa các thành phần.",
    "c": "Có thể ảnh hưởng đến hiệu năng do việc cập nhật liên tục, đôi khi không cần thiết cho tất cả các Observer.",
    "d": "Chỉ áp dụng được cho giao diện đồ họa.",
    "answer": "C",
    "theory": "Nếu có nhiều Observers và Subject thay đổi trạng thái thường xuyên, việc thông báo và cập nhật cho tất cả các Observers có thể gây ra vấn đề về hiệu năng, đặc biệt nếu một số cập nhật là không cần thiết hoặc tốn kém."
  },
  {
    "question": "25. Mẫu thiết kế nào dùng để cung cấp một giao diện đơn giản, thống nhất cho một tập hợp các giao diện phức tạp trong một hệ thống con?",
    "a": "Observer.",
    "b": "Iterator.",
    "c": "Decorator.",
    "d": "Façade.",
    "answer": "D",
    "theory": "Mẫu Façade cung cấp một giao diện đơn giản hóa cho một hệ thống con (subsystem) phức tạp bao gồm nhiều lớp hoặc giao diện. Client chỉ cần tương tác với Façade thay vì phải biết và tương tác với tất cả các thành phần bên trong hệ thống con."
  },
  {
    "question": "26. Mẫu thiết kế nào cung cấp một cách tuần tự truy cập các phần tử của một đối tượng tập hợp mà không cần phơi bày cấu trúc bên trong của nó?",
    "a": "Observer.",
    "b": "Iterator.",
    "c": "Decorator.",
    "d": "Façade.",
    "answer": "B",
    "theory": "Mẫu Iterator cung cấp một phương thức chuẩn để duyệt qua các phần tử của một đối tượng tập hợp (ví dụ: list, array) một cách tuần tự, mà không cần client phải biết về cách cấu trúc và lưu trữ bên trong của tập hợp đó."
  },
  {
    "question": "27. Mẫu thiết kế nào cho phép thêm các trách nhiệm/chức năng mới vào một đối tượng một cách linh hoạt, động tại thời điểm chạy?",
    "a": "Observer.",
    "b": "Iterator.",
    "c": "Decorator.",
    "d": "Façade.",
    "answer": "C",
    "theory": "Mẫu Decorator cho phép gắn thêm các hành vi hoặc trách nhiệm mới cho một đối tượng một cách động, bằng cách \"bao bọc\" đối tượng gốc bằng một hoặc nhiều đối tượng decorator. Nó là một giải pháp thay thế linh hoạt cho việc sử dụng kế thừa để mở rộng chức năng."
  },
  {
    "question": "28. Phát triển mã nguồn mở (Open Source Development) là gì?",
    "a": "Một phương pháp thiết kế giao diện người dùng.",
    "b": "Một cách tiếp cận phát triển phần mềm mà mã nguồn được công bố công khai và cộng đồng có thể tham gia đóng góp.",
    "c": "Một loại giấy phép bản quyền phần mềm cụ thể.",
    "d": "Một kỹ thuật tối ưu hóa cơ sở dữ liệu.",
    "answer": "B",
    "theory": "Phát triển mã nguồn mở là một mô hình phát triển phần mềm trong đó mã nguồn được công khai, cho phép mọi người xem, sửa đổi và phân phối lại. Nó thường dựa trên sự hợp tác của cộng đồng."
  },
  {
    "question": "29. Đâu KHÔNG phải là ví dụ về phần mềm mã nguồn mở nổi tiếng được đề cập?",
    "a": "Linux.",
    "b": "Microsoft Windows.",
    "c": "Apache Web Server.",
    "d": "MySQL.",
    "answer": "B",
    "theory": "Linux, Apache Web Server, và MySQL là các ví dụ nổi tiếng về phần mềm mã nguồn mở. Microsoft Windows là một hệ điều hành thương mại, mã nguồn đóng (proprietary)."
  },
  {
    "question": "30. Mô hình kinh doanh phổ biến của các công ty phát triển phần mềm mã nguồn mở thường dựa vào việc gì?",
    "a": "Bán bản quyền sử dụng phần mềm.",
    "b": "Bán dịch vụ hỗ trợ, tư vấn, đào tạo liên quan đến phần mềm.",
    "c": "Thu phí trên mỗi lượt tải về.",
    "d": "Quảng cáo tích hợp trong phần mềm.",
    "answer": "B",
    "theory": "Nhiều công ty phát triển phần mềm mã nguồn mở kiếm doanh thu bằng cách cung cấp các dịch vụ giá trị gia tăng xung quanh sản phẩm mã nguồn mở của họ, chẳng hạn như hỗ trợ kỹ thuật, tư vấn triển khai, tùy chỉnh, hoặc các phiên bản thương mại với tính năng bổ sung."
  },
  {
    "question": "31. Việc mã nguồn được công bố trong phát triển mã nguồn mở có nghĩa là gì?",
    "a": "Bất kỳ ai cũng có thể làm mọi thứ với mã nguồn đó mà không có ràng buộc.",
    "b": "Mã nguồn có sẵn để xem xét, sửa đổi nhưng việc sử dụng và phân phối lại phải tuân theo các điều khoản của giấy phép đi kèm.",
    "c": "Mã nguồn chỉ được xem, không được sửa đổi.",
    "d": "Chỉ những người trả tiền mới được xem mã nguồn.",
    "answer": "B",
    "theory": "Mặc dù mã nguồn mở được công khai, việc sử dụng, sửa đổi và phân phối lại nó vẫn phải tuân thủ các điều khoản của giấy phép mã nguồn mở (ví dụ: GPL, MIT, Apache) đi kèm với phần mềm đó. Các giấy phép này có các quy định khác nhau."
  },
  {
    "question": "32. Loại giấy phép mã nguồn mở nào yêu cầu các sản phẩm phái sinh (derived work) cũng phải được phát hành dưới dạng mã nguồn mở?",
    "a": "BSD License.",
    "b": "MIT License.",
    "c": "GPL (GNU General Public License).",
    "d": "Apache License.",
    "answer": "C",
    "theory": "Giấy phép GPL (GNU General Public License) là một giấy phép \"copyleft\" mạnh, yêu cầu rằng bất kỳ phần mềm nào được tạo ra dựa trên (phái sinh từ) mã nguồn cấp phép GPL cũng phải được phát hành dưới giấy phép GPL (hoặc một giấy phép tương thích), đảm bảo tính mở của các sản phẩm phái sinh."
  },
  {
    "question": "33. Loại giấy phép mã nguồn mở nào cho phép tích hợp mã nguồn mở vào sản phẩm thương mại độc quyền mà không yêu cầu phải mở mã nguồn của sản phẩm đó?",
    "a": "GPL (GNU General Public License).",
    "b": "LGPL (GNU Lesser General Public License) - trong một số trường hợp liên kết thư viện.",
    "c": "BSD License / MIT License.",
    "d": "Cả b và c đều đúng trong nhiều trường hợp.",
    "answer": "D",
    "theory": "Các giấy phép \"permissive\" như BSD, MIT, và Apache thường cho phép tích hợp mã nguồn mở vào các sản phẩm thương mại độc quyền mà không yêu cầu sản phẩm đó phải mở mã nguồn. LGPL cũng cho phép điều này đối với việc liên kết động thư viện, trong khi việc sửa đổi trực tiếp thư viện LGPL vẫn có thể yêu cầu mở mã nguồn phần sửa đổi."
  },
  {
    "question": "34. Tại sao việc quản lý bản quyền cẩn thận lại quan trọng khi sử dụng component mã nguồn mở?",
    "a": "Để tránh vi phạm các điều khoản giấy phép và các vấn đề pháp lý tiềm ẩn.",
    "b": "Để đảm bảo mã nguồn luôn là phiên bản mới nhất.",
    "c": "Để tối ưu hóa hiệu năng của component.",
    "d": "Chỉ là thủ tục không cần thiết.",
    "answer": "A",
    "theory": "Mỗi component mã nguồn mở đều đi kèm với một giấy phép cụ thể. Việc không tuân thủ các điều khoản của giấy phép (ví dụ: về việc ghi công, về việc phân phối lại mã nguồn) có thể dẫn đến vi phạm bản quyền và các rắc rối pháp lý."
  },
  {
    "question": "35. Thiết kế giao diện người dùng (UI) cần xem xét yếu tố nào?",
    "a": "Chỉ yếu tố thẩm mỹ (màu sắc, bố cục).",
    "b": "Chỉ tốc độ xử lý của hệ thống.",
    "c": "Nhu cầu, kinh nghiệm, khả năng và hạn chế của người dùng cuối.",
    "d": "Chỉ loại cơ sở dữ liệu được sử dụng.",
    "answer": "C",
    "theory": "Thiết kế UI hiệu quả phải đặt người dùng làm trung tâm, xem xét các yếu tố như mục tiêu của họ, kiến thức và kinh nghiệm, khả năng (ví dụ: người dùng có khuyết tật), và các hạn chế của ngữ cảnh sử dụng để tạo ra một giao diện dễ sử dụng, hiệu quả và mang lại trải nghiệm tốt."
  },
  {
    "question": "36. Nguyên tắc \"Thân thiện với người dùng\" trong thiết kế UI nghĩa là gì?",
    "a": "Sử dụng nhiều thuật ngữ kỹ thuật máy tính nhất có thể.",
    "b": "Giao diện nên sử dụng thuật ngữ và khái niệm quen thuộc với người dùng trong lĩnh vực của họ.",
    "c": "Giao diện phải có màu sắc sặc sỡ.",
    "d": "Giao diện phải thay đổi liên tục.",
    "answer": "B",
    "theory": "Thiết kế thân thiện với người dùng (user-friendly) có nghĩa là giao diện phải dễ hiểu, dễ học và dễ sử dụng. Điều này bao gồm việc sử dụng ngôn ngữ, thuật ngữ và các khái niệm mà người dùng mục tiêu đã quen thuộc, tránh các thuật ngữ kỹ thuật khó hiểu."
  },
  {
    "question": "37. Nguyên tắc \"Nhất quán\" (Consistency) trong thiết kế UI đòi hỏi điều gì?",
    "a": "Mỗi màn hình phải có một thiết kế hoàn toàn khác biệt.",
    "b": "Các lệnh, menu, biểu tượng, cách trình bày thông tin nên có sự đồng nhất trên toàn bộ ứng dụng.",
    "c": "Luôn sử dụng font chữ lớn nhất có thể.",
    "d": "Màu nền phải thay đổi theo thời gian trong ngày.",
    "answer": "B",
    "theory": "Tính nhất quán trong thiết kế UI có nghĩa là các yếu tố giao diện (như vị trí menu, biểu tượng, cách đặt tên lệnh, cách trình bày thông tin) và hành vi của chúng nên giống nhau hoặc tương tự nhau trên toàn bộ ứng dụng. Điều này giúp người dùng học nhanh hơn và giảm lỗi."
  },
  {
    "question": "38. Nguyên tắc \"Ít bất ngờ\" (Principle of Least Astonishment) trong thiết kế UI có nghĩa là gì?",
    "a": "Hệ thống nên có nhiều tính năng ẩn thú vị.",
    "b": "Hành vi của hệ thống đối với các thao tác tương tự nên có thể dự đoán được bởi người dùng.",
    "c": "Giao diện nên thay đổi bố cục một cách ngẫu nhiên.",
    "d": "Luôn yêu cầu người dùng xác nhận mọi hành động.",
    "answer": "B",
    "theory": "Nguyên tắc \"Ít bất ngờ\" (hay Principle of Least Surprise) nói rằng hành vi của hệ thống nên phù hợp với mong đợi của người dùng. Khi người dùng thực hiện một hành động, kết quả nên là điều họ dự đoán được, tránh gây bất ngờ hoặc nhầm lẫn."
  },
  {
    "question": "39. Nguyên tắc \"Khôi phục được\" (Recoverability) trong thiết kế UI đề cập đến khả năng nào?",
    "a": "Khả năng hệ thống tự sửa lỗi mã nguồn.",
    "b": "Khả năng người dùng dễ dàng hoàn tác (undo) các thao tác lỗi hoặc quay lại trạng thái trước đó.",
    "c": "Khả năng khôi phục mật khẩu đã quên.",
    "d": "Khả năng hệ thống chạy trên nhiều hệ điều hành.",
    "answer": "B",
    "theory": "Khả năng khôi phục (Recoverability) cho phép người dùng dễ dàng sửa lỗi khi họ mắc phải, ví dụ bằng cách cung cấp chức năng hoàn tác (undo), hủy bỏ (cancel), hoặc quay lại bước trước đó. Điều này giúp người dùng tự tin hơn khi tương tác với hệ thống."
  },
  {
    "question": "40. Tại sao cần xem xét \"Đa dạng người dùng\" (User Diversity) khi thiết kế UI?",
    "a": "Để làm giao diện phức tạp hơn.",
    "b": "Vì những người dùng khác nhau (ví dụ: người mới bắt đầu, chuyên gia, người có khuyết tật) có thể có nhu cầu và cách tương tác khác nhau.",
    "c": "Chỉ để tăng số lượng màn hình thiết kế.",
    "d": "Để giới hạn số lượng người có thể sử dụng hệ thống.",
    "answer": "B",
    "theory": "Người dùng có sự đa dạng về kiến thức, kinh nghiệm, kỹ năng, khả năng thể chất và nhận thức, cũng như các mục tiêu và ngữ cảnh sử dụng khác nhau. Thiết kế UI cần xem xét sự đa dạng này để đảm bảo tính dễ sử dụng và khả năng tiếp cận (accessibility) cho nhiều đối tượng người dùng nhất có thể."
  },
  {
    "question": "41. Việc mô tả thuật toán bằng lưu đồ hoặc mã giả thuộc giai đoạn nào?",
    "a": "Phân tích yêu cầu.",
    "b": "Thiết kế thuật toán (một phần của thiết kế chi tiết).",
    "c": "Kiểm thử hệ thống.",
    "d": "Bảo trì phần mềm.",
    "answer": "B",
    "theory": "Mô tả thuật toán bằng lưu đồ (flowchart) hoặc mã giả (pseudocode) là một phần của giai đoạn thiết kế chi tiết, cụ thể là thiết kế logic xử lý cho các phương thức hoặc module."
  },
  {
    "question": "42. Thiết kế cơ sở dữ liệu liên quan chặt chẽ đến giai đoạn nào trong OOD?",
    "a": "Xác định ngữ cảnh.",
    "b": "Thiết kế kiến trúc.",
    "c": "Nhận diện lớp/đối tượng và phát triển mô hình tĩnh (Biểu đồ lớp).",
    "d": "Đặc tả giao diện đối tượng.",
    "answer": "C",
    "theory": "Mô hình tĩnh (đặc biệt là Biểu đồ Lớp) trong OOD, nơi các lớp, thuộc tính và mối quan hệ giữa chúng được xác định, là đầu vào quan trọng cho việc thiết kế cơ sở dữ liệu. Các lớp thường được ánh xạ thành các bảng, thuộc tính thành các cột."
  },
  {
    "question": "43. Đâu là một kỹ thuật phổ biến để nhận diện lớp đối tượng từ mô tả yêu cầu bằng văn bản?",
    "a": "Phân tích DFD (Data Flow Diagram).",
    "b": "Phân tích ngữ pháp (Grammatical analysis), tìm danh từ (ứng viên cho lớp/thuộc tính) và động từ (ứng viên cho phương thức).",
    "c": "Phân tích lưu đồ (Flowchart analysis).",
    "d": "Phân tích mã nguồn (Source code analysis).",
    "answer": "B",
    "theory": "Phân tích ngữ pháp là một kỹ thuật đơn giản để bắt đầu nhận diện các ứng viên cho lớp và thuộc tính (thường là các danh từ hoặc cụm danh từ) và các ứng viên cho phương thức (thường là các động từ hoặc cụm động từ) từ mô tả yêu cầu bằng ngôn ngữ tự nhiên."
  },
  {
    "question": "44. Mô hình hóa ngữ cảnh giúp xác định yếu tố nào quan trọng cho thiết kế?",
    "a": "Chi tiết triển khai của các lớp.",
    "b": "Các giao diện (interfaces) mà hệ thống cần cung cấp hoặc sử dụng để tương tác với môi trường bên ngoài.",
    "c": "Các thuật toán sắp xếp dữ liệu.",
    "d": "Lựa chọn font chữ cho giao diện.",
    "answer": "B",
    "theory": "Mô hình ngữ cảnh xác định các actor và hệ thống bên ngoài mà hệ thống của chúng ta cần tương tác. Từ đó, có thể xác định các giao diện (interfaces) cần thiết để cho phép các tương tác này diễn ra, điều này rất quan trọng cho thiết kế."
  },
  {
    "question": "45. Tại sao cần phải đặc tả giao diện (Interface Specification) một cách rõ ràng?",
    "a": "Để định nghĩa \"hợp đồng\" giữa các component, cho phép chúng tương tác mà không cần biết chi tiết hiện thực bên trong của nhau.",
    "b": "Chỉ để làm tài liệu dài hơn.",
    "c": "Để mô tả trạng thái của đối tượng.",
    "d": "Để liệt kê các giấy phép mã nguồn mở.",
    "answer": "A",
    "theory": "Đặc tả giao diện rõ ràng định nghĩa các phương thức, tham số, kiểu trả về và hành vi mong đợi mà một component cung cấp hoặc yêu cầu. Điều này tạo ra một \"hợp đồng\" cho phép các component được phát triển và thay đổi độc lập, miễn là tuân thủ giao diện."
  },
  {
    "question": "46. Mối quan hệ giữa một lớp (Class) và giao diện (Interface) mà nó hiện thực hóa (implements) là loại quan hệ nào trong UML?",
    "a": "Association.",
    "b": "Generalization.",
    "c": "Realization (Hiện thực hóa).",
    "d": "Dependency.",
    "answer": "C",
    "theory": "Mối quan hệ Realization (Hiện thực hóa) trong UML được sử dụng để biểu diễn việc một lớp (classifier) hiện thực hóa (implements) các hành vi được đặc tả bởi một giao diện (interface)."
  },
  {
    "question": "47. Sử dụng mẫu thiết kế mang lại lợi ích gì ngoài việc tái sử dụng giải pháp?",
    "a": "Cung cấp một bộ từ vựng chung để các nhà phát triển giao tiếp về các giải pháp thiết kế.",
    "b": "Luôn đảm bảo hiệu năng tốt nhất.",
    "c": "Giảm số lượng dòng code phải viết.",
    "d": "Làm cho việc kiểm thử trở nên không cần thiết.",
    "answer": "A",
    "theory": "Mẫu thiết kế cung cấp một bộ thuật ngữ và khái niệm chung đã được công nhận. Khi các nhà phát triển nói về việc sử dụng \"mẫu Observer\" hay \"mẫu Factory\", họ có thể nhanh chóng hiểu ý nhau về cấu trúc và mục đích của giải pháp đó, giúp cải thiện giao tiếp."
  },
  {
    "question": "48. Khi nào thì việc áp dụng Thiết kế hướng đối tượng (OOD) có thể không hiệu quả?",
    "a": "Đối với các hệ thống lớn, phức tạp.",
    "b": "Đối với các hệ thống đòi hỏi bảo trì và mở rộng cao.",
    "c": "Đối với các hệ thống rất nhỏ, đơn giản, nơi chi phí tạo và bảo trì mô hình vượt quá lợi ích.",
    "d": "Đối với các hệ thống cần tái sử dụng code.",
    "answer": "C",
    "theory": "Đối với các ứng dụng rất nhỏ, đơn giản, hoặc các script ngắn, việc áp dụng đầy đủ quy trình OOD với nhiều mô hình có thể là quá mức cần thiết (overkill) và tốn kém hơn so với lợi ích mang lại. Tuy nhiên, các nguyên tắc OOD cơ bản vẫn có thể hữu ích."
  },
  {
    "question": "49. Biểu đồ nào trong UML phù hợp nhất để thể hiện cấu trúc vật lý của hệ thống, bao gồm các nút (nodes) và cách các thành phần (artifacts) được triển khai lên đó?",
    "a": "Biểu đồ Lớp (Class Diagram).",
    "b": "Biểu đồ Component (Component Diagram).",
    "c": "Biểu đồ Triển khai (Deployment Diagram).",
    "d": "Biểu đồ Hoạt động (Activity Diagram).",
    "answer": "C",
    "theory": "Biểu đồ Triển khai (Deployment Diagram) được sử dụng để mô hình hóa cấu trúc vật lý của hệ thống, cho thấy các nút (nodes) phần cứng (ví dụ: server, thiết bị) và cách các thành phần phần mềm thực thi (artifacts) được phân bố và triển khai trên các nút đó."
  },
  {
    "question": "50. Mối quan hệ giữa các tầng trong kiến trúc phân tầng thường là gì?",
    "a": "Tầng cao hơn sử dụng dịch vụ của tầng ngay dưới nó.",
    "b": "Các tầng có thể gọi trực tiếp bất kỳ tầng nào khác.",
    "c": "Chỉ tầng trên cùng và dưới cùng tương tác với nhau.",
    "d": "Các tầng hoàn toàn độc lập, không giao tiếp.",
    "answer": "A",
    "theory": "Trong kiến trúc phân tầng điển hình, các yêu cầu thường đi từ tầng cao hơn xuống tầng thấp hơn. Mỗi tầng cung cấp dịch vụ cho tầng ngay bên trên nó và sử dụng dịch vụ của tầng ngay bên dưới nó. Giao tiếp trực tiếp giữa các tầng không kề nhau thường bị hạn chế để duy trì sự tách biệt."
  },
  {
    "question": "51. Việc phân tích kịch bản (Scenario analysis) hữu ích như thế nào trong việc nhận diện lớp/đối tượng?",
    "a": "Giúp xác định các đối tượng, thuộc tính và hành động liên quan đến một luồng sử dụng cụ thể của hệ thống.",
    "b": "Chỉ giúp xác định các actor.",
    "c": "Chỉ hữu ích cho việc vẽ biểu đồ trạng thái.",
    "d": "Giúp xác định giấy phép mã nguồn mở.",
    "answer": "A",
    "theory": "Phân tích kịch bản (scenario analysis) bằng cách đi qua các luồng sử dụng cụ thể của hệ thống (ví dụ, các bước trong một use case) giúp nhận diện các đối tượng tham gia, dữ liệu (thuộc tính) chúng cần, và các hành động (phương thức) chúng thực hiện."
  },
  {
    "question": "52. \"Cohesion\" (Độ gắn kết) trong thiết kế module/lớp nghĩa là gì?",
    "a": "Mức độ phụ thuộc giữa các module/lớp khác nhau.",
    "b": "Mức độ mà các thành phần bên trong một module/lớp liên quan chặt chẽ đến nhau và cùng thực hiện một nhiệm vụ cụ thể.",
    "c": "Số lượng dòng code trong một module/lớp.",
    "d": "Tốc độ thực thi của module/lớp.",
    "answer": "B",
    "theory": "Cohesion (Độ gắn kết) đo lường mức độ mà các trách nhiệm và chức năng của một module hoặc lớp là liên quan và tập trung. Một module/lớp có độ gắn kết cao khi tất cả các phần tử bên trong nó làm việc cùng nhau để thực hiện một mục đích duy nhất, rõ ràng."
  },
  {
    "question": "53. \"Coupling\" (Độ khớp nối/liên kết) trong thiết kế module/lớp nghĩa là gì?",
    "a": "Mức độ liên quan của các thành phần bên trong một module.",
    "b": "Mức độ phụ thuộc lẫn nhau giữa các module/lớp khác nhau.",
    "c": "Kích thước của giao diện module/lớp.",
    "d": "Số lượng lỗi trong module/lớp.",
    "answer": "B",
    "theory": "Coupling (Độ khớp nối) đo lường mức độ phụ thuộc giữa các module hoặc lớp. Khớp nối thấp (low coupling) là mong muốn, nghĩa là các module/lớp ít phụ thuộc vào nhau, giúp chúng dễ thay đổi và bảo trì độc lập."
  },
  {
    "question": "54. Một thiết kế tốt thường hướng tới mục tiêu nào về Cohesion và Coupling?",
    "a": "Cohesion thấp, Coupling cao.",
    "b": "Cohesion cao, Coupling cao.",
    "c": "Cohesion thấp, Coupling thấp.",
    "d": "Cohesion cao, Coupling thấp.",
    "answer": "D",
    "theory": "Một thiết kế module/lớp tốt thường hướng tới mục tiêu đạt được Cohesion cao (các thành phần bên trong module/lớp liên quan chặt chẽ với nhau) và Coupling thấp (sự phụ thuộc giữa các module/lớp là tối thiểu)."
  },
  {
    "question": "55. Tại sao cần phải hiểu rõ yêu cầu (cả chức năng và phi chức năng) trước khi bắt đầu thiết kế kiến trúc?",
    "a": "Để lựa chọn được tên lớp phù hợp.",
    "b": "Vì kiến trúc phải được thiết kế để đáp ứng các yêu cầu đó, đặc biệt là các yêu cầu phi chức năng thường ảnh hưởng lớn đến cấu trúc tổng thể.",
    "c": "Chỉ để ước tính thời gian dự án.",
    "d": "Không cần thiết, có thể thiết kế kiến trúc trước rồi điều chỉnh yêu cầu sau.",
    "answer": "B",
    "theory": "Yêu cầu, đặc biệt là các yêu cầu phi chức năng (như hiệu năng, bảo mật, khả năng mở rộng), đóng vai trò quyết định trong việc lựa chọn và định hình kiến trúc. Kiến trúc phải được thiết kế sao cho có thể đáp ứng được các yêu cầu này."
  },
  {
    "question": "56. Việc sử dụng các framework (ví dụ: Spring, .NET) ảnh hưởng như thế nào đến thiết kế phần mềm?",
    "a": "Không ảnh hưởng gì.",
    "b": "Cung cấp sẵn các cấu trúc, component và mẫu, giúp đẩy nhanh quá trình phát triển nhưng cũng có thể áp đặt các ràng buộc thiết kế.",
    "c": "Chỉ giúp cho việc viết code nhanh hơn.",
    "d": "Chỉ làm tăng độ phức tạp.",
    "answer": "B",
    "theory": "Framework cung cấp một nền tảng và các thành phần được xây dựng sẵn, giúp tăng tốc độ phát triển và chuẩn hóa cấu trúc. Tuy nhiên, việc sử dụng framework cũng có nghĩa là phải tuân theo các quy ước và ràng buộc thiết kế của framework đó (inversion of control)."
  },
  {
    "question": "57. Trong thiết kế OOD, khái niệm \"Encapsulation\" (Đóng gói) có ý nghĩa gì?",
    "a": "Che giấu chi tiết hiện thực bên trong của một đối tượng và chỉ cung cấp giao diện công khai để tương tác.",
    "b": "Cho phép một lớp kế thừa thuộc tính và phương thức từ lớp khác.",
    "c": "Khả năng một đối tượng thuộc lớp con được đối xử như đối tượng thuộc lớp cha.",
    "d": "Định nghĩa nhiều phương thức cùng tên nhưng khác tham số.",
    "answer": "A",
    "theory": "Encapsulation (Đóng gói) là một nguyên tắc cơ bản của OOD, nghĩa là che giấu trạng thái bên trong (dữ liệu) và chi tiết hiện thực của một đối tượng, chỉ cho phép truy cập và thay đổi trạng thái đó thông qua một tập hợp các phương thức công khai (public interface)."
  },
  {
    "question": "58. Khái niệm \"Polymorphism\" (Đa hình) trong OOD cho phép điều gì?",
    "a": "Một đối tượng có nhiều trạng thái khác nhau.",
    "b": "Nhiều lớp có cùng tên.",
    "c": "Các đối tượng thuộc các lớp khác nhau có thể phản ứng với cùng một thông điệp (lời gọi phương thức) theo cách riêng của chúng.",
    "d": "Một lớp kế thừa từ nhiều lớp cha.",
    "answer": "C",
    "theory": "Polymorphism (Đa hình) cho phép các đối tượng của các lớp khác nhau (thường có chung một lớp cha hoặc hiện thực cùng một interface) có thể được xử lý thông qua một giao diện chung, nhưng mỗi đối tượng sẽ thực hiện hành vi (phương thức) theo cách riêng của lớp mình."
  },
  {
    "question": "59. Thiết kế hướng đối tượng (OOD) thường mang lại lợi ích gì so với thiết kế hướng thủ tục truyền thống?",
    "a": "Luôn luôn chạy nhanh hơn.",
    "b": "Code luôn ngắn gọn hơn.",
    "c": "Tăng khả năng tái sử dụng, bảo trì và mô hình hóa thế giới thực tốt hơn.",
    "d": "Dễ học và áp dụng hơn cho người mới bắt đầu.",
    "answer": "C",
    "theory": "OOD giúp tạo ra các module (lớp) có tính đóng gói cao, dễ tái sử dụng và bảo trì. Nó cũng cung cấp các khái niệm (như lớp, đối tượng, kế thừa, đa hình) giúp mô hình hóa các thực thể và mối quan hệ trong thế giới thực một cách tự nhiên hơn so với lập trình hướng thủ tục."
  },
  {
    "question": "60. Đâu là thách thức khi áp dụng các mẫu thiết kế?",
    "a": "Các mẫu thiết kế luôn làm code đơn giản hơn.",
    "b": "Việc lựa chọn sai mẫu hoặc áp dụng không đúng cách có thể dẫn đến sự phức tạp không cần thiết (over-engineering).",
    "c": "Các mẫu thiết kế chỉ áp dụng được cho một ngôn ngữ lập trình duy nhất.",
    "d": "Không có tài liệu nào về các mẫu thiết kế.",
    "answer": "B",
    "theory": "Mặc dù mẫu thiết kế cung cấp giải pháp tốt, việc áp dụng chúng một cách mù quáng hoặc chọn sai mẫu cho vấn đề có thể làm tăng độ phức tạp không cần thiết. Cần hiểu rõ vấn đề và ngữ cảnh trước khi quyết định áp dụng một mẫu cụ thể."
  },
  {
    "question": "61. Tại sao việc xem xét các \"trade-offs\" (đánh đổi) lại quan trọng khi lựa chọn và áp dụng mẫu thiết kế?",
    "a": "Vì mỗi mẫu thiết kế đều hoàn hảo.",
    "b": "Vì mỗi mẫu thiết kế đều có ưu và nhược điểm, việc áp dụng nó có thể cải thiện một khía cạnh nhưng lại ảnh hưởng đến khía cạnh khác.",
    "c": "Chỉ để làm phức tạp quá trình ra quyết định.",
    "d": "Không quan trọng, chỉ cần chọn mẫu phổ biến nhất.",
    "answer": "B",
    "theory": "Không có mẫu thiết kế nào là hoàn hảo cho mọi tình huống. Mỗi mẫu đều có những ưu điểm (ví dụ: tăng tính linh hoạt) và nhược điểm (ví dụ: tăng độ phức tạp, giảm hiệu năng). Việc hiểu và cân nhắc các đánh đổi này là rất quan trọng để đưa ra quyết định thiết kế phù hợp."
  },
  {
    "question": "62. Phát triển phần mềm dựa trên component (Component-Based Software Engineering - CBSE) liên quan đến thiết kế như thế nào?",
    "a": "Hoàn toàn không liên quan.",
    "b": "Thiết kế tập trung vào việc xác định, lựa chọn và tích hợp các component có sẵn (thường là black-box) để xây dựng hệ thống.",
    "c": "Chỉ là một cách gọi khác của OOD.",
    "d": "Chỉ áp dụng cho phần cứng.",
    "answer": "B",
    "theory": "CBSE là một cách tiếp cận phát triển phần mềm bằng cách lắp ráp từ các component đã được xây dựng sẵn và có thể tái sử dụng. Thiết kế trong CBSE tập trung vào việc xác định các component cần thiết, giao diện của chúng, và cách chúng được tích hợp để tạo thành hệ thống."
  },
  {
    "question": "63. Đặc tả giao diện (Interface Specification) đặc biệt quan trọng trong cách tiếp cận phát triển nào?",
    "a": "Chỉ trong phát triển mã nguồn mở.",
    "b": "Chỉ trong phát triển theo mô hình thác nước.",
    "c": "Trong OOD và đặc biệt là CBSE, nơi các component cần tương tác qua các giao diện được định nghĩa rõ ràng.",
    "d": "Chỉ khi sử dụng mẫu Observer.",
    "answer": "C",
    "theory": "Trong cả OOD và CBSE, giao diện đóng vai trò là \"hợp đồng\" giữa các thành phần. Việc đặc tả giao diện rõ ràng cho phép các component được phát triển độc lập và tương tác với nhau một cách đáng tin cậy, ngay cả khi hiện thực bên trong của chúng thay đổi."
  },
  {
    "question": "64. Việc lựa chọn giữa phát triển mã nguồn mở và phát triển độc quyền (proprietary) cho một dự án phụ thuộc vào yếu tố nào?",
    "a": "Chỉ phụ thuộc vào sở thích của lập trình viên.",
    "b": "Mô hình kinh doanh, chiến lược sản phẩm, yêu cầu về kiểm soát mã nguồn, yếu tố cộng đồng, và các vấn đề pháp lý/bản quyền.",
    "c": "Chỉ phụ thuộc vào chi phí ban đầu.",
    "d": "Chỉ phụ thuộc vào ngôn ngữ lập trình.",
    "answer": "B",
    "theory": "Quyết định sử dụng/phát triển mã nguồn mở hay độc quyền là một quyết định chiến lược, phụ thuộc vào nhiều yếu tố như mô hình kinh doanh của công ty, mức độ kiểm soát mong muốn đối với sản phẩm, sự sẵn có của cộng đồng hỗ trợ, chi phí, và các ràng buộc pháp lý của giấy phép."
  },
  {
    "question": "65. Giấy phép GPL và BSD khác nhau cơ bản ở điểm nào liên quan đến việc phân phối lại mã nguồn sửa đổi?",
    "a": "GPL không cho phép sửa đổi, BSD cho phép.",
    "b": "GPL yêu cầu mã nguồn sửa đổi cũng phải mở (viral/copyleft), BSD thường không yêu cầu (permissive).",
    "c": "BSD chỉ dùng cho hệ điều hành, GPL dùng cho ứng dụng.",
    "d": "GPL miễn phí, BSD phải trả phí.",
    "answer": "B",
    "theory": "GPL là một giấy phép copyleft mạnh, yêu cầu các sản phẩm phái sinh cũng phải được cấp phép dưới GPL. Ngược lại, các giấy phép kiểu BSD (và MIT) là permissive, thường cho phép sử dụng, sửa đổi và phân phối lại mã nguồn (kể cả trong các sản phẩm độc quyền) với ít ràng buộc hơn về việc mở mã nguồn của sản phẩm phái sinh."
  },
  {
    "question": "66. Trong thiết kế UI, việc cung cấp phản hồi (feedback) cho người dùng sau mỗi hành động quan trọng vì sao?",
    "a": "Để làm chậm hệ thống.",
    "b": "Để người dùng biết rằng hệ thống đã nhận và đang xử lý yêu cầu của họ, hoặc kết quả của hành động là gì.",
    "c": "Chỉ cần thiết cho các thao tác phức tạp.",
    "d": "Chỉ để hiển thị thông báo lỗi.",
    "answer": "B",
    "theory": "Phản hồi ngay lập tức và rõ ràng giúp người dùng hiểu được trạng thái hiện tại của hệ thống, xác nhận rằng hành động của họ đã được ghi nhận, và biết được kết quả của hành động đó. Điều này làm tăng cảm giác kiểm soát và giảm sự không chắc chắn."
  },
  {
    "question": "67. Thiết kế thuật toán tập trung vào khía cạnh nào của phần mềm?",
    "a": "Cách dữ liệu được lưu trữ.",
    "b": "Cách người dùng tương tác với hệ thống.",
    "c": "Logic xử lý cụ thể để giải quyết một vấn đề tính toán (hiệu quả, độ phức tạp).",
    "d": "Cách các thành phần giao tiếp với nhau.",
    "answer": "C",
    "theory": "Thiết kế thuật toán tập trung vào việc phát triển các bước logic cụ thể để giải quyết một vấn đề tính toán. Các yếu tố quan trọng trong thiết kế thuật toán bao gồm tính đúng đắn, hiệu quả (thời gian chạy, sử dụng bộ nhớ), và độ phức tạp."
  },
  {
    "question": "68. Mối liên hệ giữa thiết kế kiến trúc và thiết kế thuật toán là gì?",
    "a": "Hoàn toàn độc lập.",
    "b": "Thiết kế kiến trúc xác định các thành phần, và thiết kế thuật toán chi tiết hóa logic xử lý bên trong các thành phần đó.",
    "c": "Thiết kế thuật toán quyết định kiến trúc tổng thể.",
    "d": "Chỉ kiến trúc mới quan trọng.",
    "answer": "B",
    "theory": "Thiết kế kiến trúc xác định các thành phần chính của hệ thống và cách chúng tương tác. Thiết kế thuật toán sau đó sẽ chi tiết hóa logic xử lý bên trong các phương thức hoặc chức năng của các thành phần đó để thực hiện các nhiệm vụ cụ thể."
  },
  {
    "question": "69. Thiết kế cơ sở dữ liệu (Database Design) bao gồm các hoạt động nào?",
    "a": "Chỉ chọn màu sắc cho bảng.",
    "b": "Xác định cấu trúc lưu trữ dữ liệu (bảng, cột, kiểu dữ liệu), mối quan hệ giữa các bảng, và các ràng buộc toàn vẹn.",
    "c": "Thiết kế giao diện người dùng để nhập liệu.",
    "d": "Viết các câu lệnh SQL phức tạp.",
    "answer": "B",
    "theory": "Thiết kế cơ sở dữ liệu bao gồm việc xác định các thực thể dữ liệu, thuộc tính của chúng, cách chúng được tổ chức thành các bảng, các mối quan hệ giữa các bảng (ví dụ: khóa ngoại), và các ràng buộc để đảm bảo tính toàn vẹn và nhất quán của dữ liệu."
  },
  {
    "question": "70. Tại sao thiết kế cơ sở dữ liệu lại quan trọng đối với hiệu năng hệ thống?",
    "a": "Không ảnh hưởng đến hiệu năng.",
    "b": "Một thiết kế CSDL tốt giúp tối ưu hóa việc truy vấn và cập nhật dữ liệu, giảm thời gian xử lý.",
    "c": "Chỉ quan trọng đối với việc lưu trữ ảnh.",
    "d": "Chỉ ảnh hưởng đến dung lượng lưu trữ.",
    "answer": "B",
    "theory": "Thiết kế cơ sở dữ liệu (ví dụ: việc chọn kiểu dữ liệu phù hợp, chuẩn hóa bảng, tạo chỉ mục (index) hợp lý) có ảnh hưởng lớn đến hiệu năng của các thao tác truy vấn và cập nhật dữ liệu, từ đó ảnh hưởng đến hiệu năng tổng thể của hệ thống."
  },
  {
    "question": "71. Đâu là sự khác biệt chính giữa mô hình tĩnh và mô hình động trong thiết kế OOD?",
    "a": "Mô hình tĩnh thể hiện cấu trúc, mô hình động thể hiện hành vi theo thời gian.",
    "b": "Mô hình tĩnh dùng UML, mô hình động không dùng UML.",
    "c": "Mô hình tĩnh dễ vẽ hơn, mô hình động khó vẽ hơn.",
    "d": "Mô hình tĩnh dùng cho lớp, mô hình động dùng cho đối tượng.",
    "answer": "A",
    "theory": "Mô hình tĩnh (ví dụ: Biểu đồ Lớp) mô tả các yếu tố cấu trúc của hệ thống không thay đổi theo thời gian. Mô hình động (ví dụ: Biểu đồ Tuần tự, Biểu đồ Trạng thái) mô tả hành vi của hệ thống khi nó thực thi, bao gồm các tương tác và sự thay đổi trạng thái theo thời gian."
  },
  {
    "question": "72. Phân tích kịch bản (Scenario-based analysis) là một kỹ thuật hữu ích để:",
    "a": "Nhận diện lớp và đối tượng.",
    "b": "Hiểu cách người dùng tương tác với hệ thống trong các tình huống cụ thể.",
    "c": "Xác định các yêu cầu động và luồng sự kiện.",
    "d": "Tất cả các ý trên.",
    "answer": "D",
    "theory": "Phân tích kịch bản (thường dựa trên use cases) giúp hiểu rõ các luồng tương tác của người dùng, từ đó nhận diện các đối tượng tham gia, các hành động chúng thực hiện, và các sự kiện xảy ra. Điều này hữu ích cho cả việc xác định lớp, mô tả hành vi động và làm rõ yêu cầu."
  },
  {
    "question": "73. Một \"Subsystem\" trong thiết kế kiến trúc thường đại diện cho:",
    "a": "Một lớp đối tượng đơn lẻ.",
    "b": "Một nhóm các thành phần liên quan chặt chẽ, thực hiện một tập hợp các chức năng lớn hơn.",
    "c": "Toàn bộ hệ thống phần mềm.",
    "d": "Một file mã nguồn.",
    "answer": "B",
    "theory": "Một subsystem là một phần lớn của hệ thống, thường bao gồm nhiều component hoặc module liên quan, và có trách nhiệm thực hiện một tập hợp các chức năng có ý nghĩa. Subsystem có thể được coi là một component ở mức độ trừu tượng cao hơn."
  },
  {
    "question": "74. Tại sao việc quản lý sự thay đổi (Change Management) lại quan trọng trong suốt vòng đời thiết kế?",
    "a": "Yêu cầu và môi trường luôn thay đổi, cần có quy trình để đánh giá và tích hợp các thay đổi vào thiết kế một cách có kiểm soát.",
    "b": "Để ngăn chặn mọi thay đổi đối với thiết kế ban đầu.",
    "c": "Chỉ quan trọng trong giai đoạn hiện thực.",
    "d": "Chỉ để theo dõi ai yêu cầu thay đổi.",
    "answer": "A",
    "theory": "Trong suốt vòng đời phát triển, yêu cầu của khách hàng, công nghệ, hoặc môi trường kinh doanh có thể thay đổi. Quản lý sự thay đổi là quy trình cần thiết để đánh giá tác động của các thay đổi này, quyết định có chấp nhận chúng hay không, và tích hợp chúng vào thiết kế một cách có kiểm soát để tránh làm hỏng hệ thống."
  },
  {
    "question": "75. \"Refactoring\" (Tái cấu trúc mã) liên quan đến thiết kế như thế nào?",
    "a": "Là việc viết lại hoàn toàn thiết kế.",
    "b": "Là quá trình cải thiện cấu trúc mã nguồn hiện có mà không thay đổi hành vi bên ngoài, thường nhằm cải thiện thiết kế (dễ hiểu, dễ bảo trì).",
    "c": "Là việc thêm chức năng mới vào thiết kế.",
    "d": "Là việc sửa lỗi trong thiết kế.",
    "answer": "B",
    "theory": "Refactoring là việc cải thiện cấu trúc bên trong của mã nguồn (và do đó là thiết kế chi tiết) mà không làm thay đổi hành vi quan sát được từ bên ngoài. Mục đích là làm cho code dễ hiểu hơn, dễ bảo trì hơn, và tuân thủ các nguyên tắc thiết kế tốt hơn."
  },
  {
    "question": "76. Khi nào nên sử dụng Biểu đồ trạng thái thay vì Biểu đồ hoạt động?",
    "a": "Khi muốn mô tả luồng công việc phức tạp với nhiều bước.",
    "b": "Khi muốn tập trung vào vòng đời và các trạng thái khác nhau của một đối tượng cụ thể khi nó phản ứng với sự kiện.",
    "c": "Khi muốn mô tả cấu trúc tĩnh của hệ thống.",
    "d": "Khi muốn mô tả sự tương tác giữa nhiều đối tượng.",
    "answer": "B",
    "theory": "Biểu đồ Trạng thái phù hợp nhất khi cần mô tả hành vi của một đối tượng đơn lẻ, cụ thể là các trạng thái mà nó có thể có và cách nó chuyển đổi giữa các trạng thái đó khi có sự kiện xảy ra. Biểu đồ Hoạt động tập trung hơn vào luồng các hoạt động trong một quy trình."
  },
  {
    "question": "77. Định nghĩa \"Interface\" (Giao diện) trong ngữ cảnh OOD thường bao gồm:",
    "a": "Chi tiết hiện thực của các phương thức.",
    "b": "Chỉ tên của lớp.",
    "c": "Tập hợp các chữ ký phương thức (tên, tham số, kiểu trả về) mà một lớp phải cung cấp.",
    "d": "Các thuộc tính private của lớp.",
    "answer": "C",
    "theory": "Trong OOD, một interface (giao diện) định nghĩa một tập hợp các chữ ký phương thức (operations) mà một lớp cam kết sẽ hiện thực hóa. Nó không chứa chi tiết hiện thực của các phương thức đó, chỉ là \"hợp đồng\" về những gì lớp có thể làm."
  },
  {
    "question": "78. Lợi ích của việc sử dụng các công cụ CASE (Computer-Aided Software Engineering) trong thiết kế là gì?",
    "a": "Hỗ trợ vẽ và quản lý các mô hình UML, kiểm tra tính nhất quán, đôi khi sinh mã tự động.",
    "b": "Thay thế hoàn toàn vai trò của nhà thiết kế.",
    "c": "Làm chậm quá trình thiết kế.",
    "d": "Chỉ dùng để lưu trữ tài liệu.",
    "answer": "A",
    "theory": "Công cụ CASE hỗ trợ các nhà thiết kế trong việc tạo, sửa đổi và quản lý các mô hình phần mềm (ví dụ: mô hình UML). Chúng có thể giúp kiểm tra tính nhất quán, tạo tài liệu, và đôi khi tự động sinh mã từ các mô hình, giúp tăng năng suất và chất lượng."
  },
  {
    "question": "79. Đâu là một nguyên tắc thiết kế quan trọng giúp giảm sự phụ thuộc và tăng khả năng thay đổi?",
    "a": "Viết tất cả code trong một file duy nhất.",
    "b": "Sử dụng nhiều biến toàn cục (global variables).",
    "c": "Thiết kế dựa trên giao diện thay vì hiện thực cụ thể (Design to interfaces, not implementations).",
    "d": "Tránh sử dụng thừa kế hoàn toàn.",
    "answer": "C",
    "theory": "Nguyên tắc \"Design to interfaces, not implementations\" khuyến khích việc các thành phần phụ thuộc vào các giao diện trừu tượng thay vì các lớp hiện thực cụ thể. Điều này làm giảm sự khớp nối và cho phép dễ dàng thay thế các hiện thực mà không ảnh hưởng đến các thành phần khác."
  },
  {
    "question": "80. Mẫu Singleton đảm bảo điều gì?",
    "a": "Một lớp có nhiều đối tượng con.",
    "b": "Một lớp chỉ có duy nhất một thể hiện (instance) và cung cấp một điểm truy cập toàn cục đến nó.",
    "c": "Mọi phương thức đều là static.",
    "d": "Lớp không thể bị kế thừa.",
    "answer": "B",
    "theory": "Mẫu Singleton đảm bảo rằng một lớp chỉ có một thể hiện duy nhất trong toàn bộ ứng dụng và cung cấp một cách để truy cập vào thể hiện đó từ bất kỳ đâu (thường thông qua một phương thức static)."
  },
  {
    "question": "81. Mẫu Factory Method hữu ích khi nào?",
    "a": "Khi muốn che giấu logic tạo đối tượng phức tạp và cho phép các lớp con quyết định lớp cụ thể nào sẽ được tạo.",
    "b": "Khi muốn đảm bảo chỉ có một thể hiện của lớp.",
    "c": "Khi muốn thêm chức năng vào đối tượng một cách động.",
    "d": "Khi muốn tách rời giao diện khỏi hiện thực.",
    "answer": "A",
    "theory": "Mẫu Factory Method định nghĩa một giao diện để tạo đối tượng, nhưng để các lớp con quyết định lớp cụ thể nào sẽ được khởi tạo. Nó cho phép một lớp trì hoãn việc khởi tạo đối tượng cho các lớp con, giúp che giấu logic tạo đối tượng phức tạp."
  },
  {
    "question": "82. Việc áp dụng các nguyên tắc SOLID (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) giúp ích gì cho thiết kế OOD?",
    "a": "Làm code khó hiểu hơn.",
    "b": "Tạo ra các thiết kế linh hoạt, dễ bảo trì, dễ mở rộng và dễ hiểu hơn.",
    "c": "Chỉ áp dụng cho ngôn ngữ Java.",
    "d": "Tăng sự phụ thuộc giữa các lớp.",
    "answer": "B",
    "theory": "Các nguyên tắc SOLID là một tập hợp các hướng dẫn thiết kế hướng đối tượng nhằm tạo ra các hệ thống dễ hiểu, linh hoạt, dễ bảo trì và dễ mở rộng. Chúng giúp giảm sự khớp nối, tăng tính gắn kết và cải thiện khả năng tái sử dụng."
  },
  {
    "question": "83. Trong thiết kế phần mềm, \"Abstraction\" (Trừu tượng hóa) nghĩa là gì?",
    "a": "Cung cấp tất cả chi tiết hiện thực.",
    "b": "Tập trung vào các đặc điểm thiết yếu của một đối tượng hoặc hệ thống, bỏ qua các chi tiết không cần thiết.",
    "c": "Sao chép code từ nơi khác.",
    "d": "Viết code bằng ngôn ngữ máy.",
    "answer": "B",
    "theory": "Trừu tượng hóa là quá trình loại bỏ các chi tiết không cần thiết để tập trung vào các khía cạnh quan trọng của một vấn đề hoặc một thực thể. Trong OOD, nó giúp tạo ra các mô hình đơn giản hơn và dễ quản lý hơn."
  },
  {
    "question": "84. Thiết kế giao diện người dùng (UI) và thiết kế trải nghiệm người dùng (UX) có giống nhau không?",
    "a": "Hoàn toàn giống nhau.",
    "b": "UI tập trung vào giao diện trực quan (cái nhìn và cảm nhận), UX bao gồm toàn bộ trải nghiệm của người dùng khi tương tác với sản phẩm (bao gồm cả UI, tính hữu dụng, cảm xúc).",
    "c": "UX là một phần của UI.",
    "d": "UI chỉ liên quan đến màu sắc, UX chỉ liên quan đến tốc độ.",
    "answer": "B",
    "theory": "UI (User Interface) là phần giao diện trực quan mà người dùng nhìn thấy và tương tác. UX (User Experience) là một khái niệm rộng hơn, bao gồm toàn bộ cảm nhận và trải nghiệm của người dùng khi sử dụng một sản phẩm hoặc dịch vụ, trong đó UI là một phần quan trọng."
  },
  {
    "question": "85. Tại sao việc xem xét \"non-functional requirements\" (yêu cầu phi chức năng) lại cực kỳ quan trọng trong giai đoạn thiết kế, đặc biệt là thiết kế kiến trúc?",
    "a": "Chúng thường dễ đáp ứng hơn yêu cầu chức năng.",
    "b": "Chúng thường định hình cấu trúc tổng thể của hệ thống (ví dụ: yêu cầu hiệu năng cao có thể dẫn đến kiến trúc phân tán, yêu cầu bảo mật cao dẫn đến kiến trúc phân tầng chặt chẽ).",
    "c": "Chúng không ảnh hưởng đến mã nguồn.",
    "d": "Chúng chỉ quan trọng đối với người dùng cuối.",
    "answer": "B",
    "theory": "Các yêu cầu phi chức năng (như hiệu năng, bảo mật, khả năng mở rộng, độ tin cậy) thường có tác động sâu rộng đến các quyết định kiến trúc. Việc không xem xét kỹ lưỡng chúng từ đầu có thể dẫn đến một hệ thống không đáp ứng được các thuộc tính chất lượng quan trọng."
  },
  {
    "question": "86. Đâu là một phương pháp để đánh giá tính dễ bảo trì của một thiết kế?",
    "a": "Đếm số dòng code.",
    "b": "Xem xét mức độ module hóa, độ khớp nối (coupling) và độ gắn kết (cohesion).",
    "c": "Kiểm tra tốc độ chạy của chương trình.",
    "d": "Khảo sát ý kiến người dùng về giao diện.",
    "answer": "B",
    "theory": "Tính dễ bảo trì của một thiết kế phụ thuộc nhiều vào cấu trúc của nó. Một thiết kế có tính module hóa cao, độ gắn kết cao bên trong các module, và độ khớp nối thấp giữa các module thường dễ hiểu, dễ sửa đổi và dễ bảo trì hơn."
  },
  {
    "question": "87. Mô hình hóa động (dynamic modeling) giúp trả lời câu hỏi nào mà mô hình hóa tĩnh (static modeling) không thể?",
    "a": "Hệ thống có bao nhiêu lớp?",
    "b": "Lớp A có mối quan hệ gì với lớp B?",
    "c": "Khi sự kiện X xảy ra, đối tượng Y sẽ gửi thông điệp gì cho đối tượng Z?",
    "d": "Lớp C có những thuộc tính nào?",
    "answer": "C",
    "theory": "Mô hình hóa tĩnh mô tả cấu trúc. Mô hình hóa động (ví dụ: Biểu đồ Tuần tự) mô tả hành vi theo thời gian, cho thấy trình tự các tương tác (thông điệp) giữa các đối tượng khi một sự kiện nào đó xảy ra."
  },
  {
    "question": "88. Việc sử dụng lại (reuse) trong thiết kế phần mềm có thể ở những cấp độ nào?",
    "a": "Chỉ ở cấp độ mã nguồn (copy-paste).",
    "b": "Cấp độ mã nguồn, cấp độ component, cấp độ thiết kế (mẫu thiết kế), cấp độ kiến trúc.",
    "c": "Chỉ ở cấp độ kiến trúc.",
    "d": "Chỉ ở cấp độ mẫu thiết kế.",
    "answer": "B",
    "theory": "Tái sử dụng trong phần mềm có thể diễn ra ở nhiều cấp độ: từ việc tái sử dụng các đoạn mã nhỏ, các component đã được xây dựng sẵn, các mẫu thiết kế đã được kiểm chứng, cho đến việc tái sử dụng toàn bộ kiến trúc cho các ứng dụng tương tự."
  },
  {
    "question": "89. Một thiết kế \"testable\" (có khả năng kiểm thử) thường có đặc điểm gì?",
    "a": "Có nhiều phụ thuộc phức tạp giữa các module.",
    "b": "Các module được thiết kế độc lập, có giao diện rõ ràng, dễ dàng cô lập để kiểm thử đơn vị (unit test).",
    "c": "Sử dụng nhiều biến toàn cục.",
    "d": "Mã nguồn được viết bằng ngôn ngữ assembly.",
    "answer": "B",
    "theory": "Một thiết kế có khả năng kiểm thử cao thường có các module/component được thiết kế độc lập, có giao diện được định nghĩa rõ ràng, và ít phụ thuộc vào trạng thái toàn cục. Điều này giúp dễ dàng cô lập các phần của hệ thống để thực hiện kiểm thử đơn vị và kiểm thử tích hợp."
  },
  {
    "question": "90. Tại sao cần phân biệt giữa \"logical design\" (thiết kế logic) và \"physical design\" (thiết kế vật lý) trong cơ sở dữ liệu?",
    "a": "Không cần phân biệt.",
    "b": "Thiết kế logic tập trung vào mô hình dữ liệu (thực thể, thuộc tính, quan hệ) độc lập với hệ quản trị CSDL cụ thể; thiết kế vật lý chi tiết hóa cách dữ liệu được lưu trữ và truy cập trên một hệ quản trị CSDL cụ thể.",
    "c": "Thiết kế logic là vẽ ERD, thiết kế vật lý là viết SQL.",
    "d": "Thiết kế logic do người dùng làm, thiết kế vật lý do lập trình viên làm.",
    "answer": "B",
    "theory": "Thiết kế logic CSDL tập trung vào việc mô hình hóa yêu cầu dữ liệu của người dùng một cách trừu tượng (ví dụ: bằng ERD), không phụ thuộc vào hệ quản trị CSDL (DBMS) nào sẽ được sử dụng. Thiết kế vật lý CSDL dịch mô hình logic đó thành một hiện thực cụ thể trên một DBMS đã chọn, bao gồm việc định nghĩa bảng, cột, kiểu dữ liệu, chỉ mục, v.v."
  },
  {
    "question": "91. Trong quy trình thiết kế OOD, việc quay lại các bước trước đó (ví dụ: từ phát triển mô hình thiết kế quay lại nhận diện lớp) có phổ biến không?",
    "a": "Không, quy trình luôn đi thẳng.",
    "b": "Có, đây là một quy trình lặp, việc phát hiện ra vấn đề ở bước sau có thể yêu cầu điều chỉnh lại các bước trước đó.",
    "c": "Chỉ xảy ra khi có lỗi nghiêm trọng.",
    "d": "Chỉ áp dụng cho mô hình Agile.",
    "answer": "B",
    "theory": "Thiết kế phần mềm, bao gồm OOD, là một quy trình lặp (iterative). Việc phát hiện ra các vấn đề, thiếu sót, hoặc có những hiểu biết mới ở các bước sau thường dẫn đến việc phải quay lại và điều chỉnh các quyết định hoặc mô hình đã được tạo ở các bước trước đó."
  },
  {
    "question": "92. Đâu là vai trò của \"kịch bản\" (scenarios) trong việc phát triển mô hình thiết kế động (ví dụ: Sequence Diagram)?",
    "a": "Mỗi kịch bản đại diện cho một luồng tương tác cụ thể cần được mô hình hóa chi tiết bằng Biểu đồ Tuần tự.",
    "b": "Kịch bản chỉ dùng để viết tài liệu hướng dẫn.",
    "c": "Kịch bản dùng để xác định cấu trúc lớp tĩnh.",
    "d": "Kịch bản không liên quan đến mô hình động.",
    "answer": "A",
    "theory": "Các kịch bản (scenarios), thường là các đường đi cụ thể qua một use case, cung cấp các tình huống tương tác cụ thể. Mỗi kịch bản này có thể được mô hình hóa chi tiết bằng một Biểu đồ Tuần tự (Sequence Diagram) để thể hiện trình tự các thông điệp giữa các đối tượng."
  },
  {
    "question": "93. Khi nào thì một lớp nên được thiết kế là \"abstract\" (trừu tượng)?",
    "a": "Khi lớp đó không có phương thức nào.",
    "b": "Khi lớp đó đại diện cho một khái niệm chung, không có ý nghĩa khi tạo đối tượng trực tiếp từ nó, và dự định được kế thừa bởi các lớp cụ thể hơn.",
    "c": "Khi lớp đó có quá nhiều thuộc tính.",
    "d": "Khi muốn ngăn chặn việc kế thừa.",
    "answer": "B",
    "theory": "Một lớp trừu tượng (abstract class) đại diện cho một khái niệm chung chung mà không có ý nghĩa hoặc không thể tạo đối tượng trực tiếp từ nó. Nó thường chứa các phương thức trừu tượng (chưa có hiện thực) mà các lớp con cụ thể sẽ phải hiện thực hóa. Lớp trừu tượng được thiết kế để được kế thừa."
  },
  {
    "question": "94. Sự khác biệt giữa Aggregation và Association là gì?",
    "a": "Aggregation là mối quan hệ mạnh hơn Association.",
    "b": "Aggregation (\"part-of\") là một dạng đặc biệt của Association, thể hiện mối quan hệ \"toàn thể-bộ phận\", trong khi Association thể hiện mối liên kết chung chung hơn.",
    "c": "Association chỉ có một chiều, Aggregation có hai chiều.",
    "d": "Chỉ Aggregation mới có số lượng (multiplicity).",
    "answer": "B",
    "theory": "Association là một mối liên kết ngữ nghĩa chung giữa hai hoặc nhiều lớp. Aggregation là một dạng đặc biệt của association, biểu thị mối quan hệ \"has-a\" hoặc \"part-of\", nơi một lớp (toàn thể) bao gồm các đối tượng của lớp khác (bộ phận), nhưng các bộ phận có thể tồn tại độc lập."
  },
  {
    "question": "95. Việc sử dụng thư viện mã nguồn mở (open source libraries) ảnh hưởng thế nào đến thiết kế?",
    "a": "Không ảnh hưởng.",
    "b": "Cần xem xét giấy phép, sự ổn định, cộng đồng hỗ trợ và cách tích hợp thư viện vào kiến trúc tổng thể.",
    "c": "Chỉ làm giảm thời gian viết code.",
    "d": "Luôn luôn làm tăng hiệu năng.",
    "answer": "B",
    "theory": "Khi quyết định sử dụng một thư viện mã nguồn mở, nhà thiết kế cần xem xét nhiều yếu tố: giấy phép của thư viện có phù hợp không, thư viện có ổn định và được hỗ trợ tốt không, và việc tích hợp nó vào kiến trúc hiện tại có gây ra vấn đề gì không (ví dụ: xung đột phụ thuộc, ảnh hưởng hiệu năng)."
  },
  {
    "question": "96. Thiết kế giao diện lập trình ứng dụng (API Design) là một phần quan trọng của:",
    "a": "Thiết kế UI.",
    "b": "Thiết kế kiến trúc và thiết kế chi tiết, đặc biệt khi xây dựng các hệ thống con, component hoặc microservices cần giao tiếp với nhau.",
    "c": "Thiết kế cơ sở dữ liệu.",
    "d": "Quản lý bản quyền mã nguồn mở.",
    "answer": "B",
    "theory": "Thiết kế API (Application Programming Interface) là việc định nghĩa cách các thành phần phần mềm (ví dụ: subsystems, components, microservices) sẽ tương tác với nhau. Một API được thiết kế tốt phải dễ hiểu, dễ sử dụng, ổn định và đáp ứng được nhu cầu của các client sử dụng nó."
  },
  {
    "question": "97. Khi thiết kế kiến trúc, việc cân bằng giữa các thuộc tính chất lượng (quality attributes) thường đối mặt với thách thức nào?",
    "a": "Các thuộc tính chất lượng luôn bổ trợ lẫn nhau một cách hoàn hảo.",
    "b": "Thường phải có sự đánh đổi (trade-offs), vì việc tối ưu một thuộc tính (ví dụ: hiệu năng) có thể ảnh hưởng tiêu cực đến thuộc tính khác (ví dụ: bảo mật, khả năng bảo trì).",
    "c": "Chỉ cần tập trung vào việc đáp ứng yêu cầu chức năng là đủ, các thuộc tính chất lượng không quan trọng bằng.",
    "d": "Các thuộc tính chất lượng chỉ quan trọng đối với giao diện người dùng.",
    "answer": "B",
    "theory": "Đây là câu hỏi lặp lại từ chương 5 (câu 97) và chương 8 (câu 97). Trong thiết kế kiến trúc, việc cố gắng tối ưu một thuộc tính chất lượng (ví dụ: tăng hiệu năng) thường dẫn đến sự đánh đổi với các thuộc tính chất lượng khác (ví dụ: có thể làm tăng độ phức tạp, giảm khả năng bảo trì hoặc tăng chi phí). Các kiến trúc sư phải tìm cách cân bằng các đánh đổi này."
  },
  {
    "question": "98. Việc đánh giá kiến trúc (Architectural Evaluation) nên được thực hiện vào thời điểm nào trong quá trình phát triển để mang lại hiệu quả cao nhất?",
    "a": "Chỉ sau khi hệ thống đã hoàn thành và sẵn sàng triển khai.",
    "b": "Chỉ trong giai đoạn kiểm thử cuối cùng.",
    "c": "Càng sớm càng tốt trong chu trình thiết kế (ngay sau khi có bản phác thảo kiến trúc) và có thể lặp lại khi kiến trúc được tinh chỉnh.",
    "d": "Chỉ khi có vấn đề nghiêm trọng xảy ra trong quá trình phát triển.",
    "answer": "C",
    "theory": "Đây là câu hỏi lặp lại từ chương 5 (câu 98) và chương 8 (câu 98). Đánh giá kiến trúc nên được thực hiện càng sớm càng tốt trong vòng đời phát triển, ngay khi có các bản phác thảo kiến trúc ban đầu. Việc phát hiện và sửa chữa các vấn đề kiến trúc sớm sẽ tốn ít chi phí hơn nhiều so với việc sửa chúng ở các giai đoạn sau."
  },
  {
    "question": "99. Hiện tượng \"Architectural Drift\" (hay \"Architectural Erosion\" - Xói mòn kiến trúc) mô tả điều gì?",
    "a": "Việc kiến trúc phần mềm trở nên quá phức tạp không cần thiết.",
    "b": "Sự sai lệch dần dần của cấu trúc hệ thống thực tế so với thiết kế kiến trúc ban đầu theo thời gian, thường do các thay đổi cục bộ không tuân thủ nguyên tắc kiến trúc.",
    "c": "Việc thay đổi hoàn toàn mẫu kiến trúc đã chọn giữa chừng dự án.",
    "d": "Việc thiếu hoàn toàn tài liệu mô tả kiến trúc.",
    "answer": "B",
    "theory": "Đây là câu hỏi lặp lại từ chương 5 (câu 99) và chương 8 (câu 99). Xói mòn kiến trúc (Architectural Drift/Erosion) là hiện tượng cấu trúc thực tế của hệ thống ngày càng sai lệch so với thiết kế kiến trúc ban đầu qua thời gian. Điều này thường xảy ra do các thay đổi, sửa lỗi, hoặc bổ sung tính năng được thực hiện mà không tuân thủ chặt chẽ các nguyên tắc và ràng buộc của kiến trúc đã định."
  },
  {
    "question": "100. \"Architectural Style\" (Kiểu kiến trúc) và \"Architectural Pattern\" (Mẫu kiến trúc) thường được phân biệt như thế nào?",
    "a": "Style là một giải pháp cụ thể, Pattern là một vấn đề chung chung.",
    "b": "Pattern mô tả một giải pháp đã được chứng minh cho một vấn đề thiết kế cụ thể, lặp đi lặp lại; Style mô tả một cách tiếp cận, một triết lý tổ chức hệ thống ở mức cao hơn, định hình cấu trúc tổng thể (ví dụ: Client-Server là một style, MVC là một pattern).",
    "c": "Không có sự khác biệt rõ ràng, chúng thường được dùng thay thế cho nhau.",
    "d": "Style chỉ áp dụng cho các hệ thống phân tán, Pattern áp dụng cho mọi hệ thống.",
    "answer": "B",
    "theory": "Đây là câu hỏi lặp lại từ chương 5 (câu 100) và chương 8 (câu 100). Architectural Style (Kiểu kiến trúc) là một tập hợp các nguyên tắc và ràng buộc về cách tổ chức hệ thống ở mức cao (ví dụ: Client-Server, Layered, Pipe-and-Filter). Architectural Pattern (Mẫu kiến trúc) là một giải pháp đã được kiểm chứng cho một vấn đề thiết kế cụ thể, thường có phạm vi nhỏ hơn Style (ví dụ: MVC, Repository). Một Style có thể được hiện thực hóa bằng nhiều Pattern khác nhau."
  },
  {
    "question": "1. Theo định nghĩa trong giáo trình, \"Hiện thực phần mềm\" (Implementation) bao gồm những hoạt động chính nào?",
    "a": "Chỉ lập trình (programming).",
    "b": "Lập trình (programming) và tích hợp (integration) các đơn vị (unit).",
    "c": "Chỉ thiết kế chi tiết.",
    "d": "Chỉ kiểm thử đơn vị.",
    "answer": "B",
    "theory": "Hiện thực phần mềm không chỉ là việc viết mã (lập trình) cho từng đơn vị (unit) mà còn bao gồm cả việc tích hợp các đơn vị đó lại với nhau để tạo thành các thành phần lớn hơn hoặc toàn bộ hệ thống."
  },
  {
    "question": "2. \"Unit\" trong \"Unit Implementation\" được hiểu là gì?",
    "a": "Toàn bộ hệ thống phần mềm.",
    "b": "Một module lớn của hệ thống.",
    "c": "Phần nhỏ nhất của phần mềm được duy trì một cách riêng biệt (thường là lớp hoặc phương thức).",
    "d": "Một yêu cầu chức năng.",
    "answer": "C",
    "theory": "Một \"unit\" trong ngữ cảnh hiện thực và kiểm thử đơn vị thường là một thành phần nhỏ nhất có thể kiểm thử được của phần mềm, chẳng hạn như một lớp, một phương thức, hoặc một hàm."
  },
  {
    "question": "3. Mục đích chính của giai đoạn Hiện thực là gì?",
    "a": "Thu thập yêu cầu từ khách hàng.",
    "b": "Đáp ứng các yêu cầu đã được mô tả trong thiết kế chi tiết.",
    "c": "Tối ưu hóa kiến trúc hệ thống.",
    "d": "Viết tài liệu hướng dẫn sử dụng.",
    "answer": "B",
    "theory": "Mục đích chính của giai đoạn hiện thực là chuyển đổi các đặc tả thiết kế chi tiết (Software Design Document - SDD) thành mã nguồn chạy được, đảm bảo rằng mã nguồn đó đáp ứng đúng các yêu cầu và thiết kế đã được xác định."
  },
  {
    "question": "4. Hai mục đích chính của việc mã hóa (coding) là gì?",
    "a": "Tốc độ và hiệu năng.",
    "b": "Tính đúng đắn (Correctness) và Tính rõ ràng (Clarity).",
    "c": "Bảo mật và khả năng mở rộng.",
    "d": "Hoàn thành nhanh và chi phí thấp.",
    "answer": "B",
    "theory": "Khi viết mã, mục tiêu quan trọng nhất là đảm bảo mã hoạt động đúng đắn (correctness) theo yêu cầu và thiết kế. Đồng thời, mã nguồn cũng cần phải rõ ràng, dễ đọc, dễ hiểu (clarity) để thuận tiện cho việc bảo trì và phát triển sau này."
  },
  {
    "question": "5. \"Quy tắc vàng\" được đề cập một cách ẩn ý trong quy trình phát triển là gì?",
    "a": "Chỉ viết code một lần duy nhất.",
    "b": "Luôn ưu tiên hiệu năng hơn mọi thứ khác.",
    "c": "Quy trình lặp đi lặp lại giữa việc xác định yêu cầu, thiết kế, hiện thực và kiểm tra.",
    "d": "Bỏ qua tài liệu hóa để tiết kiệm thời gian.",
    "answer": "C",
    "theory": "Quy trình phát triển phần mềm hiện đại thường mang tính lặp đi lặp lại (iterative) và tăng trưởng (incremental). Các hoạt động như xác định yêu cầu, thiết kế, hiện thực, và kiểm tra được thực hiện lặp đi lặp lại trong các chu kỳ ngắn, giúp thích ứng với thay đổi và cải thiện chất lượng liên tục."
  },
  {
    "question": "6. Bước đầu tiên trong việc chuẩn bị để hiện thực một đơn vị phần mềm là gì?",
    "a": "Viết mã nguồn ngay lập tức.",
    "b": "Ước lượng thời gian cần thiết.",
    "c": "Xác nhận (confirm) và hiểu rõ các thiết kế chi tiết (ví dụ: từ SDD) cần phải hiện thực.",
    "d": "Chuẩn bị form ghi lỗi.",
    "answer": "C",
    "theory": "Trước khi bắt tay vào viết mã cho một đơn vị phần mềm, lập trình viên cần đảm bảo rằng họ đã hiểu rõ các yêu cầu và thiết kế chi tiết của đơn vị đó, thường được mô tả trong Tài liệu Đặc tả Thiết kế (SDD) hoặc các tài liệu tương đương."
  },
  {
    "question": "7. Tại sao việc hiểu các tiêu chuẩn (ví dụ: coding standard, documentation standard) lại quan trọng trước khi bắt đầu hiện thực?",
    "a": "Để làm tăng độ phức tạp của dự án.",
    "b": "Để đảm bảo tính nhất quán, dễ đọc, dễ bảo trì cho mã nguồn và tài liệu.",
    "c": "Chỉ là yêu cầu hình thức từ quản lý.",
    "d": "Để hạn chế sự sáng tạo của lập trình viên.",
    "answer": "B",
    "theory": "Tuân thủ các tiêu chuẩn về viết mã (coding standards) và tài liệu hóa (documentation standards) giúp tạo ra mã nguồn và tài liệu nhất quán, dễ đọc, dễ hiểu và dễ bảo trì hơn, đặc biệt khi làm việc trong một nhóm."
  },
  {
    "question": "8. Việc ước lượng kích thước (ví dụ: LOC) và thời gian hiện thực dựa trên dữ liệu lịch sử có lợi ích gì?",
    "a": "Đảm bảo dự án luôn hoàn thành đúng hạn.",
    "b": "Giúp lập kế hoạch thực tế hơn và quản lý tiến độ hiệu quả.",
    "c": "Làm tăng chi phí quản lý dự án.",
    "d": "Không có lợi ích thực tế nào.",
    "answer": "B",
    "theory": "Dữ liệu lịch sử từ các dự án tương tự có thể giúp ước lượng kích thước công việc (ví dụ: Lines of Code - LOC) và thời gian cần thiết để hiện thực một cách thực tế hơn, từ đó hỗ trợ việc lập kế hoạch và quản lý tiến độ dự án hiệu quả hơn."
  },
  {
    "question": "9. Mô hình hiện thực trong RUP (Rational Unified Process) thể hiện mối quan hệ nào?",
    "a": "Chỉ mối quan hệ giữa các file mã nguồn.",
    "b": "Mối quan hệ và sự truy vết (traceability) giữa các yếu tố thiết kế (design model) và các yếu tố hiện thực (implementation artifacts).",
    "c": "Chỉ cấu trúc thư mục dự án.",
    "d": "Chỉ quy trình biên dịch.",
    "answer": "B",
    "theory": "Trong RUP, Mô hình Hiện thực (Implementation Model) mô tả cách các yếu tố trong Mô hình Thiết kế (Design Model) được hiện thực hóa bằng các thành phần mã nguồn (implementation artifacts) như file mã nguồn, file thực thi. Sự truy vết giữa hai mô hình này là quan trọng."
  },
  {
    "question": "10. Stereotype «trace» trong mô hình hiện thực RUP dùng để làm gì?",
    "a": "Biểu diễn một file thực thi.",
    "b": "Chỉ ra mối liên kết truy vết nguồn gốc giữa phần tử thiết kế và phần tử hiện thực.",
    "c": "Biểu diễn quá trình biên dịch.",
    "d": "Biểu diễn một lớp trừu tượng.",
    "answer": "B",
    "theory": "Stereotype «trace» được sử dụng trong RUP (và UML nói chung) để biểu diễn một mối quan hệ phụ thuộc, chỉ ra rằng một phần tử (ví dụ: một file mã nguồn trong mô hình hiện thực) truy vết (trace) hoặc hiện thực hóa một phần tử khác (ví dụ: một lớp trong mô hình thiết kế)."
  },
  {
    "question": "11. Stereotype «file» trong mô hình hiện thực RUP đại diện cho điều gì?",
    "a": "Một lớp trong mô hình thiết kế.",
    "b": "Một package mã nguồn.",
    "c": "Một file vật lý trong hệ thống file (ví dụ: file mã nguồn .java, file .jar, file readme).",
    "d": "Một tiến trình đang chạy.",
    "answer": "C",
    "theory": "Stereotype «file» trong RUP được sử dụng để đại diện cho một artifact vật lý trong hệ thống file, chẳng hạn như một file mã nguồn, một file thực thi, một file tài liệu, v.v."
  },
  {
    "question": "12. Bước nào sau đây thường KHÔNG nằm trong quy trình hiện thực mã chương trình chi tiết được đề cập?",
    "a": "Lập kế hoạch cấu trúc và thiết kế mã.",
    "b": "Tự kiểm tra lại thiết kế/cấu trúc.",
    "c": "Gõ mã lệnh chương trình.",
    "d": "Họp với khách hàng để xác nhận lại yêu cầu.",
    "answer": "D",
    "theory": "Quy trình hiện thực mã chi tiết thường bao gồm việc lập kế hoạch (có thể là thiết kế ở mức thấp), viết mã, và tự kiểm tra/review mã. Việc họp với khách hàng để xác nhận yêu cầu thường thuộc giai đoạn phân tích yêu cầu hoặc các vòng lặp sớm hơn, không phải là bước trực tiếp trong việc gõ mã chi tiết."
  },
  {
    "question": "13. Tại sao việc \"tự kiểm tra lại mã lệnh – vẫn chưa biên dịch\" lại được gợi ý?",
    "a": "Để trì hoãn việc biên dịch.",
    "b": "Để phát hiện các lỗi logic hoặc lỗi không tuân thủ thiết kế/tiêu chuẩn trước khi trình biên dịch báo lỗi cú pháp.",
    "c": "Chỉ là bước không cần thiết.",
    "d": "Để đảm bảo mã nguồn chạy nhanh hơn.",
    "answer": "B",
    "theory": "Việc tự kiểm tra lại mã lệnh (desk checking) trước khi biên dịch giúp lập trình viên phát hiện sớm các lỗi logic, lỗi thiết kế, hoặc các vấn đề về tuân thủ tiêu chuẩn mà trình biên dịch có thể không phát hiện được. Điều này giúp tiết kiệm thời gian và công sức so với việc chỉ dựa vào trình biên dịch."
  },
  {
    "question": "14. Việc ghi chú lại các mốc thời gian trong quá trình hiện thực giúp ích gì?",
    "a": "Chỉ để báo cáo cho quản lý.",
    "b": "Giúp cải thiện kỹ năng ước lượng và phân tích hiệu quả công việc trong tương lai.",
    "c": "Làm tăng áp lực cho lập trình viên.",
    "d": "Không có tác dụng thực tế.",
    "answer": "B",
    "theory": "Ghi lại thời gian thực tế bỏ ra cho các tác vụ hiện thực giúp cải thiện kỹ năng ước lượng cho các tác vụ tương tự trong tương lai. Nó cũng cung cấp dữ liệu để phân tích năng suất và hiệu quả công việc, từ đó có thể cải tiến quy trình."
  },
  {
    "question": "15. Quy tắc đặt tên sử dụng getters và setters (ví dụ: getName(), setName()) thường áp dụng cho thành phần nào trong lớp?",
    "a": "Các phương thức khởi tạo (constructors).",
    "b": "Các thuộc tính (attributes) private để kiểm soát truy cập.",
    "c": "Các hằng số (constants).",
    "d": "Các lớp lồng nhau (nested classes).",
    "answer": "B",
    "theory": "Getters (ví dụ: `getName()`) và setters (ví dụ: `setName()`) là các phương thức công khai được sử dụng để truy cập (get) và thay đổi (set) giá trị của các thuộc tính (attributes) private của một lớp. Đây là một phần của nguyên tắc đóng gói (encapsulation)."
  },
  {
    "question": "16. Việc sử dụng tiền tố hoặc hậu tố để phân biệt biến lớp, biến cục bộ và tham số (ví dụ: _length, length, aLength) nhằm mục đích gì?",
    "a": "Làm cho tên biến dài hơn và khó đọc hơn.",
    "b": "Tăng tính rõ ràng của mã nguồn, giúp dễ dàng phân biệt phạm vi của biến.",
    "c": "Là yêu cầu bắt buộc của mọi ngôn ngữ lập trình.",
    "d": "Chỉ là sở thích cá nhân của lập trình viên.",
    "answer": "B",
    "theory": "Sử dụng các quy ước đặt tên nhất quán, ví dụ như dùng tiền tố (_ cho biến instance, a cho argument/tham số), có thể giúp tăng tính rõ ràng của mã nguồn, giúp người đọc nhanh chóng xác định được phạm vi và loại của một biến."
  },
  {
    "question": "17. Quy ước đặt tên lớp bắt đầu bằng ký tự in hoa và tên biến bắt đầu bằng ký tự thường là một ví dụ của:",
    "a": "Tối ưu hóa hiệu năng.",
    "b": "Quy tắc bảo mật.",
    "c": "Tiêu chuẩn mã hóa (Coding Standard) về phong cách (style).",
    "d": "Kỹ thuật kiểm thử.",
    "answer": "C",
    "theory": "Các quy ước đặt tên (naming conventions) như việc lớp bắt đầu bằng chữ hoa (PascalCase) và biến/phương thức bắt đầu bằng chữ thường (camelCase) là một phần của tiêu chuẩn mã hóa về phong cách, giúp mã nguồn nhất quán và dễ đọc hơn."
  },
  {
    "question": "18. Tại sao nên sử dụng các từ nối (ví dụ: cylinderLength) thay vì viết tắt khó hiểu khi đặt tên?",
    "a": "Để tên biến/phương thức ngắn gọn nhất có thể.",
    "b": "Để tăng tính dễ đọc và dễ hiểu của mã nguồn.",
    "c": "Để giảm kích thước file mã nguồn.",
    "d": "Để gây khó khăn cho người khác khi đọc code.",
    "answer": "B",
    "theory": "Sử dụng tên đầy đủ, có ý nghĩa, và dễ hiểu (ví dụ: `cylinderLength` thay vì `cylLen` hoặc `cl`) giúp mã nguồn dễ đọc và dễ bảo trì hơn, ngay cả khi tên đó dài hơn một chút. Tránh viết tắt khó hiểu."
  },
  {
    "question": "19. Việc sử dụng static final (trong Java) cho các hằng số (ví dụ: MAX_NAME_LENGTH) mang lại lợi ích gì?",
    "a": "Cho phép thay đổi giá trị của hằng số trong quá trình chạy.",
    "b": "Đảm bảo giá trị không đổi và có thể truy cập mà không cần tạo đối tượng.",
    "c": "Làm giảm hiệu năng chương trình.",
    "d": "Chỉ dùng cho các hằng số kiểu số nguyên.",
    "answer": "B",
    "theory": "Trong Java, `static final` được sử dụng để khai báo hằng số. `final` đảm bảo giá trị không thể thay đổi sau khi được gán. `static` cho phép truy cập hằng số đó thông qua tên lớp mà không cần tạo đối tượng của lớp, và giá trị hằng số được chia sẻ cho tất cả các đối tượng."
  },
  {
    "question": "20. Cấu trúc thư mục dự án (ví dụ: tách riêng Source/Resource) giúp ích gì?",
    "a": "Tăng kích thước dự án.",
    "b": "Tổ chức mã nguồn và tài nguyên một cách logic, dễ quản lý và tìm kiếm.",
    "c": "Làm chậm quá trình biên dịch.",
    "d": "Không có lợi ích gì.",
    "answer": "B",
    "theory": "Một cấu trúc thư mục dự án được tổ chức tốt (ví dụ: tách riêng mã nguồn, tài nguyên, file test, tài liệu) giúp việc quản lý dự án, tìm kiếm file, và build hệ thống trở nên dễ dàng và logic hơn."
  },
  {
    "question": "21. Tài liệu hóa header của một file mã nguồn thường bao gồm thông tin gì?",
    "a": "Chỉ tên file.",
    "b": "Tên lớp (nếu có), thông tin phiên bản, ngày tạo, bản quyền, lịch sử chỉnh sửa.",
    "c": "Danh sách các lỗi đã sửa.",
    "d": "Kết quả kiểm thử đơn vị.",
    "answer": "B",
    "theory": "Header của một file mã nguồn thường chứa các thông tin meta-data quan trọng như tên file/lớp, mô tả ngắn gọn, tác giả, ngày tạo, thông tin bản quyền, và lịch sử các thay đổi quan trọng (version history)."
  },
  {
    "question": "22. Tài liệu hóa header của một phương thức (method) nên mô tả điều gì?",
    "a": "Chỉ kiểu dữ liệu trả về.",
    "b": "Mục đích của phương thức, cách thức hoạt động (nếu cần), ý nghĩa tham số (@param), ngoại lệ có thể ném ra (@exception), điều kiện trước/sau.",
    "c": "Chỉ tên của người viết phương thức.",
    "d": "Đoạn mã giả của phương thức.",
    "answer": "B",
    "theory": "Tài liệu hóa header của một phương thức (ví dụ: Javadoc) nên cung cấp thông tin đầy đủ để người khác có thể hiểu và sử dụng phương thức đó một cách chính xác, bao gồm mục đích, ý nghĩa của các tham số, giá trị trả về, các ngoại lệ có thể xảy ra, và các điều kiện tiên quyết/hậu quả."
  },
  {
    "question": "23. Tại sao việc mô tả \"Nguyên nhân lựa chọn phạm vi truy xuất\" (ví dụ: public, private, protected) lại quan trọng trong tài liệu phương thức?",
    "a": "Để giải thích lý do tại sao phương thức được thiết kế với mức độ truy cập đó, hỗ trợ việc hiểu và bảo trì.",
    "b": "Chỉ là thông tin thừa.",
    "c": "Để tăng độ dài của tài liệu.",
    "d": "Chỉ cần thiết cho phương thức private.",
    "answer": "A",
    "theory": "Giải thích lý do lựa chọn một phạm vi truy xuất cụ thể (ví dụ: tại sao một phương thức là `private` thay vì `public`) giúp người đọc hiểu được ý đồ thiết kế và các ràng buộc, từ đó hỗ trợ việc bảo trì và tránh thay đổi không phù hợp sau này."
  },
  {
    "question": "24. Việc ghi lại \"Điều kiện trước\" (Pre-conditions) và \"Điều kiện sau\" (Post-conditions) cho một phương thức giúp ích gì?",
    "a": "Xác định rõ ràng các giả định về trạng thái đầu vào và đảm bảo về trạng thái đầu ra, hỗ trợ cho việc sử dụng và kiểm thử.",
    "b": "Làm cho phương thức khó sử dụng hơn.",
    "c": "Chỉ cần thiết cho các phương thức phức tạp.",
    "d": "Tăng thời gian chạy của phương thức.",
    "answer": "A",
    "theory": "Pre-conditions là các điều kiện phải đúng trước khi phương thức được gọi. Post-conditions là các điều kiện sẽ đúng sau khi phương thức thực thi xong (nếu pre-conditions được thỏa mãn). Việc xác định rõ chúng giúp định nghĩa \"hợp đồng\" của phương thức, hỗ trợ việc sử dụng đúng và kiểm thử hiệu quả."
  },
  {
    "question": "25. Tài liệu hóa thuộc tính (attribute) nên bao gồm thông tin gì?",
    "a": "Chỉ tên thuộc tính.",
    "b": "Mục đích sử dụng, các giá trị hợp lệ hoặc ràng buộc (ví dụ: 15 <= _age <= 130).",
    "c": "Lịch sử thay đổi giá trị của thuộc tính.",
    "d": "Tên của phương thức truy cập thuộc tính đó.",
    "answer": "B",
    "theory": "Tài liệu hóa một thuộc tính nên giải thích mục đích sử dụng của nó, kiểu dữ liệu, và quan trọng là các ràng buộc về giá trị hợp lệ hoặc các bất biến (invariants) liên quan đến thuộc tính đó."
  },
  {
    "question": "26. Mục đích chính của việc kiểm tra mã (Code Inspection/Review) là gì?",
    "a": "Tìm lỗi cú pháp mà trình biên dịch bỏ qua.",
    "b": "Đánh giá hiệu quả làm việc của lập trình viên.",
    "c": "Tìm các lỗi logic, lỗi không tuân thủ thiết kế/tiêu chuẩn, và các vấn đề tiềm ẩn khác mà kiểm thử có thể bỏ sót.",
    "d": "Chỉ để đảm bảo code được định dạng đẹp.",
    "answer": "C",
    "theory": "Code inspection/review là một quá trình kiểm tra tĩnh mã nguồn bởi người khác (không phải tác giả) nhằm phát hiện các lỗi (logic, thiết kế), các điểm không tuân thủ tiêu chuẩn, các vấn đề về hiệu năng, bảo mật, hoặc các đoạn mã khó hiểu, khó bảo trì."
  },
  {
    "question": "27. Ai thường là người thực hiện kiểm tra mã?",
    "a": "Chỉ người quản lý dự án.",
    "b": "Các lập trình viên khác trong nhóm (peer review) hoặc nhóm đảm bảo chất lượng.",
    "c": "Chỉ khách hàng.",
    "d": "Chỉ người viết ra đoạn mã đó.",
    "answer": "B",
    "theory": "Kiểm tra mã thường được thực hiện bởi các đồng nghiệp (peer review), các thành viên có kinh nghiệm hơn trong nhóm, hoặc một nhóm đảm bảo chất lượng (QA) độc lập. Việc có một cặp mắt thứ hai giúp phát hiện lỗi hiệu quả hơn."
  },
  {
    "question": "28. Checklist kiểm tra Class (ví dụ: C1-C8) nhằm đảm bảo điều gì?",
    "a": "Đảm bảo tên lớp đúng, lớp có mức trừu tượng phù hợp, header đầy đủ, liên kết yêu cầu rõ ràng, phụ thuộc được nêu, phạm vi truy cập hợp lý, tuân thủ chuẩn.",
    "b": "Chỉ kiểm tra tên lớp.",
    "c": "Chỉ kiểm tra tài liệu chuẩn (javadoc).",
    "d": "Đảm bảo lớp không có lỗi cú pháp.",
    "answer": "A",
    "theory": "Checklist kiểm tra Class thường bao gồm nhiều mục để đảm bảo chất lượng của lớp, bao gồm tính đúng đắn của tên, mức độ trừu tượng, sự đầy đủ của header, liên kết với yêu cầu, quản lý phụ thuộc, phạm vi truy cập, và tuân thủ các tiêu chuẩn mã hóa."
  },
  {
    "question": "29. Checklist kiểm tra thuộc tính (ví dụ: A1-A7) tập trung vào:",
    "a": "Chỉ kiểu dữ liệu của thuộc tính.",
    "b": "Sự cần thiết, tính tĩnh/final, phạm vi truy cập, quy ước đặt tên, tính độc lập, và chiến lược khởi tạo toàn diện.",
    "c": "Chỉ quy ước đặt tên.",
    "d": "Cách thuộc tính được sử dụng trong các phương thức.",
    "answer": "B",
    "theory": "Checklist kiểm tra thuộc tính xem xét các khía cạnh như sự cần thiết của thuộc tính, liệu nó có nên là `static` hoặc `final` không, phạm vi truy cập (public, private, protected) có phù hợp, tên có tuân thủ quy ước, có độc lập với các thuộc tính khác khi cần, và chiến lược khởi tạo có đảm bảo tính toàn vẹn."
  },
  {
    "question": "30. Checklist kiểm tra phương thức khởi tạo (constructor) (ví dụ: CO1-CO5) xem xét:",
    "a": "Chỉ số lượng tham số.",
    "b": "Sự cần thiết, việc tận dụng constructor khác, việc khởi tạo đủ thuộc tính, phạm vi truy cập, và việc gọi constructor lớp cha.",
    "c": "Tên của constructor.",
    "d": "Kiểu dữ liệu trả về của constructor (lưu ý: constructor không có kiểu trả về).",
    "answer": "B",
    "theory": "Checklist cho constructor xem xét sự cần thiết của constructor, liệu có thể tận dụng constructor chaining, tất cả các thuộc tính quan trọng có được khởi tạo đúng cách, phạm vi truy cập có phù hợp, và liệu constructor của lớp cha có được gọi đúng (nếu cần)."
  },
  {
    "question": "31. Checklist kiểm tra header phương thức (ví dụ: MH1-MH11) đảm bảo:",
    "a": "Chỉ tên phương thức đúng.",
    "b": "Tên phù hợp, phạm vi truy cập, tính tĩnh/final, mô tả mục đích rõ ràng, liên kết yêu cầu/thiết kế, nêu đủ invariants/pre-conditions/post-conditions, tuân thủ chuẩn tài liệu, kiểu tham số hợp lý.",
    "c": "Header không quá dài.",
    "d": "Chỉ mô tả các tham số.",
    "answer": "B",
    "theory": "Checklist cho header phương thức rất quan trọng, đảm bảo tên gọi có ý nghĩa, phạm vi truy cập và các modifier (static, final) là đúng, mô tả rõ mục đích, liên kết với yêu cầu, các điều kiện, tuân thủ chuẩn tài liệu hóa, và kiểu dữ liệu tham số hợp lý."
  },
  {
    "question": "32. Checklist kiểm tra nội dung phương thức (ví dụ: MB1-MB11) tập trung vào:",
    "a": "Chỉ số lượng dòng code.",
    "b": "Sự nhất quán với thiết kế (pseudocode/flowchart), việc tuân thủ preconditions/postconditions/invariants, tính kết thúc của vòng lặp, tuân thủ chuẩn, cân bằng dấu ngoặc, xử lý tham số bất hợp lệ, kiểu trả về đúng, và comment đầy đủ.",
    "c": "Tốc độ thực thi của phương thức.",
    "d": "Việc sử dụng biến toàn cục.",
    "answer": "B",
    "theory": "Checklist kiểm tra nội dung phương thức tập trung vào tính đúng đắn logic, sự nhất quán với thiết kế, việc xử lý các điều kiện biên và ngoại lệ, tính kết thúc của vòng lặp, tuân thủ các tiêu chuẩn mã hóa, và sự rõ ràng, đầy đủ của comment."
  },
  {
    "question": "33. Đo lường mã nguồn (Code Metrics) như LoC (Lines of Code) cung cấp thông tin về:",
    "a": "Độ phức tạp logic của mã nguồn.",
    "b": "Kích thước vật lý của mã nguồn.",
    "c": "Mức độ dễ bảo trì.",
    "d": "Số lượng lỗi tiềm ẩn.",
    "answer": "B",
    "theory": "LoC (Lines of Code) là một thước đo đơn giản về kích thước vật lý của mã nguồn. Nó có thể được sử dụng (một cách cẩn thận) để ước lượng nỗ lực, năng suất, hoặc so sánh kích thước giữa các module, nhưng không trực tiếp đo lường độ phức tạp hay chất lượng."
  },
  {
    "question": "34. Các số liệu Software Science của IEEE (n1, n2, N1, N2) đo lường dựa trên:",
    "a": "Số lượng module và lớp.",
    "b": "Số lượng toán tử (operators) và toán hạng (operands) duy nhất và tổng số lần xuất hiện của chúng.",
    "c": "Số lượng dòng comment.",
    "d": "Thời gian thực thi chương trình.",
    "answer": "B",
    "theory": "Các số liệu Software Science của Halstead dựa trên việc đếm số lượng toán tử (operators) và toán hạng (operands) trong mã nguồn, cả về số loại duy nhất (n1, n2) và tổng số lần xuất hiện (N1, N2), từ đó suy ra các thước đo về độ dài, khối lượng, độ khó, nỗ lực."
  },
  {
    "question": "35. Độ phức tạp Cyclomatic (Cyclomatic Complexity) đo lường điều gì?",
    "a": "Kích thước của mã nguồn.",
    "b": "Số lượng đường thực thi độc lập tuyến tính trong một module, thường liên quan đến số lượng điểm quyết định.",
    "c": "Số lượng biến được sử dụng.",
    "d": "Mức độ sử dụng lại code.",
    "answer": "B",
    "theory": "Độ phức tạp Cyclomatic của McCabe là một thước đo định lượng về độ phức tạp logic của một chương trình. Nó đo số lượng các đường đi độc lập tuyến tính qua đồ thị luồng điều khiển của chương trình, thường liên quan đến số lượng các câu lệnh điều kiện (if, while, for) và các điểm quyết định."
  },
  {
    "question": "36. Giá trị Độ phức tạp Cyclomatic cao thường gợi ý điều gì?",
    "a": "Mã nguồn rất dễ hiểu và bảo trì.",
    "b": "Mã nguồn có cấu trúc logic phức tạp, khó kiểm thử và tiềm ẩn nhiều lỗi hơn.",
    "c": "Mã nguồn có hiệu năng rất tốt.",
    "d": "Mã nguồn được viết rất ngắn gọn.",
    "answer": "B",
    "theory": "Giá trị Độ phức tạp Cyclomatic cao cho thấy module đó có nhiều đường đi logic, làm cho nó khó hiểu, khó kiểm thử toàn diện, và có khả năng chứa nhiều lỗi hơn. Thường có một ngưỡng khuyến nghị cho độ phức tạp này."
  },
  {
    "question": "37. Tại sao việc tích hợp (Integration) các đơn vị phần mềm lại cần thiết?",
    "a": "Để làm chậm quá trình phát triển.",
    "b": "Để kết hợp các phần đã được hiện thực và kiểm thử riêng lẻ thành một hệ thống hoặc hệ thống con hoạt động hoàn chỉnh.",
    "c": "Chỉ cần thiết khi sử dụng mô hình thác nước.",
    "d": "Để tăng số lượng lỗi.",
    "answer": "B",
    "theory": "Sau khi các đơn vị phần mềm (module, component) được phát triển và kiểm thử đơn vị, chúng cần được tích hợp lại với nhau để tạo thành một hệ thống lớn hơn. Quá trình tích hợp này nhằm đảm bảo các đơn vị có thể làm việc cùng nhau một cách chính xác."
  },
  {
    "question": "38. Trong mô hình thác nước, tích hợp thường diễn ra khi nào?",
    "a": "Ở đầu dự án.",
    "b": "Song song với việc viết code từng đơn vị.",
    "c": "Gần cuối giai đoạn hiện thực, sau khi hầu hết các đơn vị đã được hoàn thành.",
    "d": "Không cần tích hợp trong mô hình thác nước.",
    "answer": "C",
    "theory": "Trong mô hình thác nước truyền thống, giai đoạn tích hợp thường diễn ra sau khi tất cả (hoặc hầu hết) các đơn vị đã được phát triển và kiểm thử đơn vị xong. Đây là một kiểu tích hợp \"big bang\" hoặc tích hợp theo giai đoạn lớn."
  },
  {
    "question": "39. Trong các quy trình lặp như RUP, tích hợp diễn ra như thế nào?",
    "a": "Chỉ diễn ra một lần duy nhất ở cuối dự án.",
    "b": "Diễn ra thường xuyên, cuối mỗi vòng lặp (iteration) hoặc thậm chí thường xuyên hơn (continuous integration).",
    "c": "Không diễn ra trong RUP.",
    "d": "Chỉ tích hợp các đơn vị liên quan đến giao diện người dùng.",
    "answer": "B",
    "theory": "Trong các quy trình lặp và tăng trưởng như RUP, hoặc các phương pháp Agile, việc tích hợp được thực hiện thường xuyên, thường là vào cuối mỗi vòng lặp ngắn. Continuous Integration (CI) thậm chí còn khuyến khích tích hợp nhiều lần trong ngày."
  },
  {
    "question": "40. Quá trình \"Build\" trong phát triển phần mềm là gì?",
    "a": "Quá trình viết tài liệu thiết kế.",
    "b": "Quá trình biên dịch mã nguồn, liên kết thư viện và tạo ra một phiên bản thực thi hoặc có thể triển khai của phần mềm.",
    "c": "Quá trình thu thập yêu cầu.",
    "d": "Quá trình kiểm thử giao diện.",
    "answer": "B",
    "theory": "Quá trình build bao gồm các bước cần thiết để chuyển đổi từ mã nguồn thành một sản phẩm phần mềm có thể chạy được hoặc triển khai được. Điều này thường bao gồm biên dịch, liên kết thư viện, đóng gói, và đôi khi cả việc chạy các kiểm thử tự động."
  },
  {
    "question": "41. \"Single level iteration\" và \"Double level iteration\" trong quá trình build ám chỉ điều gì?",
    "a": "Số lượng lập trình viên tham gia build.",
    "b": "Các cấp độ tích hợp và build khác nhau, từ build cục bộ của lập trình viên đến build tích hợp của toàn đội.",
    "c": "Số lần build trong một ngày.",
    "d": "Loại công cụ build được sử dụng.",
    "answer": "B",
    "theory": "\"Single level iteration\" có thể ám chỉ build và tích hợp ở mức độ cá nhân hoặc một nhóm nhỏ. \"Double level iteration\" gợi ý có ít nhất hai cấp độ: build cục bộ (ví dụ: trên máy của lập trình viên) và build tích hợp (ví dụ: trên server CI, tích hợp mã nguồn từ nhiều người)."
  },
  {
    "question": "42. \"Final Build of Single Level\" có thể tương ứng với cái gì?",
    "a": "Build hàng ngày của một lập trình viên.",
    "b": "Build tích hợp cuối cùng cho một vòng lặp (iteration) hoặc một tính năng.",
    "c": "Build cuối cùng của toàn bộ dự án.",
    "d": "Build chỉ chứa mã nguồn.",
    "answer": "B",
    "theory": "Trong một quy trình lặp, \"Final Build of Single Level\" có thể hiểu là bản build hoàn chỉnh cho một vòng lặp phát triển (iteration) hoặc cho một tính năng cụ thể, trước khi nó được tích hợp vào một bản build lớn hơn hoặc được phát hành."
  },
  {
    "question": "43. Mục đích của \"Perform regression testing from prior build\" là gì?",
    "a": "Kiểm tra các chức năng mới được thêm vào.",
    "b": "Đảm bảo rằng các thay đổi mới không làm hỏng các chức năng đã hoạt động đúng ở bản build trước đó.",
    "c": "Chỉ kiểm tra giao diện người dùng.",
    "d": "Kiểm tra hiệu năng của bản build mới.",
    "answer": "B",
    "theory": "Kiểm thử hồi quy (Regression testing) được thực hiện sau khi có sự thay đổi trong mã nguồn để đảm bảo rằng các thay đổi đó không vô tình làm hỏng các chức năng đã hoạt động tốt trước đây."
  },
  {
    "question": "44. \"Retest functions/modules/interfaces if required\" được thực hiện khi nào?",
    "a": "Luôn luôn thực hiện cho mọi chức năng.",
    "b": "Khi có thay đổi được thực hiện liên quan đến chức năng/module/giao diện đó hoặc khi kiểm thử hồi quy thất bại.",
    "c": "Chỉ khi bắt đầu một vòng lặp mới.",
    "d": "Chỉ khi khách hàng yêu cầu.",
    "answer": "B",
    "theory": "Việc kiểm thử lại (retest) một chức năng, module, hoặc giao diện là cần thiết khi có sự thay đổi trong phần đó, hoặc khi một kiểm thử liên quan đến nó (ví dụ: kiểm thử hồi quy) bị thất bại ở lần chạy trước, để xác nhận rằng lỗi đã được sửa."
  },
  {
    "question": "45. \"Perform build integration tests\" tập trung vào việc kiểm tra:",
    "a": "Từng đơn vị mã nguồn riêng lẻ.",
    "b": "Sự tương tác và giao tiếp giữa các đơn vị/component vừa được tích hợp trong bản build hiện tại.",
    "c": "Giao diện người dùng đồ họa.",
    "d": "Tài liệu thiết kế.",
    "answer": "B",
    "theory": "Kiểm thử tích hợp (Integration testing) tập trung vào việc kiểm tra giao diện và sự tương tác giữa các đơn vị hoặc component đã được tích hợp với nhau, nhằm phát hiện các lỗi phát sinh do sự kết hợp này."
  },
  {
    "question": "46. \"Perform iteration system and usability tests\" diễn ra khi nào theo quy trình gợi ý?",
    "a": "Trước khi bắt đầu vòng lặp.",
    "b": "Sau khi việc phát triển của một vòng lặp (iteration) được xem là hoàn thành (Development of iteration complete).",
    "c": "Sau khi cài đặt hệ thống.",
    "d": "Sau khi công việc hoàn thành (Job complete).",
    "answer": "B",
    "theory": "Sau khi các hoạt động phát triển trong một vòng lặp (iteration) được coi là hoàn thành (ví dụ: các tính năng của vòng lặp đó đã được hiện thực và kiểm thử đơn vị/tích hợp), thì kiểm thử hệ thống (system test) và kiểm thử khả năng sử dụng (usability test) cho vòng lặp đó sẽ được thực hiện."
  },
  {
    "question": "47. Kiểm thử cài đặt (Installation tests) nhằm mục đích gì?",
    "a": "Kiểm tra logic nghiệp vụ.",
    "b": "Đảm bảo rằng phần mềm có thể được cài đặt thành công trên môi trường đích.",
    "c": "Kiểm tra hiệu năng tải trang.",
    "d": "Tìm lỗi cú pháp.",
    "answer": "B",
    "theory": "Kiểm thử cài đặt nhằm xác minh rằng phần mềm có thể được cài đặt (và gỡ cài đặt) một cách chính xác và đầy đủ trên các môi trường đích đã được chỉ định, bao gồm cả việc kiểm tra các file, cấu hình, và các phụ thuộc cần thiết."
  },
  {
    "question": "48. Kiểm thử chấp nhận (Acceptance tests) thường do ai thực hiện và nhằm mục đích gì?",
    "a": "Lập trình viên, để tìm lỗi code.",
    "b": "Người dùng cuối hoặc khách hàng, để xác nhận rằng hệ thống đáp ứng yêu cầu và có thể chấp nhận được.",
    "c": "Nhóm kiểm thử tự động, để chạy kiểm thử hồi quy.",
    "d": "Quản lý dự án, để kiểm tra tiến độ.",
    "answer": "B",
    "theory": "Kiểm thử chấp nhận (Acceptance testing) thường được thực hiện bởi người dùng cuối, khách hàng, hoặc đại diện của họ, để xác định xem hệ thống có đáp ứng được các yêu cầu nghiệp vụ và mong đợi của họ hay không, và liệu có thể chấp nhận sản phẩm để đưa vào sử dụng."
  },
  {
    "question": "49. Tại sao tính rõ ràng (clarity) của mã nguồn lại quan trọng đối với bảo trì?",
    "a": "Mã nguồn rõ ràng giúp người bảo trì dễ dàng hiểu, sửa lỗi và thêm tính năng mới.",
    "b": "Mã nguồn rõ ràng luôn chạy nhanh hơn.",
    "c": "Mã nguồn rõ ràng không cần kiểm thử.",
    "d": "Không quan trọng, chỉ cần chạy đúng là được.",
    "answer": "A",
    "theory": "Mã nguồn rõ ràng, dễ đọc và dễ hiểu sẽ giúp giảm đáng kể thời gian và công sức cần thiết cho việc bảo trì, bao gồm việc tìm và sửa lỗi, hiểu logic hiện có, và thêm các tính năng mới mà không gây ra lỗi không mong muốn."
  },
  {
    "question": "50. Việc tuân thủ các tiêu chuẩn mã hóa (coding standards) đóng góp vào mục tiêu nào?",
    "a": "Chỉ làm mã nguồn dài hơn.",
    "b": "Tăng tính nhất quán, dễ đọc, dễ hiểu và dễ bảo trì của mã nguồn.",
    "c": "Giảm hiệu năng của chương trình.",
    "d": "Hạn chế khả năng tái sử dụng mã.",
    "answer": "B",
    "theory": "Tiêu chuẩn mã hóa giúp đảm bảo rằng tất cả các thành viên trong nhóm viết mã theo một phong cách nhất quán, làm cho mã nguồn dễ đọc, dễ hiểu hơn đối với mọi người, từ đó cải thiện khả năng bảo trì và hợp tác."
  },

  {
    "question": "51. Sự khác biệt giữa \"Verification\" (Kiểm định) và \"Validation\" (Thẩm định) trong ngữ cảnh hiện thực và kiểm thử là gì?",
    "a": "Verification kiểm tra \"Are we building the product right?\" (sản phẩm có tuân thủ đặc tả/thiết kế không), Validation kiểm tra \"Are we building the right product?\" (sản phẩm có đáp ứng nhu cầu người dùng không).",
    "b": "Verification là kiểm thử tự động, Validation là kiểm thử thủ công.",
    "c": "Verification do lập trình viên làm, Validation do khách hàng làm.",
    "d": "Không có sự khác biệt.",
    "answer": "A",
    "theory": "Verification (Kiểm định) là quá trình đảm bảo rằng phần mềm được xây dựng đúng theo các đặc tả và thiết kế đã định (\"building the product right\"). Validation (Thẩm định) là quá trình đảm bảo rằng phần mềm đáp ứng được nhu cầu và mong đợi của người dùng (\"building the right product\")."
  },
  {
    "question": "52. Kiểm thử đơn vị (Unit testing) chủ yếu thuộc về hoạt động nào?",
    "a": "Validation (Thẩm định).",
    "b": "Verification (Kiểm định - kiểm tra xem đơn vị có hoạt động đúng theo thiết kế của nó không).",
    "c": "Requirements analysis (Phân tích yêu cầu).",
    "d": "Deployment (Triển khai).",
    "answer": "B",
    "theory": "Kiểm thử đơn vị là một hoạt động Verification, nhằm xác minh rằng từng đơn vị (unit) nhỏ nhất của mã nguồn (ví dụ: phương thức, lớp) hoạt động đúng như thiết kế và đặc tả của nó."
  },
  {
    "question": "53. Kiểm thử chấp nhận người dùng (User Acceptance Testing - UAT) chủ yếu thuộc về hoạt động nào?",
    "a": "Verification (Kiểm định).",
    "b": "Validation (Thẩm định - kiểm tra xem sản phẩm có đáp ứng đúng nhu cầu người dùng không).",
    "c": "Coding (Mã hóa).",
    "d": "Architectural Design (Thiết kế kiến trúc).",
    "answer": "B",
    "theory": "UAT là một hoạt động Validation, nơi người dùng cuối kiểm tra xem hệ thống có đáp ứng được các yêu cầu và nhu cầu thực tế của họ trong môi trường làm việc hay không, trước khi chấp nhận sản phẩm."
  },
  {
    "question": "54. Công cụ nào thường được sử dụng để quản lý mã nguồn và theo dõi lịch sử thay đổi?",
    "a": "Trình biên dịch (Compiler).",
    "b": "Hệ thống quản lý phiên bản (Version Control System - VCS) như Git, SVN.",
    "c": "Công cụ vẽ lưu đồ (Flowchart tool).",
    "d": "Trình soạn thảo văn bản (Text editor).",
    "answer": "B",
    "theory": "Hệ thống quản lý phiên bản (VCS) như Git, Subversion (SVN), Mercurial được sử dụng để lưu trữ mã nguồn, theo dõi lịch sử các thay đổi, cho phép nhiều người làm việc song song, phân nhánh (branching), và hợp nhất (merging) mã nguồn."
  },
  {
    "question": "55. Tại sao việc sử dụng VCS lại hữu ích hơn việc ghi nhật ký thay đổi thủ công trong header file?",
    "a": "VCS cung cấp khả năng theo dõi chi tiết, phân nhánh, hợp nhất và khôi phục phiên bản hiệu quả hơn nhiều.",
    "b": "Ghi thủ công luôn chính xác hơn.",
    "c": "VCS chỉ dành cho các dự án mã nguồn mở.",
    "d": "VCS làm chậm quá trình phát triển.",
    "answer": "A",
    "theory": "VCS cung cấp một cơ chế tự động và mạnh mẽ để quản lý các thay đổi trong mã nguồn, bao gồm việc lưu trữ chi tiết ai thay đổi gì, khi nào, cho phép tạo các nhánh để phát triển độc lập, hợp nhất các thay đổi, và dễ dàng quay lại các phiên bản trước đó nếu cần. Việc ghi thủ công rất dễ sai sót và không hiệu quả bằng."
  },
  {
    "question": "56. \"Code Smell\" là thuật ngữ chỉ điều gì trong hiện thực phần mềm?",
    "a": "Mùi hương dễ chịu từ phòng làm việc của lập trình viên.",
    "b": "Bất kỳ triệu chứng nào trong mã nguồn có thể chỉ ra một vấn đề sâu sắc hơn trong thiết kế hoặc hiện thực (ví dụ: phương thức quá dài, lớp quá lớn, code trùng lặp).",
    "c": "Lỗi cú pháp nghiêm trọng.",
    "d": "Comment không rõ ràng.",
    "answer": "B",
    "theory": "Code Smell là một dấu hiệu bề ngoài trong mã nguồn cho thấy có thể có một vấn đề tiềm ẩn về thiết kế hoặc hiện thực. Nó không nhất thiết là một lỗi, nhưng thường là một chỉ báo rằng mã nguồn có thể cần được cải thiện (refactoring) để dễ hiểu, dễ bảo trì hơn."
  },
  {
    "question": "57. Hoạt động \"Refactoring\" thường được thực hiện để giải quyết vấn đề gì?",
    "a": "Thêm chức năng mới.",
    "b": "Sửa lỗi khẩn cấp.",
    "c": "Cải thiện cấu trúc và thiết kế của mã nguồn hiện có (loại bỏ code smell) mà không thay đổi hành vi bên ngoài của nó.",
    "d": "Tối ưu hóa cơ sở dữ liệu.",
    "answer": "C",
    "theory": "Refactoring là quá trình cải thiện cấu trúc bên trong của mã nguồn hiện có mà không làm thay đổi hành vi quan sát được từ bên ngoài. Mục đích chính là làm cho mã dễ hiểu, dễ bảo trì hơn, và loại bỏ các \"code smells\"."
  },
  {
    "question": "58. Continuous Integration (CI - Tích hợp liên tục) là một thực hành trong đó:",
    "a": "Mã nguồn chỉ được tích hợp một lần duy nhất trước khi release.",
    "b": "Lập trình viên tích hợp mã nguồn của họ vào kho chứa chung thường xuyên (ít nhất hàng ngày) và mỗi lần tích hợp đều được build và kiểm thử tự động.",
    "c": "Chỉ thực hiện kiểm thử thủ công.",
    "d": "Việc tích hợp do người quản lý dự án thực hiện thủ công.",
    "answer": "B",
    "theory": "Continuous Integration (CI) là một thực hành phát triển phần mềm trong đó các thành viên trong nhóm tích hợp công việc của họ thường xuyên, thường là nhiều lần mỗi ngày. Mỗi lần tích hợp được xác minh bằng một bản build tự động (bao gồm cả kiểm thử) để phát hiện lỗi tích hợp sớm."
  },
  {
    "question": "59. Lợi ích chính của Continuous Integration (CI) là gì?",
    "a": "Phát hiện sớm các xung đột và lỗi tích hợp, giảm rủi ro và thời gian sửa lỗi.",
    "b": "Làm tăng số lượng lỗi trong hệ thống.",
    "c": "Chỉ phù hợp với các dự án nhỏ.",
    "d": "Thay thế hoàn toàn việc kiểm thử đơn vị.",
    "answer": "A",
    "theory": "CI giúp phát hiện sớm các vấn đề phát sinh do việc tích hợp mã nguồn từ nhiều người, giảm thiểu rủi ro của việc tích hợp lớn ở cuối dự án, và cho phép sửa lỗi nhanh hơn khi chúng còn nhỏ và dễ khoanh vùng."
  },
  {
    "question": "60. Công cụ nào thường được sử dụng để tự động hóa quá trình Build và CI?",
    "a": "Microsoft Word.",
    "b": "Jenkins, GitLab CI/CD, GitHub Actions, Maven, Gradle.",
    "c": "Photoshop.",
    "d": "Công cụ vẽ UML.",
    "answer": "B",
    "theory": "Có nhiều công cụ hỗ trợ tự động hóa quá trình build và CI. Jenkins, GitLab CI/CD, GitHub Actions là các server CI phổ biến. Maven và Gradle là các công cụ build tự động thường được sử dụng cho các dự án Java và Android (Gradle)."
  },
  {
    "question": "61. \"Technical Debt\" (Nợ kỹ thuật) là khái niệm ám chỉ điều gì?",
    "a": "Khoản nợ tài chính của dự án phần mềm.",
    "b": "Chi phí tiềm ẩn trong tương lai do việc chọn giải pháp dễ dàng, nhanh chóng nhưng không tối ưu trong hiện tại (ví dụ: bỏ qua refactoring, viết code khó bảo trì).",
    "c": "Số lượng lỗi chưa được sửa.",
    "d": "Thời gian cần thiết để đào tạo lập trình viên mới.",
    "answer": "B",
    "theory": "Nợ kỹ thuật là một ẩn dụ, chỉ chi phí ngầm của việc phải làm lại công việc trong tương lai do đã chọn một giải pháp dễ dàng hoặc nhanh chóng (nhưng không phải là tốt nhất) ở hiện tại. Việc này có thể bao gồm việc bỏ qua refactoring, viết code chất lượng thấp, hoặc không cập nhật tài liệu."
  },
  {
    "question": "62. Việc tuân thủ thiết kế chi tiết (SDD) khi hiện thực quan trọng vì sao?",
    "a": "Chỉ để làm hài lòng nhà thiết kế.",
    "b": "Để đảm bảo rằng mã nguồn hiện thực đúng logic và cấu trúc đã được cân nhắc và phê duyệt, giảm thiểu lỗi và đảm bảo tính nhất quán.",
    "c": "Không quan trọng, lập trình viên có thể tự do thay đổi thiết kế.",
    "d": "Chỉ cần thiết khi sử dụng ngôn ngữ C++.",
    "answer": "B",
    "theory": "Thiết kế chi tiết (SDD) là kết quả của quá trình phân tích và thiết kế cẩn thận. Việc tuân thủ SDD khi hiện thực giúp đảm bảo rằng mã nguồn phản ánh đúng các quyết định thiết kế, duy trì tính toàn vẹn của kiến trúc, và giảm thiểu rủi ro phát sinh lỗi do hiểu sai hoặc hiện thực không đúng."
  },
  {
    "question": "63. \"Debugging\" (Gỡ lỗi) khác với \"Testing\" (Kiểm thử) như thế nào?",
    "a": "Testing tìm ra sự tồn tại của lỗi, Debugging xác định vị trí và nguyên nhân của lỗi để sửa chữa.",
    "b": "Debugging được thực hiện trước Testing.",
    "c": "Testing chỉ do tester làm, Debugging chỉ do lập trình viên làm.",
    "d": "Chúng là hai thuật ngữ đồng nghĩa.",
    "answer": "A",
    "theory": "Testing là hoạt động nhằm phát hiện sự tồn tại của lỗi bằng cách thực thi chương trình với các đầu vào cụ thể. Debugging là hoạt động sau khi lỗi đã được phát hiện, nhằm tìm ra vị trí (nguồn gốc) và nguyên nhân của lỗi đó để có thể sửa chữa."
  },
  {
    "question": "64. Công cụ Debugger thường cung cấp những khả năng nào?",
    "a": "Chỉ biên dịch mã nguồn.",
    "b": "Chạy chương trình từng bước, đặt điểm dừng (breakpoints), kiểm tra giá trị biến, xem call stack.",
    "c": "Tự động sửa lỗi logic.",
    "d": "Vẽ biểu đồ lớp.",
    "answer": "B",
    "theory": "Công cụ Debugger cung cấp các tính năng giúp lập trình viên theo dõi quá trình thực thi của chương trình, bao gồm việc chạy từng dòng lệnh (step-by-step execution), đặt các điểm dừng (breakpoints) để tạm ngưng chương trình tại vị trí mong muốn, kiểm tra giá trị của các biến, và xem call stack (lịch sử các lời gọi hàm)."
  },
  {
    "question": "65. Tại sao việc viết kiểm thử đơn vị (unit tests) trước hoặc song song với việc viết mã (Test-Driven Development - TDD) lại được khuyến khích?",
    "a": "Giúp định nghĩa rõ ràng yêu cầu của đơn vị mã, đảm bảo mã viết ra có thể kiểm thử được và cung cấp mạng lưới an toàn cho refactoring.",
    "b": "Làm tăng gấp đôi thời gian phát triển.",
    "c": "Chỉ phù hợp cho các hàm toán học đơn giản.",
    "d": "Gây khó khăn cho việc thiết kế.",
    "answer": "A",
    "theory": "TDD là một thực hành phát triển trong đó kiểm thử đơn vị được viết trước khi viết mã chức năng. Điều này giúp làm rõ yêu cầu cho đơn vị mã, đảm bảo mã được thiết kế để có thể kiểm thử, và tạo ra một bộ kiểm thử hồi quy tự động giúp an toàn khi refactoring hoặc thay đổi mã sau này."
  },
  {
    "question": "66. Mục tiêu của kiểm thử tích hợp (Integration Testing) là gì?",
    "a": "Kiểm tra từng đơn vị riêng lẻ.",
    "b": "Kiểm tra sự tương tác và giao tiếp giữa các đơn vị/component đã được tích hợp với nhau.",
    "c": "Kiểm tra hiệu năng tổng thể của hệ thống.",
    "d": "Kiểm tra giao diện người dùng.",
    "answer": "B",
    "theory": "Kiểm thử tích hợp được thực hiện sau khi các đơn vị đã được kiểm thử đơn vị và được kết hợp lại. Mục tiêu là phát hiện các lỗi phát sinh do sự tương tác giữa các đơn vị, ví dụ như lỗi giao diện, lỗi truyền dữ liệu, hoặc các giả định sai về hành vi của nhau."
  },
  {
    "question": "67. Chiến lược tích hợp \"Big Bang\" có nhược điểm gì?",
    "a": "Tích hợp tất cả các module cùng một lúc, khiến việc xác định nguồn gốc lỗi khi có vấn đề trở nên rất khó khăn.",
    "b": "Quá tốn thời gian để tích hợp từng module nhỏ.",
    "c": "Chỉ áp dụng được cho RUP.",
    "d": "Yêu cầu phải có công cụ CI.",
    "answer": "A",
    "theory": "Trong chiến lược tích hợp \"Big Bang\", tất cả các module được tích hợp cùng một lúc. Nếu có lỗi xảy ra, việc tìm ra module nào gây lỗi hoặc tương tác nào gây lỗi sẽ rất khó khăn và tốn thời gian do có quá nhiều điểm tương tác tiềm ẩn."
  },
  {
    "question": "68. Chiến lược tích hợp tăng dần (Incremental Integration), ví dụ Top-down hoặc Bottom-up, có ưu điểm gì so với Big Bang?",
    "a": "Lỗi tích hợp được phát hiện và định vị dễ dàng hơn do chỉ tích hợp một hoặc vài module mỗi lần.",
    "b": "Hoàn thành dự án nhanh hơn.",
    "c": "Không cần viết test driver hoặc test stub.",
    "d": "Yêu cầu ít tài nguyên kiểm thử hơn.",
    "answer": "A",
    "theory": "Trong tích hợp tăng dần, các module được tích hợp từng cái một hoặc từng nhóm nhỏ. Điều này giúp việc phát hiện và khoanh vùng lỗi tích hợp trở nên dễ dàng hơn, vì phạm vi tìm kiếm lỗi được giới hạn trong các module mới được tích hợp và giao diện của chúng."
  },
  {
    "question": "69. \"Test Stub\" thường được sử dụng trong chiến lược tích hợp nào và với mục đích gì?",
    "a": "Bottom-up, để mô phỏng module cấp cao hơn gọi module đang kiểm thử.",
    "b": "Top-down, để mô phỏng các module cấp thấp hơn được gọi bởi module đang kiểm thử.",
    "c": "Big Bang, để mô phỏng toàn bộ hệ thống.",
    "d": "Không dùng trong tích hợp.",
    "answer": "B",
    "theory": "Trong chiến lược tích hợp Top-down, các module cấp cao được kiểm thử trước. Khi một module cấp cao gọi một module cấp thấp chưa được hiện thực, một Test Stub (giả lập đơn giản) sẽ được sử dụng để thay thế module cấp thấp đó, trả về các giá trị giả định để module cấp cao có thể được kiểm thử."
  },
  {
    "question": "70. \"Test Driver\" thường được sử dụng trong chiến lược tích hợp nào và với mục đích gì?",
    "a": "Top-down, để mô phỏng module cấp thấp hơn.",
    "b": "Bottom-up, để mô phỏng module cấp cao hơn gọi module/nhóm module đang được kiểm thử.",
    "c": "Big Bang, để bắt đầu quá trình kiểm thử.",
    "d": "Chỉ dùng cho kiểm thử đơn vị.",
    "answer": "B",
    "theory": "Trong chiến lược tích hợp Bottom-up, các module cấp thấp được kiểm thử trước. Để kiểm thử một module cấp thấp, một Test Driver (một chương trình nhỏ) được viết để gọi module đó, cung cấp đầu vào và kiểm tra đầu ra, đóng vai trò như một module cấp cao hơn."
  },
  {
    "question": "71. Việc lựa chọn ngôn ngữ lập trình có ảnh hưởng đến giai đoạn hiện thực không?",
    "a": "Không, mọi ngôn ngữ đều như nhau.",
    "b": "Có, ảnh hưởng đến cú pháp, các thư viện có sẵn, hiệu năng, cộng đồng hỗ trợ, và đôi khi cả phong cách thiết kế.",
    "c": "Chỉ ảnh hưởng đến tốc độ biên dịch.",
    "d": "Chỉ ảnh hưởng đến kích thước file thực thi.",
    "answer": "B",
    "theory": "Lựa chọn ngôn ngữ lập trình có ảnh hưởng lớn đến giai đoạn hiện thực. Mỗi ngôn ngữ có cú pháp, hệ sinh thái thư viện, đặc điểm hiệu năng, và cộng đồng hỗ trợ riêng, điều này có thể ảnh hưởng đến năng suất, chất lượng mã nguồn, và khả năng giải quyết các vấn đề cụ thể."
  },
  {
    "question": "72. Khái niệm \"Code Readability\" (Tính dễ đọc của mã) phụ thuộc vào yếu tố nào?",
    "a": "Chỉ phụ thuộc vào độ dài của mã.",
    "b": "Cách đặt tên biến/hàm, cấu trúc mã, định dạng nhất quán, comment hợp lý, sự đơn giản của logic.",
    "c": "Chỉ phụ thuộc vào ngôn ngữ lập trình.",
    "d": "Chỉ phụ thuộc vào kinh nghiệm của người đọc.",
    "answer": "B",
    "theory": "Tính dễ đọc của mã phụ thuộc vào nhiều yếu tố, bao gồm việc đặt tên có ý nghĩa, cấu trúc logic rõ ràng, định dạng mã nhất quán, sử dụng comment hiệu quả để giải thích những phần phức tạp, và giữ cho logic đơn giản nhất có thể."
  },
  {
    "question": "73. Tại sao nên tránh sử dụng \"magic numbers\" (các hằng số không tường minh) trong code?",
    "a": "Làm mã nguồn khó hiểu và khó bảo trì khi cần thay đổi giá trị. Nên sử dụng hằng số có tên (named constants).",
    "b": "Chúng làm giảm hiệu năng.",
    "c": "Chúng gây lỗi biên dịch.",
    "d": "Chúng chỉ được phép dùng trong ngôn ngữ C.",
    "answer": "A",
    "theory": "\"Magic numbers\" là các giá trị hằng số xuất hiện trực tiếp trong mã mà không có giải thích về ý nghĩa của chúng. Điều này làm mã khó hiểu và khó bảo trì, vì nếu giá trị đó cần thay đổi, phải tìm và sửa ở nhiều nơi. Sử dụng hằng số có tên (ví dụ: `final int MAX_USERS = 100;`) sẽ cải thiện tính dễ đọc và dễ bảo trì."
  },
  {
    "question": "74. Mục đích của việc viết comment trong code là gì?",
    "a": "Giải thích những đoạn code phức tạp, mục đích của một khối mã, hoặc các quyết định thiết kế quan trọng (WHY, not just WHAT).",
    "b": "Lặp lại y nguyên những gì code đã thể hiện rõ ràng.",
    "c": "Làm cho file mã nguồn dài hơn.",
    "d": "Chỉ để ghi tên tác giả.",
    "answer": "A",
    "theory": "Comment nên được sử dụng để giải thích những phần code không tự minh bạch, ví dụ như logic phức tạp, lý do đằng sau một quyết định thiết kế, hoặc mục đích của một khối mã. Comment nên tập trung vào \"tại sao\" (WHY) hơn là chỉ mô tả lại \"cái gì\" (WHAT) mà code đã thể hiện rõ."
  },
  {
    "question": "75. Comment như thế nào được coi là \"tốt\"?",
    "a": "Càng nhiều comment càng tốt.",
    "b": "Comment giải thích rõ ràng \"tại sao\" (why) đoạn code được viết như vậy, thay vì chỉ mô tả \"cái gì\" (what) mà code đang làm (nếu code đã tự rõ ràng). Comment cần được cập nhật khi code thay đổi.",
    "c": "Chỉ comment ở đầu file.",
    "d": "Sử dụng ngôn ngữ địa phương thay vì tiếng Anh.",
    "answer": "B",
    "theory": "Comment tốt là comment cung cấp thông tin giá trị, giải thích ý đồ hoặc logic phức tạp mà không thể hiện rõ qua code. Nó phải chính xác và được cập nhật cùng với code. Tránh comment thừa thãi hoặc mô tả những điều hiển nhiên."
  },
  {
    "question": "76. Việc hiện thực các xử lý ngoại lệ (Exception Handling) quan trọng vì sao?",
    "a": "Để chương trình chạy nhanh hơn.",
    "b": "Để xử lý các tình huống lỗi hoặc bất thường một cách có kiểm soát, tránh chương trình bị dừng đột ngột và cung cấp thông tin hữu ích.",
    "c": "Chỉ cần thiết cho các ứng dụng web.",
    "d": "Làm tăng độ phức tạp không cần thiết.",
    "answer": "B",
    "theory": "Xử lý ngoại lệ là một phần quan trọng của việc viết mã mạnh mẽ (robust). Nó cho phép chương trình đối phó với các tình huống lỗi hoặc các điều kiện bất thường một cách có kiểm soát, thay vì bị crash. Nó cũng có thể cung cấp thông tin lỗi hữu ích cho người dùng hoặc để ghi log."
  },
  {
    "question": "77. Tài liệu nào là đầu vào quan trọng nhất cho giai đoạn hiện thực?",
    "a": "Kế hoạch dự án (Project Plan).",
    "b": "Đặc tả yêu cầu phần mềm (SRS - Software Requirements Specification).",
    "c": "Tài liệu thiết kế chi tiết (SDD - Software Design Document), bao gồm thiết kế lớp, thiết kế thuật toán, thiết kế giao diện.",
    "d": "Tài liệu kiểm thử (Test Plan).",
    "answer": "C",
    "theory": "Tài liệu Thiết kế Chi tiết (SDD) là đầu vào chính cho giai đoạn hiện thực. Nó cung cấp các đặc tả về cách hệ thống và các thành phần của nó nên được xây dựng, bao gồm cấu trúc lớp, thuật toán, giao diện, v.v."
  },
  {
    "question": "78. Kết quả đầu ra chính của giai đoạn hiện thực là gì?",
    "a": "Các mô hình thiết kế.",
    "b": "Mã nguồn đã được biên dịch, kiểm thử đơn vị và (một phần) tích hợp.",
    "c": "Kế hoạch kiểm thử chấp nhận.",
    "d": "Tài liệu yêu cầu.",
    "answer": "B",
    "theory": "Kết quả chính của giai đoạn hiện thực là mã nguồn hoạt động được (đã biên dịch), đã qua kiểm thử đơn vị, và có thể đã được tích hợp một phần hoặc toàn bộ, sẵn sàng cho các giai đoạn kiểm thử tiếp theo."
  },
  {
    "question": "79. Ai là người chịu trách nhiệm chính cho việc hiện thực mã nguồn?",
    "a": "Khách hàng.",
    "b": "Người quản lý dự án.",
    "c": "Lập trình viên (Developer/Programmer).",
    "d": "Người kiểm thử (Tester).",
    "answer": "C",
    "theory": "Lập trình viên (Developer hay Programmer) là người chịu trách nhiệm chính trong việc viết mã nguồn (coding) dựa trên các đặc tả thiết kế."
  },
  {
    "question": "80. Hoạt động nào giúp đảm bảo chất lượng trong suốt quá trình hiện thực?",
    "a": "Chỉ dựa vào kiểm thử cuối cùng.",
    "b": "Tuân thủ tiêu chuẩn mã hóa, viết kiểm thử đơn vị, thực hiện code review, tích hợp liên tục.",
    "c": "Chỉ viết comment đầy đủ.",
    "d": "Chỉ sử dụng IDE tốt nhất.",
    "answer": "B",
    "theory": "Đảm bảo chất lượng trong giai đoạn hiện thực là một quá trình liên tục, bao gồm nhiều hoạt động như tuân thủ coding standards, viết unit tests, thực hiện code reviews (ví dụ: peer reviews), và áp dụng tích hợp liên tục (CI) để phát hiện lỗi sớm."
  },
  {
    "question": "81. Độ phức tạp của mã hóa (Coding Complexity) có thể được giảm bớt bằng cách nào?",
    "a": "Chia nhỏ các phương thức/lớp thành các đơn vị nhỏ hơn, có trách nhiệm rõ ràng (Single Responsibility Principle).",
    "b": "Sử dụng tên biến ngắn nhất có thể.",
    "c": "Viết tất cả logic vào một phương thức lớn.",
    "d": "Tránh sử dụng comment.",
    "answer": "A",
    "theory": "Chia nhỏ các vấn đề phức tạp thành các đơn vị nhỏ hơn, dễ quản lý hơn, mỗi đơn vị có một trách nhiệm rõ ràng (theo Nguyên tắc Trách nhiệm Đơn lẻ - Single Responsibility Principle) là một cách hiệu quả để giảm độ phức tạp của mã hóa và cải thiện tính dễ hiểu, dễ bảo trì."
  },
  {
    "question": "82. Tài liệu hóa mã nguồn (Code Documentation) phục vụ mục đích gì?",
    "a": "Chỉ để đáp ứng yêu cầu quy trình.",
    "b": "Giúp các lập trình viên khác (và chính mình trong tương lai) hiểu được mã nguồn, cách sử dụng và bảo trì nó.",
    "c": "Làm chậm quá trình phát triển.",
    "d": "Chỉ cần thiết cho mã nguồn mở.",
    "answer": "B",
    "theory": "Tài liệu hóa mã nguồn (ví dụ: comment trong code, tài liệu API) rất quan trọng để giúp người khác (và chính tác giả sau một thời gian) hiểu được mã làm gì, tại sao nó được viết như vậy, và cách sử dụng nó. Điều này cực kỳ hữu ích cho việc bảo trì và phát triển tiếp."
  },
  {
    "question": "83. Sự khác biệt giữa hiện thực một lớp trừu tượng (abstract class) và một giao diện (interface) là gì?",
    "a": "Lớp trừu tượng không thể có phương thức cụ thể, interface có thể.",
    "b": "Interface có thể chứa thuộc tính, lớp trừu tượng thì không.",
    "c": "Một lớp có thể kế thừa nhiều lớp trừu tượng nhưng chỉ hiện thực một interface.",
    "d": "Một lớp kế thừa lớp trừu tượng (extends) và hiện thực giao diện (implements); lớp trừu tượng có thể có cả phương thức trừu tượng và cụ thể, interface (trong Java < 8) chỉ có phương thức trừu tượng (hoặc default/static từ Java 8+).",
    "answer": "D",
    "theory": "Trong Java, một lớp `extends` một lớp trừu tượng (chỉ một) và `implements` một hoặc nhiều giao diện. Lớp trừu tượng có thể có cả phương thức trừu tượng (không có thân hàm) và phương thức cụ thể (có thân hàm), cũng như các thuộc tính. Interface (trước Java 8) chỉ chứa các hằng số và chữ ký phương thức trừu tượng. Từ Java 8, interface có thể có cả phương thức default và static với hiện thực."
  },
  {
    "question": "84. Khi hiện thực một phương thức, việc kiểm tra các tham số đầu vào (input validation) quan trọng vì sao?",
    "a": "Để đảm bảo phương thức hoạt động đúng đắn với các dữ liệu không hợp lệ hoặc không mong đợi, tránh gây lỗi hoặc hành vi không xác định.",
    "b": "Chỉ cần thiết nếu phương thức là public.",
    "c": "Làm giảm hiệu năng của phương thức.",
    "d": "Không cần thiết nếu người gọi luôn truyền đúng tham số.",
    "answer": "A",
    "theory": "Kiểm tra tính hợp lệ của các tham số đầu vào là một thực hành tốt để đảm bảo phương thức hoạt động một cách mạnh mẽ (robust). Nó giúp xử lý các trường hợp dữ liệu đầu vào không mong đợi hoặc không hợp lệ, tránh gây ra lỗi không kiểm soát hoặc hành vi không xác định."
  },
  {
    "question": "85. Tích hợp hệ thống (System Integration) khác với tích hợp đơn vị/component (Unit/Component Integration) ở điểm nào?",
    "a": "Không có sự khác biệt.",
    "b": "Tích hợp hệ thống thường liên quan đến việc kết hợp các hệ thống con (subsystems) lớn hoặc kết nối với các hệ thống bên ngoài.",
    "c": "Tích hợp đơn vị phức tạp hơn tích hợp hệ thống.",
    "d": "Chỉ tích hợp hệ thống mới cần kiểm thử.",
    "answer": "B",
    "theory": "Tích hợp đơn vị/component tập trung vào việc kết hợp các module nhỏ bên trong một hệ thống. Tích hợp hệ thống thường ở một quy mô lớn hơn, liên quan đến việc kết hợp các subsystem đã được tích hợp lại với nhau, hoặc tích hợp hệ thống của chúng ta với các hệ thống bên ngoài khác."
  },
  {
    "question": "86. Việc sử dụng một \"Build Script\" (ví dụ: Ant, Maven, Gradle script) giúp tự động hóa những công việc gì?",
    "a": "Chỉ việc viết code.",
    "b": "Các bước như biên dịch mã nguồn, chạy kiểm thử, đóng gói ứng dụng, và đôi khi cả triển khai.",
    "c": "Chỉ việc quản lý yêu cầu.",
    "d": "Chỉ việc vẽ sơ đồ UML.",
    "answer": "B",
    "theory": "Build script tự động hóa các tác vụ lặp đi lặp lại trong quá trình build, bao gồm việc biên dịch mã nguồn, quản lý các phụ thuộc, chạy các kiểm thử tự động, đóng gói ứng dụng thành các định dạng có thể triển khai (ví dụ: JAR, WAR, APK), và đôi khi cả việc triển khai lên môi trường."
  },
  {
    "question": "87. Tại sao việc duy trì sự nhất quán giữa thiết kế và mã nguồn hiện thực lại quan trọng?",
    "a": "Giúp tài liệu thiết kế luôn phản ánh đúng trạng thái của hệ thống, hỗ trợ bảo trì và phát triển trong tương lai.",
    "b": "Chỉ là vấn đề thẩm mỹ.",
    "c": "Không quan trọng, code chạy đúng là được.",
    "d": "Chỉ cần thiết cho người quản lý.",
    "answer": "A",
    "theory": "Nếu mã nguồn hiện thực bị thay đổi mà tài liệu thiết kế không được cập nhật tương ứng (hoặc ngược lại), tài liệu thiết kế sẽ trở nên lỗi thời và không còn hữu ích. Duy trì sự nhất quán giúp đảm bảo tài liệu luôn là nguồn tham khảo đáng tin cậy cho việc hiểu, bảo trì và phát triển hệ thống."
  },
  {
    "question": "88. \"Code Coverage\" (Độ bao phủ mã) là một số liệu kiểm thử đo lường:",
    "a": "Tỷ lệ phần trăm mã nguồn đã được thực thi bởi các bộ kiểm thử.",
    "b": "Số lượng lỗi tìm thấy trên mỗi nghìn dòng code.",
    "c": "Thời gian cần thiết để chạy tất cả các kiểm thử.",
    "d": "Mức độ phức tạp của mã nguồn.",
    "answer": "A",
    "theory": "Code Coverage là một thước đo cho biết bao nhiêu phần trăm mã nguồn (ví dụ: dòng lệnh, nhánh, điều kiện) đã được thực thi trong quá trình chạy các bộ kiểm thử. Nó giúp đánh giá mức độ đầy đủ của việc kiểm thử."
  },
  {
    "question": "89. Đạt được 100% Code Coverage có đảm bảo rằng phần mềm không còn lỗi không?",
    "a": "Có, tuyệt đối không còn lỗi.",
    "b": "Không, nó chỉ đảm bảo mọi dòng lệnh/nhánh đã được chạy ít nhất một lần, nhưng không đảm bảo đúng đắn trong mọi tình huống hoặc logic.",
    "c": "Chỉ đảm bảo không có lỗi cú pháp.",
    "d": "Chỉ đảm bảo hiệu năng tốt.",
    "answer": "B",
    "theory": "Đạt 100% code coverage không có nghĩa là phần mềm không có lỗi. Nó chỉ cho biết tất cả các phần của mã đã được thực thi bởi các test case, nhưng không đảm bảo rằng các test case đó đã kiểm tra tất cả các tình huống logic có thể xảy ra hoặc các yêu cầu phi chức năng."
  },
  {
    "question": "90. Phong cách mã hóa (Coding Style) bao gồm những yếu tố nào?",
    "a": "Chỉ cách đặt tên biến.",
    "b": "Cách thụt lề, sử dụng khoảng trắng, vị trí dấu ngoặc, quy ước đặt tên, cách viết comment, v.v.",
    "c": "Chỉ thuật toán được sử dụng.",
    "d": "Chỉ ngôn ngữ lập trình.",
    "answer": "B",
    "theory": "Phong cách mã hóa (Coding Style) bao gồm một tập hợp các quy ước về cách viết và định dạng mã nguồn, như cách thụt lề, sử dụng khoảng trắng, vị trí đặt dấu ngoặc, quy ước đặt tên cho biến/hàm/lớp, cách viết comment, và nhiều quy tắc khác nhằm làm cho mã nguồn nhất quán và dễ đọc."
  },
  {
    "question": "91. Tại sao các nhóm phát triển thường thống nhất một Coding Style chung?",
    "a": "Để hạn chế sự sáng tạo.",
    "b": "Để tạo ra mã nguồn nhất quán, dễ đọc và dễ hiểu cho tất cả thành viên trong nhóm.",
    "c": "Chỉ vì quản lý yêu cầu.",
    "d": "Để làm chậm tiến độ.",
    "answer": "B",
    "theory": "Việc thống nhất một Coding Style chung trong nhóm giúp đảm bảo rằng mã nguồn do các thành viên khác nhau viết ra có cùng một diện mạo và cấu trúc, làm cho việc đọc, hiểu, và bảo trì mã của người khác trở nên dễ dàng hơn, cải thiện sự hợp tác."
  },
  {
    "question": "92. Hiện thực phần mềm có phải là một hoạt động hoàn toàn độc lập, không cần giao tiếp với các vai trò khác không?",
    "a": "Đúng, lập trình viên chỉ cần làm việc một mình.",
    "b": "Không, cần có sự giao tiếp thường xuyên với nhà thiết kế, tester, nhà phân tích nghiệp vụ và các lập trình viên khác.",
    "c": "Chỉ cần giao tiếp với tester.",
    "d": "Chỉ cần giao tiếp khi gặp lỗi.",
    "answer": "B",
    "theory": "Hiện thực phần mềm là một hoạt động hợp tác. Lập trình viên cần giao tiếp với nhà thiết kế để làm rõ các đặc tả, với tester để hiểu các kịch bản kiểm thử, với nhà phân tích nghiệp vụ để hiểu yêu cầu, và với các lập trình viên khác để phối hợp công việc và giải quyết các vấn đề tích hợp."
  },
  {
    "question": "93. Giai đoạn nào trong vòng đời phần mềm thường tốn nhiều chi phí nhất?",
    "a": "Thu thập yêu cầu.",
    "b": "Thiết kế.",
    "c": "Hiện thực.",
    "d": "Bảo trì và tiến hóa (thường chiếm phần lớn chi phí trong suốt vòng đời).",
    "answer": "D",
    "theory": "Đối với nhiều hệ thống phần mềm, đặc biệt là các hệ thống lớn và tồn tại lâu dài, chi phí cho việc bảo trì (sửa lỗi, thích ứng với thay đổi môi trường) và tiến hóa (thêm tính năng mới, cải tiến) thường chiếm phần lớn tổng chi phí trong suốt vòng đời của phần mềm, vượt xa chi phí phát triển ban đầu."
  },
  {
    "question": "94. Việc viết mã nguồn \"sạch\" (Clean Code) có ý nghĩa gì?",
    "a": "Mã nguồn không có comment.",
    "b": "Mã nguồn dễ đọc, dễ hiểu, dễ thay đổi, tuân thủ các nguyên tắc thiết kế tốt và tiêu chuẩn mã hóa.",
    "c": "Mã nguồn sử dụng ít biến nhất.",
    "d": "Mã nguồn được viết nhanh nhất.",
    "answer": "B",
    "theory": "Clean Code là mã nguồn được viết sao cho dễ đọc, dễ hiểu, và dễ bảo trì bởi người khác (và chính tác giả trong tương lai). Nó thường tuân thủ các nguyên tắc thiết kế tốt (như SOLID), có tên gọi rõ ràng, cấu trúc logic, và tránh sự phức tạp không cần thiết."
  },
  {
    "question": "95. Đâu là thách thức phổ biến trong giai đoạn tích hợp?",
    "a": "Các giao diện giữa các module không tương thích.",
    "b": "Các giả định sai về cách hoạt động của module khác.",
    "c": "Khó khăn trong việc xác định nguồn gốc lỗi khi nhiều module được tích hợp cùng lúc.",
    "d": "Tất cả các ý trên.",
    "answer": "D",
    "theory": "Giai đoạn tích hợp thường gặp nhiều thách thức, bao gồm sự không tương thích về giao diện giữa các module, các giả định sai lầm của các nhà phát triển về cách module khác hoạt động, và việc khó khăn trong việc khoanh vùng lỗi khi nhiều module được tích hợp đồng thời."
  },
  {
    "question": "96. Việc kiểm tra hiệu năng (Performance Testing) nên được thực hiện khi nào?",
    "a": "Chỉ sau khi hoàn thành toàn bộ hệ thống.",
    "b": "Có thể thực hiện ở cấp độ đơn vị, tích hợp và hệ thống, đặc biệt quan trọng khi tích hợp các thành phần có ảnh hưởng đến hiệu năng.",
    "c": "Không cần thiết phải kiểm tra hiệu năng.",
    "d": "Chỉ khi người dùng phàn nàn về tốc độ.",
    "answer": "B",
    "theory": "Kiểm tra hiệu năng không nên đợi đến cuối cùng. Nó có thể và nên được thực hiện ở các cấp độ khác nhau (đơn vị, tích hợp, hệ thống) để phát hiện sớm các vấn đề về hiệu năng. Đặc biệt quan trọng khi tích hợp các thành phần hoặc subsystem có khả năng ảnh hưởng đến thời gian đáp ứng hoặc thông lượng."
  },
  {
    "question": "97. Khi thiết kế kiến trúc, việc cân bằng giữa các thuộc tính chất lượng (quality attributes) thường đối mặt với thách thức nào?",
    "a": "Các thuộc tính chất lượng luôn bổ trợ lẫn nhau một cách hoàn hảo.",
    "b": "Thường phải có sự đánh đổi (trade-offs), vì việc tối ưu một thuộc tính (ví dụ: hiệu năng) có thể ảnh hưởng tiêu cực đến thuộc tính khác (ví dụ: bảo mật, khả năng bảo trì).",
    "c": "Chỉ cần tập trung vào việc đáp ứng yêu cầu chức năng là đủ, các thuộc tính chất lượng không quan trọng bằng.",
    "d": "Các thuộc tính chất lượng chỉ quan trọng đối với giao diện người dùng.",
    "answer": "B",
    "theory": "Đây là câu hỏi lặp lại từ chương 5 (câu 97) và chương 6 (câu 97). Trong thiết kế kiến trúc, việc cố gắng tối ưu một thuộc tính chất lượng (ví dụ: tăng hiệu năng) thường dẫn đến sự đánh đổi với các thuộc tính chất lượng khác (ví dụ: có thể làm tăng độ phức tạp, giảm khả năng bảo trì hoặc tăng chi phí). Các kiến trúc sư phải tìm cách cân bằng các đánh đổi này."
  },
  {
    "question": "98. Việc đánh giá kiến trúc (Architectural Evaluation) nên được thực hiện vào thời điểm nào trong quá trình phát triển để mang lại hiệu quả cao nhất?",
    "a": "Chỉ sau khi hệ thống đã hoàn thành và sẵn sàng triển khai.",
    "b": "Chỉ trong giai đoạn kiểm thử cuối cùng.",
    "c": "Càng sớm càng tốt trong chu trình thiết kế (ngay sau khi có bản phác thảo kiến trúc) và có thể lặp lại khi kiến trúc được tinh chỉnh.",
    "d": "Chỉ khi có vấn đề nghiêm trọng xảy ra trong quá trình phát triển.",
    "answer": "C",
    "theory": "Đây là câu hỏi lặp lại từ chương 5 (câu 98) và chương 6 (câu 98). Đánh giá kiến trúc nên được thực hiện càng sớm càng tốt trong vòng đời phát triển, ngay khi có các bản phác thảo kiến trúc ban đầu. Việc phát hiện và sửa chữa các vấn đề kiến trúc sớm sẽ tốn ít chi phí hơn nhiều so với việc sửa chúng ở các giai đoạn sau."
  },
  {
    "question": "99. Hiện tượng \"Architectural Drift\" (hay \"Architectural Erosion\" - Xói mòn kiến trúc) mô tả điều gì?",
    "a": "Việc kiến trúc phần mềm trở nên quá phức tạp không cần thiết.",
    "b": "Sự sai lệch dần dần của cấu trúc hệ thống thực tế so với thiết kế kiến trúc ban đầu theo thời gian, thường do các thay đổi cục bộ không tuân thủ nguyên tắc kiến trúc.",
    "c": "Việc thay đổi hoàn toàn mẫu kiến trúc đã chọn giữa chừng dự án.",
    "d": "Việc thiếu hoàn toàn tài liệu mô tả kiến trúc.",
    "answer": "B",
    "theory": "Đây là câu hỏi lặp lại từ chương 5 (câu 99) và chương 6 (câu 99). Xói mòn kiến trúc (Architectural Drift/Erosion) là hiện tượng cấu trúc thực tế của hệ thống ngày càng sai lệch so với thiết kế kiến trúc ban đầu qua thời gian. Điều này thường xảy ra do các thay đổi, sửa lỗi, hoặc bổ sung tính năng được thực hiện mà không tuân thủ chặt chẽ các nguyên tắc và ràng buộc của kiến trúc đã định."
  },
  {
    "question": "100. \"Architectural Style\" (Kiểu kiến trúc) và \"Architectural Pattern\" (Mẫu kiến trúc) thường được phân biệt như thế nào?",
    "a": "Style là một giải pháp cụ thể, Pattern là một vấn đề chung chung.",
    "b": "Pattern mô tả một giải pháp đã được chứng minh cho một vấn đề thiết kế cụ thể, lặp đi lặp lại; Style mô tả một cách tiếp cận, một triết lý tổ chức hệ thống ở mức cao hơn, định hình cấu trúc tổng thể (ví dụ: Client-Server là một style, MVC là một pattern).",
    "c": "Không có sự khác biệt rõ ràng, chúng thường được dùng thay thế cho nhau.",
    "d": "Style chỉ áp dụng cho các hệ thống phân tán, Pattern áp dụng cho mọi hệ thống.",
    "answer": "B",
    "theory": "Đây là câu hỏi lặp lại từ chương 5 (câu 100) và chương 6 (câu 100). Architectural Style (Kiểu kiến trúc) là một tập hợp các nguyên tắc và ràng buộc về cách tổ chức hệ thống ở mức cao (ví dụ: Client-Server, Layered, Pipe-and-Filter). Architectural Pattern (Mẫu kiến trúc) là một giải pháp đã được kiểm chứng cho một vấn đề thiết kế cụ thể, thường có phạm vi nhỏ hơn Style (ví dụ: MVC, Repository). Một Style có thể được hiện thực hóa bằng nhiều Pattern khác nhau."
  },

  {
    "question": "1. Mục tiêu chính của kiểm thử phần mềm là gì?",
    "a": "Chứng minh rằng phần mềm không có lỗi.",
    "b": "Tìm ra lỗi và chỉ ra rằng phần mềm hoạt động đúng như mong đợi.",
    "c": "Tối ưu hóa hiệu năng của phần mềm.",
    "d": "Viết tài liệu hướng dẫn sử dụng.",
    "answer": "B",
    "theory": "Mục tiêu chính của kiểm thử là phát hiện lỗi (defects) trong phần mềm. Đồng thời, kiểm thử cũng nhằm mục đích xác nhận rằng phần mềm hoạt động đúng theo các yêu cầu và mong đợi đã đặt ra. Không thể chứng minh phần mềm hoàn toàn không có lỗi."
  },
  {
    "question": "2. Hoạt động nào sau đây nhằm mục đích chỉ ra rằng phần mềm thỏa mãn các yêu cầu đã đặt ra?",
    "a": "Defect testing (Kiểm thử lỗi).",
    "b": "Validation testing (Kiểm thử thẩm định).",
    "c": "Regression testing (Kiểm thử hồi quy).",
    "d": "Unit testing (Kiểm thử đơn vị).",
    "answer": "B",
    "theory": "Validation testing (Kiểm thử thẩm định) nhằm mục đích xác nhận rằng phần mềm đáp ứng được nhu cầu của người dùng và thỏa mãn các yêu cầu đã được đặt ra (Are we building the right product?)."
  },
  {
    "question": "3. Hoạt động nào sau đây nhằm mục đích khám phá các lỗi hoặc khiếm khuyết trong phần mềm?",
    "a": "Validation testing (Kiểm thử thẩm định).",
    "b": "Defect testing (Kiểm thử lỗi).",
    "c": "User testing (Kiểm thử người dùng).",
    "d": "Acceptance testing (Kiểm thử chấp nhận).",
    "answer": "B",
    "theory": "Defect testing (Kiểm thử lỗi) là hoạt động được thiết kế đặc biệt để tìm kiếm các lỗi, khiếm khuyết, hoặc các điểm không phù hợp với đặc tả trong phần mềm."
  },
  {
    "question": "4. \"Verification\" (Kiểm định) trong V&V (Verification & Validation) trả lời câu hỏi nào?",
    "a": "\"Chúng ta có đang xây dựng đúng sản phẩm không?\" (Are we building the right product?)",
    "b": "\"Chúng ta có đang xây dựng sản phẩm đúng cách không?\" (Are we building the product right?)",
    "c": "\"Sản phẩm có dễ sử dụng không?\"",
    "d": "\"Chi phí phát triển là bao nhiêu?\"",
    "answer": "B",
    "theory": "Verification (Kiểm định) trả lời câu hỏi \"Are we building the product right?\", nghĩa là kiểm tra xem phần mềm có được xây dựng đúng theo các đặc tả, thiết kế, và tiêu chuẩn đã định hay không."
  },
  {
    "question": "5. \"Validation\" (Thẩm định) trong V&V (Verification & Validation) trả lời câu hỏi nào?",
    "a": "\"Chúng ta có đang xây dựng đúng sản phẩm không?\" (Are we building the right product?)",
    "b": "\"Chúng ta có đang xây dựng sản phẩm đúng cách không?\" (Are we building the product right?)",
    "c": "\"Mã nguồn có tuân thủ coding standard không?\"",
    "d": "\"Kiến trúc hệ thống có tối ưu không?\"",
    "answer": "A",
    "theory": "Validation (Thẩm định) trả lời câu hỏi \"Are we building the right product?\", nghĩa là kiểm tra xem phần mềm có đáp ứng được nhu cầu và mong đợi thực sự của người dùng và các bên liên quan hay không."
  },
  {
    "question": "6. Sự khác biệt cơ bản giữa kiểm thử (Testing) và gỡ lỗi (Debugging) là gì?",
    "a": "Testing tìm lỗi, Debugging sửa lỗi.",
    "b": "Debugging là một phần của Testing.",
    "c": "Testing thực hiện trước Debugging.",
    "d": "Cả a và c đều đúng.",
    "answer": "A",
    "theory": "Testing là quá trình thực thi phần mềm để tìm ra sự tồn tại của lỗi. Debugging là quá trình sau khi lỗi được phát hiện, nhằm xác định vị trí và nguyên nhân của lỗi để sửa chữa nó. Testing thường diễn ra trước Debugging."
  },
  {
    "question": "7. Thanh tra phần mềm (Software Inspection) là một kỹ thuật:",
    "a": "Kiểm thử động (Dynamic testing).",
    "b": "Kiểm thử tĩnh (Static verification), phân tích biểu diễn tĩnh của hệ thống.",
    "c": "Kiểm thử hiệu năng.",
    "d": "Kiểm thử người dùng.",
    "answer": "B",
    "theory": "Software Inspection (còn gọi là Fagan inspection) là một kỹ thuật kiểm thử tĩnh (static verification). Nó bao gồm việc xem xét kỹ lưỡng các sản phẩm phần mềm (như code, tài liệu thiết kế) bởi một nhóm người để tìm lỗi, mà không cần thực thi chương trình."
  },
  {
    "question": "8. Kiểm thử phần mềm (Software Testing) là một kỹ thuật:",
    "a": "Kiểm thử tĩnh (Static verification).",
    "b": "Kiểm thử động (Dynamic verification), thực thi và quan sát hành vi.",
    "c": "Chỉ dùng để kiểm tra tài liệu.",
    "d": "Chỉ thực hiện bởi khách hàng.",
    "answer": "B",
    "theory": "Software Testing là một kỹ thuật kiểm thử động (dynamic verification). Nó liên quan đến việc thực thi chương trình với các dữ liệu đầu vào cụ thể và quan sát hành vi, kết quả đầu ra để xác định xem có lỗi hay không."
  },
  {
    "question": "9. Mô hình quy trình kiểm thử phần mềm cơ bản bao gồm các bước nào?",
    "a": "Chỉ chạy chương trình và báo cáo kết quả.",
    "b": "Thiết kế test case → Chuẩn bị test data → Chạy chương trình với test data → So sánh kết quả.",
    "c": "Viết code → Chạy chương trình → Sửa lỗi.",
    "d": "Thu thập yêu cầu → Thiết kế → Kiểm thử.",
    "answer": "B",
    "theory": "Một quy trình kiểm thử cơ bản bao gồm các bước chính: Thiết kế các trường hợp kiểm thử (test cases) dựa trên đặc tả, chuẩn bị dữ liệu kiểm thử (test data) cho các test case đó, thực thi chương trình với test data, và so sánh kết quả thực tế với kết quả mong đợi để xác định lỗi."
  },
  {
    "question": "10. Kiểm thử hộp đen (Black-box testing) dựa trên yếu tố nào để thiết kế test case?",
    "a": "Cấu trúc mã nguồn bên trong.",
    "b": "Đặc tả yêu cầu chức năng và phi chức năng của phần mềm.",
    "c": "Kinh nghiệm cá nhân của lập trình viên.",
    "d": "Lưu đồ thuật toán.",
    "answer": "B",
    "theory": "Kiểm thử hộp đen (Black-box testing) tập trung vào việc kiểm tra chức năng của phần mềm dựa trên đặc tả yêu cầu, mà không cần biết đến cấu trúc bên trong (mã nguồn) của nó. Test case được thiết kế dựa trên đầu vào và đầu ra mong đợi."
  },
  {
    "question": "11. Kiểm thử hộp trắng (White-box testing) dựa trên yếu tố nào để thiết kế test case?",
    "a": "Yêu cầu của khách hàng.",
    "b": "Giao diện người dùng.",
    "c": "Cấu trúc logic và mã nguồn bên trong của phần mềm.",
    "d": "Tài liệu kiến trúc hệ thống.",
    "answer": "C",
    "theory": "Kiểm thử hộp trắng (White-box testing hay glass-box testing) dựa trên kiến thức về cấu trúc bên trong, logic và mã nguồn của phần mềm. Test case được thiết kế để kiểm tra các đường đi (paths) cụ thể trong mã, các điều kiện, vòng lặp, v.v."
  },
  {
    "question": "12. Kỹ thuật phân vùng tương đương (Equivalence Partitioning) thuộc loại kiểm thử nào?",
    "a": "Kiểm thử hộp trắng (White-box testing).",
    "b": "Kiểm thử hộp đen (Black-box testing).",
    "c": "Kiểm thử hồi quy (Regression testing).",
    "d": "Kiểm thử tích hợp (Integration testing).",
    "answer": "B",
    "theory": "Phân vùng tương đương là một kỹ thuật thiết kế test case hộp đen. Nó chia miền dữ liệu đầu vào thành các phân vùng (lớp) tương đương, nơi giả định rằng tất cả các giá trị trong một phân vùng sẽ cho kết quả tương tự. Chỉ cần chọn một giá trị đại diện từ mỗi phân vùng để kiểm thử."
  },
  {
    "question": "13. Kỹ thuật phân tích giá trị biên (Boundary Value Analysis) thường được sử dụng kết hợp với kỹ thuật nào?",
    "a": "Kiểm tra luồng điều khiển (Control flow testing).",
    "b": "Phân vùng tương đương (Equivalence Partitioning).",
    "c": "Kiểm thử trạng thái (State testing).",
    "d": "Kiểm thử đơn vị (Unit testing).",
    "answer": "B",
    "theory": "Phân tích giá trị biên (BVA) thường được sử dụng kết hợp với Phân vùng tương đương. Sau khi xác định các phân vùng tương đương, BVA tập trung vào việc kiểm thử các giá trị tại các điểm biên (boundaries) của các phân vùng đó, vì lỗi thường xảy ra ở các điểm biên."
  },
  {
    "question": "14. Mục tiêu của kiểm thử độ bao phủ câu lệnh (Statement Coverage) là gì?",
    "a": "Đảm bảo mọi hàm đều được gọi ít nhất một lần.",
    "b": "Đảm bảo mọi dòng lệnh trong mã nguồn được thực thi ít nhất một lần.",
    "c": "Đảm bảo mọi nhánh quyết định (true/false) đều được thực thi ít nhất một lần.",
    "d": "Đảm bảo mọi vòng lặp được thực thi đúng số lần.",
    "answer": "B",
    "theory": "Độ bao phủ câu lệnh (Statement Coverage) là một thước đo kiểm thử hộp trắng, nhằm đảm bảo rằng mỗi câu lệnh (statement) thực thi được trong mã nguồn đã được chạy ít nhất một lần trong quá trình kiểm thử."
  },
  {
    "question": "15. Kiểm thử độ bao phủ nhánh (Branch Coverage) / Quyết định (Decision Coverage) mạnh hơn Độ bao phủ câu lệnh vì sao?",
    "a": "Nó dễ thực hiện hơn.",
    "b": "Nó đảm bảo mọi dòng lệnh được chạy và còn đảm bảo mọi kết quả có thể có của các điểm quyết định (if, while,...) đều được kiểm tra.",
    "c": "Nó chỉ kiểm tra các nhánh 'true'.",
    "d": "Nó không yêu cầu xem mã nguồn.",
    "answer": "B",
    "theory": "Độ bao phủ nhánh (hay quyết định) yêu cầu mỗi nhánh có thể có của một điểm quyết định (ví dụ: cả nhánh true và false của một câu lệnh if) đều phải được thực thi ít nhất một lần. Điều này mạnh hơn độ bao phủ câu lệnh vì có thể có trường hợp mọi câu lệnh được chạy nhưng không phải tất cả các nhánh đều được kiểm tra."
  },
  {
    "question": "16. Kiểm thử trong khi xây dựng (Development testing) thường do ai thực hiện?",
    "a": "Khách hàng.",
    "b": "Đội ngũ kiểm thử độc lập.",
    "c": "Nhóm phát triển phần mềm (lập trình viên).",
    "d": "Người quản lý dự án.",
    "answer": "C",
    "theory": "Kiểm thử trong khi xây dựng (Development testing), bao gồm kiểm thử đơn vị (unit testing) và kiểm thử thành phần (component testing), thường được thực hiện bởi chính các lập trình viên hoặc nhóm phát triển trong quá trình họ xây dựng phần mềm."
  },
  {
    "question": "17. Kiểm thử đơn vị (Unit testing) tập trung vào việc kiểm tra:",
    "a": "Toàn bộ hệ thống.",
    "b": "Tương tác giữa các component.",
    "c": "Các đơn vị chương trình riêng lẻ (lớp, phương thức) một cách độc lập.",
    "d": "Giao diện người dùng.",
    "answer": "C",
    "theory": "Kiểm thử đơn vị tập trung vào việc kiểm tra các thành phần nhỏ nhất, có thể cô lập được của phần mềm (ví dụ: một phương thức, một lớp) để đảm bảo chúng hoạt động đúng theo đặc tả của chúng, một cách độc lập với các phần khác của hệ thống."
  },
  {
    "question": "18. Kiểm thử thành phần (Component testing) tập trung vào việc kiểm tra:",
    "a": "Từng dòng mã lệnh.",
    "b": "Giao diện (interface) của một component được tạo thành từ nhiều đơn vị.",
    "c": "Yêu cầu của người dùng cuối.",
    "d": "Cấu hình cài đặt.",
    "answer": "B",
    "theory": "Kiểm thử thành phần (Component testing) tập trung vào việc kiểm tra các component (thường được tạo thành từ việc tích hợp nhiều đơn vị) thông qua giao diện (interface) của chúng. Nó kiểm tra xem component có cung cấp đúng các dịch vụ được đặc tả qua giao diện hay không."
  },
  {
    "question": "19. Kiểm thử hệ thống (System testing) tập trung vào việc kiểm tra:",
    "a": "Các thuật toán riêng lẻ.",
    "b": "Tương tác giữa các component đã được tích hợp và các chức năng nổi bật của toàn hệ thống.",
    "c": "Tài liệu thiết kế.",
    "d": "Mã nguồn của từng lớp.",
    "answer": "B",
    "theory": "Kiểm thử hệ thống (System testing) được thực hiện trên toàn bộ hệ thống đã được tích hợp. Nó kiểm tra xem hệ thống có đáp ứng các yêu cầu chức năng và phi chức năng đã đặt ra hay không, bao gồm sự tương tác giữa các component và các hành vi nổi bật của hệ thống."
  },
  {
    "question": "20. Việc sử dụng framework như JUnit, NUnit hỗ trợ loại kiểm thử nào?",
    "a": "Kiểm thử hệ thống thủ công.",
    "b": "Kiểm thử chấp nhận người dùng.",
    "c": "Tự động hóa kiểm thử đơn vị (Automated unit testing).",
    "d": "Thanh tra mã nguồn (Code inspection).",
    "answer": "C",
    "theory": "JUnit (cho Java) và NUnit (cho .NET) là các framework phổ biến được sử dụng để viết và chạy các kiểm thử đơn vị một cách tự động. Chúng cung cấp các assertion, test runner, và các tiện ích khác để hỗ trợ việc kiểm thử đơn vị."
  },
  {
    "question": "21. Kiểm thử giao diện (Interface testing) nhằm mục đích gì?",
    "a": "Kiểm tra giao diện người dùng đồ họa.",
    "b": "Tìm lỗi do tương tác không đúng hoặc giả định sai về cách các module/component giao tiếp với nhau.",
    "c": "Chỉ kiểm tra các tham số kiểu số nguyên.",
    "d": "Kiểm tra tốc độ mạng.",
    "answer": "B",
    "theory": "Kiểm thử giao diện tập trung vào việc kiểm tra sự tương tác giữa các module, component, hoặc hệ thống thông qua các giao diện (APIs, tham số, định dạng dữ liệu). Mục đích là phát hiện lỗi do hiểu sai về giao diện, truyền dữ liệu không đúng, hoặc các giả định không chính xác về hành vi của nhau."
  },
  {
    "question": "22. Khi kiểm thử giao diện có tham số, tại sao nên kiểm tra các giá trị biên?",
    "a": "Vì lỗi thường xảy ra tại các điểm giới hạn của dải giá trị hợp lệ.",
    "b": "Chỉ để tăng số lượng test case.",
    "c": "Vì giá trị biên dễ nhập liệu hơn.",
    "d": "Chỉ là quy tắc ngẫu nhiên.",
    "answer": "A",
    "theory": "Kinh nghiệm cho thấy lỗi thường có xu hướng xảy ra tại các giá trị biên của một dải đầu vào (ví dụ: giá trị nhỏ nhất, lớn nhất, ngay bên trong và ngay bên ngoài dải hợp lệ). Do đó, kiểm tra các giá trị biên là một kỹ thuật quan trọng."
  },
  {
    "question": "23. Tại sao việc kiểm thử tham số con trỏ với giá trị null lại quan trọng?",
    "a": "Để đảm bảo chương trình không bị lỗi NullPointerException hoặc tương tự khi tham số là null.",
    "b": "null là giá trị phổ biến nhất.",
    "c": "Chỉ cần thiết trong ngôn ngữ C.",
    "d": "Để kiểm tra hiệu năng.",
    "answer": "A",
    "theory": "Nếu một phương thức mong đợi một đối tượng (tham chiếu/con trỏ) nhưng lại nhận được giá trị null, nó có thể gây ra lỗi NullPointerException (trong Java) hoặc các lỗi tương tự nếu không được xử lý đúng cách. Kiểm thử với giá trị null giúp đảm bảo chương trình xử lý tình huống này một cách an toàn."
  },
  {
    "question": "24. Stress testing trong hệ thống truyền thông điệp nhằm mục đích gì?",
    "a": "Kiểm tra giao diện người dùng.",
    "b": "Đánh giá khả năng xử lý của hệ thống dưới tải trọng cao hoặc bất thường, tìm ra giới hạn hoặc điểm yếu.",
    "c": "Chỉ kiểm tra định dạng thông điệp.",
    "d": "Kiểm tra khả năng cài đặt.",
    "answer": "B",
    "theory": "Stress testing đẩy hệ thống vượt quá giới hạn hoạt động bình thường của nó (ví dụ: gửi một lượng lớn thông điệp, tạo ra các điều kiện lỗi) để xem hệ thống phản ứng như thế nào, có phục hồi được không, và tìm ra các điểm yếu hoặc giới hạn chịu tải."
  },
  {
    "question": "25. Use case có thể được sử dụng làm cơ sở cho loại kiểm thử nào?",
    "a": "Chỉ kiểm thử đơn vị.",
    "b": "Kiểm thử hệ thống (System testing) và Kiểm thử chấp nhận (Acceptance testing) vì nó mô tả tương tác end-to-end.",
    "c": "Chỉ kiểm thử giao diện.",
    "d": "Chỉ kiểm thử hồi quy.",
    "answer": "B",
    "theory": "Use case mô tả cách người dùng tương tác với hệ thống để đạt được một mục tiêu. Do đó, chúng là cơ sở tốt để thiết kế các test case cho Kiểm thử Hệ thống (kiểm tra xem hệ thống có thực hiện đúng các chức năng từ đầu đến cuối) và Kiểm thử Chấp nhận (xác nhận hệ thống đáp ứng nhu cầu người dùng)."
  },
  {
    "question": "26. Kiểm thử hồi quy (Regression Testing) là gì?",
    "a": "Kiểm thử các chức năng mới được thêm vào.",
    "b": "Kiểm thử lại hệ thống sau khi có thay đổi để đảm bảo các chức năng cũ không bị ảnh hưởng tiêu cực.",
    "c": "Kiểm thử được thực hiện bởi người dùng cuối.",
    "d": "Kiểm thử hiệu năng của hệ thống.",
    "answer": "B",
    "theory": "Kiểm thử hồi quy được thực hiện mỗi khi có sự thay đổi trong mã nguồn (sửa lỗi, thêm tính năng mới, refactoring) để đảm bảo rằng các thay đổi đó không vô tình làm hỏng các chức năng đã hoạt động tốt trước đây."
  },
  {
    "question": "27. Tại sao kiểm thử hồi quy rất tốn kém nếu thực hiện thủ công?",
    "a": "Vì phải lặp lại một số lượng lớn các kiểm thử đã thực hiện trước đó.",
    "b": "Vì cần nhiều người thực hiện.",
    "c": "Vì yêu cầu phần cứng đặc biệt.",
    "d": "Vì khó thiết kế test case hồi quy.",
    "answer": "A",
    "theory": "Kiểm thử hồi quy thường bao gồm việc chạy lại một bộ lớn các test case đã được tạo ra từ trước để bao phủ các chức năng hiện có. Nếu thực hiện thủ công, việc này sẽ rất tốn thời gian và công sức, dễ gây nhàm chán và sai sót."
  },
  {
    "question": "28. Tự động hóa đóng vai trò quan trọng như thế nào đối với kiểm thử hồi quy?",
    "a": "Làm cho kiểm thử hồi quy trở nên khả thi và hiệu quả về chi phí bằng cách chạy lại các bộ kiểm thử một cách nhanh chóng.",
    "b": "Không có vai trò gì.",
    "c": "Chỉ giúp tạo báo cáo.",
    "d": "Chỉ áp dụng cho kiểm thử đơn vị.",
    "answer": "A",
    "theory": "Tự động hóa kiểm thử hồi quy cho phép chạy lại một bộ lớn các test case một cách nhanh chóng và nhất quán sau mỗi lần thay đổi. Điều này làm cho việc kiểm thử hồi quy trở nên khả thi, hiệu quả về chi phí và giúp phát hiện lỗi sớm."
  },
  {
    "question": "29. Kiểm thử bản phát hành (Release testing) thường do ai thực hiện?",
    "a": "Nhóm phát triển.",
    "b": "Một nhóm kiểm thử độc lập hoặc nhóm đảm bảo chất lượng (QA).",
    "c": "Khách hàng tiềm năng.",
    "d": "Người quản lý dự án.",
    "answer": "B",
    "theory": "Kiểm thử bản phát hành (Release testing) thường được thực hiện bởi một nhóm kiểm thử riêng biệt, độc lập với nhóm phát triển (ví dụ: đội QA). Mục đích là để đánh giá xem hệ thống đã sẵn sàng để phát hành cho khách hàng hay chưa, dựa trên một góc nhìn khách quan."
  },
  {
    "question": "30. Mục tiêu chính của Kiểm thử bản phát hành là gì?",
    "a": "Tìm ra mọi lỗi còn sót lại trong mã nguồn.",
    "b": "Thuyết phục các bên liên quan (bao gồm khách hàng) rằng hệ thống đủ tốt để phát hành và đáp ứng yêu cầu.",
    "c": "Tối ưu hóa hiệu năng cuối cùng.",
    "d": "Viết tài liệu người dùng.",
    "answer": "B",
    "theory": "Kiểm thử bản phát hành không nhằm mục đích tìm lỗi (mặc dù lỗi vẫn có thể được phát hiện) mà chủ yếu là để chứng minh rằng hệ thống đáp ứng các yêu cầu đã định và đủ chất lượng để phát hành cho người dùng. Nó là một dạng của validation testing."
  },
  {
    "question": "31. Kiểm thử bản phát hành thường tập trung vào phương pháp kiểm thử nào?",
    "a": "Chỉ kiểm thử hộp trắng.",
    "b": "Chủ yếu là kiểm thử hộp đen (dựa trên đặc tả và yêu cầu).",
    "c": "Chỉ kiểm thử đơn vị.",
    "d": "Chỉ thanh tra mã nguồn.",
    "answer": "B",
    "theory": "Kiểm thử bản phát hành thường tập trung vào kiểm thử hộp đen, nghĩa là kiểm tra hệ thống dựa trên đặc tả yêu cầu và hành vi quan sát được từ bên ngoài, mà không cần quan tâm đến cấu trúc bên trong. Điều này phản ánh cách người dùng sẽ sử dụng hệ thống."
  },
  {
    "question": "32. Kiểm thử hiệu năng (Performance testing) là một phần quan trọng của kiểm thử bản phát hành nhằm mục đích gì?",
    "a": "Đảm bảo giao diện người dùng đẹp mắt.",
    "b": "Đánh giá các thuộc tính phi chức năng như thời gian đáp ứng, thông lượng (throughput) dưới các tải trọng khác nhau.",
    "c": "Tìm lỗi logic trong các thuật toán.",
    "d": "Kiểm tra khả năng cài đặt.",
    "answer": "B",
    "theory": "Kiểm thử hiệu năng trong giai đoạn kiểm thử bản phát hành nhằm đánh giá xem hệ thống có đáp ứng được các yêu cầu về hiệu năng (ví dụ: thời gian phản hồi, khả năng chịu tải, thông lượng) đã được đặt ra trong các kịch bản sử dụng thực tế hay không."
  },
  {
    "question": "33. Stress testing khác với Load testing như thế nào?",
    "a": "Stress testing kiểm tra dưới tải trọng bình thường, Load testing kiểm tra dưới tải trọng cực hạn.",
    "b": "Load testing đánh giá hiệu năng dưới tải trọng dự kiến, Stress testing đẩy hệ thống vượt quá giới hạn để xem nó ứng xử/phục hồi ra sao.",
    "c": "Chúng là hai thuật ngữ đồng nghĩa.",
    "d": "Stress testing chỉ kiểm tra CPU, Load testing kiểm tra bộ nhớ.",
    "answer": "B",
    "theory": "Load testing kiểm tra hành vi của hệ thống dưới các mức tải trọng bình thường và dự kiến. Stress testing đi xa hơn, đẩy hệ thống đến hoặc vượt quá giới hạn chịu tải của nó để xem hệ thống phản ứng như thế nào khi gặp điều kiện khắc nghiệt (ví dụ: có bị crash không, có phục hồi được không)."
  },
  {
    "question": "34. Kiểm thử người dùng (User testing) là gì?",
    "a": "Lập trình viên tự kiểm thử mã của mình.",
    "b": "Nhóm QA kiểm thử hệ thống trong môi trường giả lập.",
    "c": "Người dùng thực tế hoặc tiềm năng sử dụng và kiểm thử hệ thống trong môi trường làm việc của họ.",
    "d": "Tự động chạy các script kiểm thử giao diện.",
    "answer": "C",
    "theory": "Kiểm thử người dùng là quá trình cho phép người dùng thực tế (hoặc đại diện của họ) sử dụng hệ thống trong môi trường làm việc tự nhiên của họ để đánh giá tính dễ sử dụng, sự phù hợp với nhu cầu, và phát hiện các vấn đề mà các loại kiểm thử khác có thể bỏ qua."
  },
  {
    "question": "35. Kiểm thử Alpha (Alpha testing) thường diễn ra ở đâu?",
    "a": "Tại địa điểm của khách hàng.",
    "b": "Tại địa điểm của nhà phát triển, với sự tham gia của người dùng (hoặc nhóm kiểm thử nội bộ đóng vai người dùng).",
    "c": "Công khai trên internet cho mọi người tham gia.",
    "d": "Chỉ trên môi trường đám mây.",
    "answer": "B",
    "theory": "Alpha testing thường được thực hiện tại môi trường của nhà phát triển (hoặc một môi trường kiểm soát) bởi một nhóm người dùng nội bộ hoặc một nhóm khách hàng được chọn lọc, trước khi sản phẩm được phát hành rộng rãi hơn."
  },
  {
    "question": "36. Kiểm thử Beta (Beta testing) thường diễn ra ở đâu?",
    "a": "Chỉ tại địa điểm của nhà phát triển.",
    "b": "Phát hành bản dùng thử cho một nhóm người dùng bên ngoài sử dụng trong môi trường thực tế của họ và cung cấp phản hồi.",
    "c": "Chỉ trong phòng thí nghiệm.",
    "d": "Không cần thiết cho phần mềm hiện đại.",
    "answer": "B",
    "theory": "Beta testing diễn ra sau Alpha testing, nơi sản phẩm được phát hành cho một nhóm người dùng bên ngoài (beta testers) sử dụng trong môi trường thực tế của họ. Mục đích là để thu thập phản hồi về các vấn đề, lỗi, và tính dễ sử dụng trong điều kiện sử dụng thực."
  },
  {
    "question": "37. Mục tiêu chính của Kiểm thử người dùng là gì?",
    "a": "Tìm lỗi cú pháp.",
    "b": "Đánh giá xem hệ thống có thực sự đáp ứng nhu cầu và mong đợi của người dùng trong thực tế hay không (Validation).",
    "c": "Kiểm tra kiến trúc hệ thống.",
    "d": "Đo lường độ bao phủ mã.",
    "answer": "B",
    "theory": "Mục tiêu chính của kiểm thử người dùng (bao gồm Alpha và Beta testing) là để xác nhận (validate) rằng hệ thống thực sự hữu ích, dễ sử dụng, và đáp ứng được nhu cầu của người dùng mục tiêu trong các kịch bản sử dụng thực tế."
  },
  {
    "question": "38. Đâu KHÔNG phải là một tiêu chí phổ biến để dừng kiểm thử?",
    "a": "Hoàn thành một phương pháp kiểm tra cụ thể (ví dụ: chạy hết các test case đã thiết kế).",
    "b": "Đạt được một tỷ lệ bao phủ mã nhất định (ví dụ: 95% bao phủ nhánh).",
    "c": "Tỷ lệ phát hiện lỗi giảm xuống dưới một ngưỡng nhất định.",
    "d": "Hết thời gian dự kiến cho giai đoạn kiểm thử, bất kể chất lượng.",
    "answer": "D",
    "theory": "Việc dừng kiểm thử chỉ vì hết thời gian mà không xem xét đến chất lượng hiện tại của sản phẩm (ví dụ: số lượng lỗi nghiêm trọng còn tồn tại, độ bao phủ chưa đạt) là một thực hành không tốt và có thể dẫn đến việc phát hành sản phẩm kém chất lượng."
  },
  {
    "question": "39. Phương pháp \"gieo hạt lỗi\" (fault seeding / defect seeding) được sử dụng để:",
    "a": "Cố tình thêm lỗi vào phần mềm để gây khó khăn cho người dùng.",
    "b": "Ước lượng số lượng lỗi còn lại trong phần mềm bằng cách xem tỷ lệ lỗi được \"gieo\" vào bị phát hiện trong quá trình kiểm thử.",
    "c": "Tăng tốc độ kiểm thử.",
    "d": "Tự động sửa các lỗi tìm thấy.",
    "answer": "B",
    "theory": "Trong phương pháp gieo hạt lỗi, một số lượng lỗi đã biết (hạt lỗi) được cố tình đưa vào phần mềm. Sau đó, quá trình kiểm thử được thực hiện. Tỷ lệ hạt lỗi được tìm thấy so với tổng số hạt lỗi được gieo có thể được sử dụng để ước lượng hiệu quả của quá trình kiểm thử và từ đó suy ra số lượng lỗi thực tế còn lại trong phần mềm."
  },
  {
    "question": "40. Tiến hóa phần mềm (Software Evolution) đề cập đến giai đoạn nào của vòng đời phần mềm?",
    "a": "Chỉ giai đoạn phát triển ban đầu.",
    "b": "Giai đoạn sau khi phần mềm được phát hành và đưa vào sử dụng, nơi nó tiếp tục được thay đổi và cập nhật.",
    "c": "Chỉ giai đoạn thu thập yêu cầu.",
    "d": "Chỉ giai đoạn kiểm thử.",
    "answer": "B",
    "theory": "Tiến hóa phần mềm là quá trình thay đổi và phát triển của phần mềm sau khi nó đã được triển khai và đưa vào sử dụng. Điều này bao gồm việc sửa lỗi, cải tiến, thêm tính năng mới, và thích ứng với môi trường thay đổi."
  },
  {
    "question": "41. Tại sao tiến hóa phần mềm lại quan trọng và tốn kém?",
    "a": "Vì yêu cầu kinh doanh, công nghệ và môi trường hoạt động liên tục thay đổi, đòi hỏi phần mềm phải thích ứng để duy trì giá trị. Chi phí bảo trì và nâng cấp thường chiếm phần lớn tổng chi phí vòng đời.",
    "b": "Vì lập trình viên thích viết lại code.",
    "c": "Vì khách hàng luôn đòi hỏi những thứ không cần thiết.",
    "d": "Tiến hóa không quan trọng và không tốn kém.",
    "answer": "A",
    "theory": "Phần mềm phải liên tục tiến hóa để đáp ứng các yêu cầu kinh doanh thay đổi, công nghệ mới, và sự thay đổi của môi trường vận hành. Nếu không, nó sẽ trở nên lỗi thời và mất giá trị. Quá trình bảo trì và tiến hóa này thường rất tốn kém, chiếm một phần lớn trong tổng chi phí vòng đời của phần mềm."
  },
  {
    "question": "42. Sự khác biệt giữa \"Evolution\" và \"Servicing\" trong vòng đời phần mềm là gì?",
    "a": "Evolution thêm chức năng mới, Servicing chỉ sửa lỗi.",
    "b": "Evolution diễn ra khi phần mềm còn được tích cực phát triển để đáp ứng yêu cầu mới, Servicing chỉ sửa lỗi và thực hiện các thay đổi nhỏ để duy trì hoạt động trong môi trường hiện tại (không thêm tính năng lớn).",
    "c": "Servicing tốn kém hơn Evolution.",
    "d": "Không có sự khác biệt.",
    "answer": "B",
    "theory": "Evolution (Tiến hóa) thường liên quan đến việc phát triển các phiên bản mới với tính năng mới hoặc cải tiến đáng kể để đáp ứng các yêu cầu thay đổi. Servicing (Bảo dưỡng) tập trung vào việc duy trì hoạt động của phiên bản hiện tại, bao gồm sửa lỗi, và thực hiện các điều chỉnh nhỏ để nó tiếp tục hoạt động trong môi trường hiện tại mà không thêm các tính năng lớn."
  },
  {
    "question": "43. Giai đoạn \"Phase-out\" của phần mềm nghĩa là gì?",
    "a": "Phần mềm đang được phát triển mạnh mẽ nhất.",
    "b": "Phần mềm vẫn được sử dụng nhưng không còn được thay đổi hay nâng cấp nữa, chuẩn bị được thay thế.",
    "c": "Phần mềm vừa được phát hành lần đầu.",
    "d": "Phần mềm được chuyển sang mã nguồn mở.",
    "answer": "B",
    "theory": "Giai đoạn Phase-out (Loại bỏ dần) là giai đoạn cuối trong vòng đời của một số phần mềm, khi nó không còn được hỗ trợ tích cực (không có bản vá lỗi, không có nâng cấp) và đang được lên kế hoạch để thay thế bằng một hệ thống mới hơn, mặc dù nó có thể vẫn đang được sử dụng."
  },
  {
    "question": "44. Quy trình xử lý yêu cầu thay đổi (Change Request) trong tiến hóa phần mềm thường bao gồm bước nào?",
    "a": "Chấp nhận và thực hiện ngay mọi yêu cầu thay đổi.",
    "b": "Phân tích tác động (Impact Analysis), Lập kế hoạch phát hành (Release Planning), Hiện thực thay đổi.",
    "c": "Chỉ cần ghi nhận yêu cầu thay đổi.",
    "d": "Từ chối mọi yêu cầu thay đổi sau khi phát hành.",
    "answer": "B",
    "theory": "Một quy trình xử lý yêu cầu thay đổi có cấu trúc thường bao gồm các bước: Tiếp nhận yêu cầu, Phân tích tác động của thay đổi (về kỹ thuật, chi phí, thời gian), Quyết định chấp nhận/từ chối, Lập kế hoạch cho việc hiện thực (nếu chấp nhận), Hiện thực thay đổi, Kiểm thử, và Phát hành."
  },
  {
    "question": "45. Phân tích tác động (Impact Analysis) trong quy trình thay đổi nhằm mục đích gì?",
    "a": "Ước tính chi phí và thời gian cần thiết để thực hiện thay đổi, xác định các phần khác của hệ thống có thể bị ảnh hưởng.",
    "b": "Chỉ để xác định ai là người yêu cầu thay đổi.",
    "c": "Để viết lại yêu cầu thay đổi.",
    "d": "Để quyết định có nên sửa lỗi hay không.",
    "answer": "A",
    "theory": "Phân tích tác động là một bước quan trọng để đánh giá ảnh hưởng của một yêu cầu thay đổi. Nó giúp xác định những phần nào của hệ thống sẽ bị ảnh hưởng, mức độ phức tạp của thay đổi, chi phí và thời gian ước tính, và các rủi ro tiềm ẩn, từ đó giúp đưa ra quyết định có thực hiện thay đổi hay không."
  },
  {
    "question": "46. Quy trình xử lý thay đổi khẩn cấp (Urgent Change Process) thường khác quy trình thông thường ở điểm nào?",
    "a": "Bỏ qua hoàn toàn việc phân tích và kiểm thử.",
    "b": "Quy trình được rút gọn hơn để có thể phát hành bản sửa lỗi nhanh chóng, có thể bỏ qua một số bước phê duyệt hoặc kiểm thử đầy đủ (nhưng vẫn cần kiểm thử cơ bản).",
    "c": "Chỉ áp dụng cho thay đổi giao diện.",
    "d": "Luôn tốn nhiều thời gian hơn quy trình thường.",
    "answer": "B",
    "theory": "Đối với các thay đổi khẩn cấp (ví dụ: sửa lỗi nghiêm trọng ảnh hưởng đến hoạt động kinh doanh), quy trình xử lý thường được rút gọn để có thể triển khai bản vá nhanh nhất có thể. Điều này có thể bao gồm việc bỏ qua một số bước phê duyệt hoặc giảm bớt phạm vi kiểm thử, nhưng vẫn cần đảm bảo tính ổn định cơ bản."
  },
  {
    "question": "47. Bảo trì phần mềm (Software Maintenance) được định nghĩa là:",
    "a": "Chỉ việc sửa lỗi sau khi phần mềm được phát hành.",
    "b": "Mọi hoạt động sửa đổi phần mềm sau khi nó đã được bàn giao và đưa vào sử dụng.",
    "c": "Chỉ việc thêm tính năng mới.",
    "d": "Chỉ việc nâng cấp phần cứng.",
    "answer": "B",
    "theory": "Bảo trì phần mềm bao gồm tất cả các hoạt động sửa đổi được thực hiện trên một sản phẩm phần mềm sau khi nó đã được triển khai và đưa vào sử dụng. Điều này bao gồm sửa lỗi, cải tiến, thích ứng với môi trường mới, và thêm các chức năng nhỏ."
  },
  {
    "question": "48. Loại bảo trì nào nhằm sửa các lỗi được phát hiện trong quá trình sử dụng?",
    "a": "Bảo trì thích ứng (Adaptive Maintenance).",
    "b": "Bảo trì hoàn thiện (Perfective Maintenance).",
    "c": "Bảo trì phòng ngừa (Preventive Maintenance).",
    "d": "Bảo trì sửa lỗi (Corrective Maintenance).",
    "answer": "D",
    "theory": "Bảo trì sửa lỗi (Corrective Maintenance) là loại bảo trì được thực hiện để sửa các lỗi (bugs) hoặc khiếm khuyết được phát hiện bởi người dùng hoặc trong quá trình vận hành phần mềm."
  },
  {
    "question": "49. Loại bảo trì nào nhằm điều chỉnh phần mềm để hoạt động trong môi trường mới (ví dụ: hệ điều hành mới, CSDL mới)?",
    "a": "Bảo trì sửa lỗi (Corrective Maintenance).",
    "b": "Bảo trì thích ứng (Adaptive Maintenance).",
    "c": "Bảo trì hoàn thiện (Perfective Maintenance).",
    "d": "Bảo trì phòng ngừa (Preventive Maintenance).",
    "answer": "B",
    "theory": "Bảo trì thích ứng (Adaptive Maintenance) là loại bảo trì được thực hiện để điều chỉnh phần mềm cho phù hợp với những thay đổi trong môi trường hoạt động của nó, chẳng hạn như nâng cấp hệ điều hành, thay đổi cơ sở dữ liệu, hoặc tích hợp với các hệ thống mới."
  },
  {
    "question": "50. Loại bảo trì nào nhằm cải thiện hiệu năng, khả năng bảo trì hoặc thêm các tính năng nhỏ mới theo yêu cầu người dùng?",
    "a": "Bảo trì sửa lỗi (Corrective Maintenance).",
    "b": "Bảo trì thích ứng (Adaptive Maintenance).",
    "c": "Bảo trì hoàn thiện (Perfective Maintenance).",
    "d": "Bảo trì phòng ngừa (Preventive Maintenance).",
    "answer": "C",
    "theory": "Bảo trì hoàn thiện (Perfective Maintenance) bao gồm các thay đổi nhằm cải thiện chất lượng của phần mềm (ví dụ: tăng hiệu năng, cải thiện khả năng bảo trì) hoặc thêm các tính năng nhỏ mới, thường dựa trên phản hồi hoặc yêu cầu từ người dùng."
  },
  {
    "question": "51. Loại bảo trì nào nhằm thay đổi phần mềm để làm cho nó dễ bảo trì hơn trong tương lai, ngay cả khi chưa có lỗi hay yêu cầu thay đổi cụ thể?",
    "a": "Bảo trì sửa lỗi (Corrective Maintenance).",
    "b": "Bảo trì thích ứng (Adaptive Maintenance).",
    "c": "Bảo trì hoàn thiện (Perfective Maintenance).",
    "d": "Bảo trì phòng ngừa (Preventive Maintenance).",
    "answer": "D",
    "theory": "Bảo trì phòng ngừa (Preventive Maintenance) là các hoạt động được thực hiện để cải thiện cấu trúc hoặc thiết kế của phần mềm, làm cho nó dễ bảo trì hơn trong tương lai, giảm khả năng phát sinh lỗi, ngay cả khi hiện tại chưa có lỗi hoặc yêu cầu thay đổi cụ thể. Refactoring là một ví dụ."
  },
  {
    "question": "52. Chi phí bảo trì thường bị ảnh hưởng bởi yếu tố nào?",
    "a": "Chất lượng của thiết kế và mã nguồn ban đầu.",
    "b": "Chất lượng của tài liệu đi kèm.",
    "c": "Kinh nghiệm của đội ngũ bảo trì.",
    "d": "Tất cả các yếu tố trên.",
    "answer": "D",
    "theory": "Chi phí bảo trì bị ảnh hưởng bởi nhiều yếu tố, bao gồm chất lượng của sản phẩm ban đầu (thiết kế tốt, code rõ ràng sẽ dễ bảo trì hơn), chất lượng của tài liệu, kinh nghiệm và kỹ năng của đội ngũ bảo trì, sự ổn định của môi trường, và tần suất thay đổi yêu cầu."
  },
  {
    "question": "53. Tại sao việc dự đoán chi phí bảo trì lại khó khăn?",
    "a": "Vì không thể biết trước được các yêu cầu thay đổi hoặc lỗi sẽ phát sinh.",
    "b": "Vì thiếu dữ liệu lịch sử về các hệ thống tương tự.",
    "c": "Vì sự thay đổi nhân sự trong đội bảo trì.",
    "d": "Cả a và b đều đúng.",
    "answer": "D",
    "theory": "Dự đoán chi phí bảo trì rất khó khăn vì nó phụ thuộc vào nhiều yếu tố không chắc chắn, như số lượng và độ phức tạp của các yêu cầu thay đổi hoặc lỗi sẽ phát sinh trong tương lai. Việc thiếu dữ liệu lịch sử đáng tin cậy về các hệ thống tương tự cũng làm tăng độ khó."
  },
  {
    "question": "54. Hệ thống kế thừa (Legacy System) là gì?",
    "a": "Một hệ thống phần mềm hoàn toàn mới.",
    "b": "Một hệ thống phần mềm cũ, thường lớn, quan trọng đối với hoạt động kinh doanh nhưng có thể khó bảo trì và thay đổi do công nghệ lỗi thời hoặc thiếu tài liệu.",
    "c": "Một hệ thống phần mềm mã nguồn mở.",
    "d": "Một hệ thống chỉ chạy trên máy mainframe.",
    "answer": "B",
    "theory": "Hệ thống kế thừa là các hệ thống phần mềm cũ đã tồn tại trong một thời gian dài, thường vẫn đóng vai trò quan trọng trong hoạt động kinh doanh nhưng đã trở nên khó bảo trì, khó thay đổi do sử dụng công nghệ cũ, thiếu tài liệu, hoặc cấu trúc phức tạp."
  },
  {
    "question": "55. Khi đánh giá một hệ thống kế thừa, cần xem xét hai yếu tố chính nào để quyết định chiến lược (ví dụ: bỏ đi, bảo trì, tái cấu trúc, thay thế)?",
    "a": "Giao diện người dùng và ngôn ngữ lập trình.",
    "b": "Giá trị kinh doanh (Business Value) và Chất lượng kỹ thuật (Technical Quality).",
    "c": "Kích thước mã nguồn và số lượng người dùng.",
    "d": "Tuổi đời của hệ thống và chi phí phần cứng.",
    "answer": "B",
    "theory": "Khi quyết định chiến lược cho một hệ thống kế thừa, hai yếu tố quan trọng cần xem xét là Giá trị kinh doanh mà hệ thống đó vẫn còn mang lại (nó có còn quan trọng không?) và Chất lượng kỹ thuật của nó (nó có dễ bảo trì, ổn định không?). Sự kết hợp của hai yếu tố này sẽ giúp định hướng chiến lược phù hợp."
  },
  {
    "question": "56. Tái cấu trúc hệ thống (System Re-engineering) là quá trình:",
    "a": "Viết lại hoàn toàn hệ thống từ đầu.",
    "b": "Phân tích hệ thống cũ và viết lại một phần hoặc toàn bộ để cải thiện cấu trúc, khả năng bảo trì mà thường giữ nguyên chức năng.",
    "c": "Chỉ nâng cấp phần cứng.",
    "d": "Chỉ sửa các lỗi nhỏ.",
    "answer": "B",
    "theory": "Tái cấu trúc hệ thống (System Re-engineering) là quá trình kiểm tra lại và thay đổi một hệ thống hiện có để cải thiện các thuộc tính như khả năng bảo trì, khả năng hiểu, hoặc hiệu năng, mà thường không làm thay đổi đáng kể chức năng bên ngoài của nó."
  },
  {
    "question": "57. \"Reverse Engineering\" trong quá trình tái cấu trúc là gì?",
    "a": "Viết mã nguồn từ thiết kế.",
    "b": "Phân tích mã nguồn của hệ thống cũ để hiểu thiết kế và đặc tả của nó (thường khi thiếu tài liệu).",
    "c": "Chạy chương trình ngược thời gian.",
    "d": "Dịch mã nguồn sang ngôn ngữ khác.",
    "answer": "B",
    "theory": "Reverse Engineering (Kỹ thuật đảo ngược) là quá trình phân tích một hệ thống hiện có (thường là mã nguồn) để hiểu được cấu trúc, thiết kế, và hành vi của nó, đặc biệt khi tài liệu gốc bị thiếu hoặc không đầy đủ. Đây là một bước quan trọng trong tái cấu trúc."
  },
  {
    "question": "58. \"Program Structure Improvement\" và \"Program Modularization\" nhằm mục đích gì?",
    "a": "Làm cho mã nguồn phức tạp hơn.",
    "b": "Cải thiện cấu trúc logic, chia nhỏ chương trình thành các module rõ ràng, dễ hiểu và dễ bảo trì hơn.",
    "c": "Tăng sự phụ thuộc giữa các module.",
    "d": "Chỉ để thay đổi tên biến.",
    "answer": "B",
    "theory": "Cải thiện cấu trúc chương trình (Program Structure Improvement) và module hóa chương trình (Program Modularization) là các kỹ thuật trong tái cấu trúc nhằm mục đích làm cho mã nguồn có cấu trúc logic tốt hơn, dễ hiểu hơn, và dễ bảo trì hơn bằng cách chia nhỏ thành các module có trách nhiệm rõ ràng và ít phụ thuộc lẫn nhau."
  },
  {
    "question": "59. Sự khác biệt cơ bản giữa Refactoring và Re-engineering là gì?",
    "a": "Refactoring là thay đổi nhỏ, liên tục trong quá trình phát triển/tiến hóa; Re-engineering là hoạt động lớn hơn, thường áp dụng cho hệ thống kế thừa để cải thiện cấu trúc tổng thể.",
    "b": "Refactoring thay đổi chức năng, Re-engineering không thay đổi.",
    "c": "Re-engineering luôn nhanh hơn Refactoring.",
    "d": "Chỉ Re-engineering mới sử dụng công cụ tự động.",
    "answer": "A",
    "theory": "Refactoring là các thay đổi nhỏ, có tính cục bộ, được thực hiện liên tục để cải thiện cấu trúc mã mà không thay đổi hành vi. Re-engineering là một quá trình lớn hơn, có thể bao gồm việc viết lại đáng kể các phần của hệ thống để cải thiện cấu trúc và khả năng bảo trì, thường áp dụng cho các hệ thống kế thừa."
  },
  {
    "question": "60. Kiểm thử đóng vai trò gì trong quá trình tiến hóa và bảo trì?",
    "a": "Không có vai trò gì.",
    "b": "Rất quan trọng, đặc biệt là kiểm thử hồi quy để đảm bảo các thay đổi không gây ra lỗi mới hoặc ảnh hưởng chức năng cũ.",
    "c": "Chỉ cần kiểm thử các tính năng mới.",
    "d": "Chỉ cần thiết nếu có tái cấu trúc lớn.",
    "answer": "B",
    "theory": "Kiểm thử, đặc biệt là kiểm thử hồi quy, đóng vai trò cực kỳ quan trọng trong quá trình tiến hóa và bảo trì. Mỗi khi có sự thay đổi (sửa lỗi, thêm tính năng, refactoring), cần phải kiểm thử lại để đảm bảo rằng thay đổi đó hoạt động đúng và không làm hỏng các phần khác của hệ thống."
  },
  {
    "question": "61. Kiểm thử đơn vị tự động đặc biệt hữu ích cho việc:",
    "a": "Kiểm thử giao diện người dùng.",
    "b": "Kiểm thử hiệu năng hệ thống lớn.",
    "c": "Hỗ trợ Refactoring và đảm bảo các thay đổi nhỏ không làm hỏng chức năng của đơn vị.",
    "d": "Thay thế hoàn toàn kiểm thử hệ thống.",
    "answer": "C",
    "theory": "Khi thực hiện refactoring hoặc các thay đổi nhỏ trong mã, bộ kiểm thử đơn vị tự động cung cấp một mạng lưới an toàn, giúp nhanh chóng phát hiện nếu các thay đổi đó vô tình làm hỏng chức năng hiện có của đơn vị được kiểm thử."
  },
  {
    "question": "62. Việc đo lường số liệu (metrics) trong kiểm thử và bảo trì giúp:",
    "a": "Chỉ để báo cáo.",
    "b": "Đánh giá chất lượng, theo dõi tiến độ, ước lượng nỗ lực và đưa ra quyết định dựa trên dữ liệu.",
    "c": "Gây áp lực cho đội ngũ.",
    "d": "Không có giá trị thực tiễn.",
    "answer": "B",
    "theory": "Các số liệu (metrics) như số lượng lỗi, mật độ lỗi, thời gian sửa lỗi, độ bao phủ kiểm thử, chi phí bảo trì, v.v., cung cấp dữ liệu khách quan để đánh giá chất lượng sản phẩm và quy trình, theo dõi tiến độ, ước lượng nỗ lực, và hỗ trợ việc ra quyết định cải tiến."
  },
  {
    "question": "63. \"Testability\" (Khả năng kiểm thử) của phần mềm là một thuộc tính:",
    "a": "Chức năng.",
    "b": "Phi chức năng, liên quan đến việc thiết kế phần mềm sao cho dễ dàng kiểm tra được.",
    "c": "Chỉ liên quan đến phần cứng.",
    "d": "Chỉ quan trọng đối với tester.",
    "answer": "B",
    "theory": "Testability là một thuộc tính chất lượng phi chức năng, chỉ mức độ dễ dàng mà một hệ thống hoặc thành phần phần mềm có thể được kiểm thử. Thiết kế tốt (ví dụ: module hóa, giao diện rõ ràng, khả năng cô lập) sẽ làm tăng khả năng kiểm thử."
  },
  {
    "question": "64. Thiết kế kiến trúc có ảnh hưởng lớn đến khả năng kiểm thử của hệ thống không?",
    "a": "Không ảnh hưởng.",
    "b": "Có, kiến trúc module hóa tốt, giao diện rõ ràng thường dễ kiểm thử hơn kiến trúc nguyên khối, phức tạp.",
    "c": "Chỉ ảnh hưởng đến kiểm thử đơn vị.",
    "d": "Chỉ ảnh hưởng đến tốc độ chạy test.",
    "answer": "B",
    "theory": "Các quyết định kiến trúc có ảnh hưởng lớn đến khả năng kiểm thử của hệ thống. Một kiến trúc được module hóa tốt, các thành phần có giao diện rõ ràng, và ít phụ thuộc lẫn nhau sẽ dễ dàng hơn cho việc thiết kế test case, cô lập lỗi, và thực hiện các loại kiểm thử khác nhau."
  },
  {
    "question": "65. Mục tiêu của việc kiểm thử hiệu năng (Performance Testing) là gì?",
    "a": "Tìm lỗi logic.",
    "b": "Đảm bảo giao diện đẹp.",
    "c": "Đánh giá các chỉ số như thời gian đáp ứng, thông lượng, mức sử dụng tài nguyên của hệ thống dưới các điều kiện tải khác nhau.",
    "d": "Kiểm tra tính đúng đắn của thuật toán.",
    "answer": "C",
    "theory": "Kiểm thử hiệu năng nhằm đánh giá các thuộc tính liên quan đến tốc độ, sự ổn định, và khả năng mở rộng của hệ thống dưới các điều kiện tải trọng khác nhau, ví dụ như thời gian đáp ứng, thông lượng (số lượng giao dịch/giây), mức sử dụng CPU, bộ nhớ."
  },
  {
    "question": "66. Tại sao cần có kế hoạch kiểm thử (Test Plan)?",
    "a": "Để xác định phạm vi, chiến lược, tài nguyên, lịch trình và các hoạt động kiểm thử cần thực hiện.",
    "b": "Chỉ để liệt kê các test case.",
    "c": "Chỉ cần thiết cho kiểm thử thủ công.",
    "d": "Để làm phức tạp thêm quy trình.",
    "answer": "A",
    "theory": "Kế hoạch kiểm thử (Test Plan) là một tài liệu quan trọng, định nghĩa mục tiêu, phạm vi, phương pháp, tài nguyên, và lịch trình của các hoạt động kiểm thử. Nó giúp đảm bảo rằng quá trình kiểm thử được thực hiện một cách có hệ thống và hiệu quả."
  },
  {
    "question": "67. Một Test Case tốt cần có những yếu tố nào?",
    "a": "Chỉ có các bước thực hiện.",
    "b": "Mã định danh, mô tả, điều kiện tiên quyết, các bước thực hiện, dữ liệu đầu vào, kết quả mong đợi.",
    "c": "Chỉ có kết quả mong đợi.",
    "d": "Chỉ tên của người viết test case.",
    "answer": "B",
    "theory": "Một Test Case tốt cần được mô tả đầy đủ và rõ ràng, bao gồm: mã định danh duy nhất, mô tả mục tiêu kiểm thử, các điều kiện tiên quyết cần có, các bước thực hiện chi tiết, dữ liệu đầu vào cụ thể, và kết quả đầu ra mong đợi để so sánh."
  },
  {
    "question": "68. \"Test Oracle\" là gì trong kiểm thử phần mềm?",
    "a": "Một công cụ dự đoán lỗi.",
    "b": "Một cơ chế hoặc nguồn thông tin (ví dụ: đặc tả, hệ thống cũ, tính toán thủ công) được sử dụng để xác định kết quả mong đợi của một test case.",
    "c": "Tên của người thực hiện kiểm thử.",
    "d": "Một loại cơ sở dữ liệu kiểm thử.",
    "answer": "B",
    "theory": "Test Oracle là một nguồn thông tin hoặc một cơ chế được sử dụng để xác định kết quả đúng (mong đợi) cho một test case. Nó có thể là đặc tả yêu cầu, tài liệu thiết kế, một phiên bản trước đó của hệ thống, tính toán thủ công, hoặc một chương trình khác đã được biết là đúng."
  },
  {
    "question": "69. Kiểm thử thăm dò (Exploratory Testing) là gì?",
    "a": "Kiểm thử theo kịch bản đã viết sẵn một cách nghiêm ngặt.",
    "b": "Một cách tiếp cận kiểm thử ít trang trọng hơn, trong đó người kiểm thử đồng thời học hỏi về hệ thống, thiết kế và thực hiện kiểm thử dựa trên trực giác và khám phá.",
    "c": "Chỉ kiểm thử giao diện người dùng.",
    "d": "Tên gọi khác của kiểm thử tự động.",
    "answer": "B",
    "theory": "Kiểm thử thăm dò là một phong cách kiểm thử trong đó việc học hỏi về sản phẩm, thiết kế test case, thực thi test case, và báo cáo kết quả diễn ra đồng thời. Người kiểm thử sử dụng kinh nghiệm, trực giác và sự sáng tạo để khám phá các lỗi tiềm ẩn."
  },
  {
    "question": "70. Khi nào kiểm thử thăm dò đặc biệt hữu ích?",
    "a": "Khi đặc tả yêu cầu đầy đủ và chi tiết.",
    "b": "Khi thời gian kiểm thử eo hẹp hoặc đặc tả không đầy đủ, giúp nhanh chóng khám phá các khu vực có vấn đề.",
    "c": "Chỉ khi kiểm thử hồi quy.",
    "d": "Khi hệ thống quá đơn giản.",
    "answer": "B",
    "theory": "Kiểm thử thăm dò đặc biệt hữu ích trong các tình huống có ít thời gian, tài liệu đặc tả không đầy đủ hoặc không rõ ràng. Nó cho phép tester nhanh chóng học hỏi và khám phá các khía cạnh của hệ thống để tìm lỗi mà không cần các test case được viết trước chi tiết."
  },
  {
    "question": "71. Lập trình cặp (Pair Programming) có thể đóng góp vào chất lượng mã nguồn và giảm lỗi như thế nào?",
    "a": "Hai người cùng viết code giúp phát hiện lỗi và thảo luận giải pháp thiết kế ngay lập tức (giống như code review liên tục).",
    "b": "Làm chậm tiến độ gấp đôi.",
    "c": "Chỉ phù hợp cho lập trình viên mới.",
    "d": "Gây ra nhiều xung đột hơn.",
    "answer": "A",
    "theory": "Trong lập trình cặp, hai lập trình viên làm việc cùng nhau trên một máy tính. Một người viết code (driver) và người kia xem xét, suy nghĩ về chiến lược, và phát hiện lỗi (navigator). Điều này giống như một quá trình code review liên tục, giúp cải thiện chất lượng mã và giảm lỗi."
  },
  {
    "question": "72. Phần lớn chi phí trong vòng đời phần mềm thường dành cho hoạt động nào?",
    "a": "Phát triển ban đầu (thiết kế, hiện thực).",
    "b": "Tiến hóa và bảo trì sau khi phát hành.",
    "c": "Thu thập yêu cầu.",
    "d": "Kiểm thử bản release.",
    "answer": "B",
    "theory": "Đối với nhiều hệ thống phần mềm, đặc biệt là những hệ thống tồn tại lâu dài, chi phí cho việc bảo trì (sửa lỗi, thích ứng) và tiến hóa (thêm tính năng, cải tiến) sau khi phát hành thường chiếm một tỷ lệ lớn (có thể lên đến 60-80%) trong tổng chi phí vòng đời."
  },
  {
    "question": "73. Việc thiếu tài liệu hoặc tài liệu không cập nhật ảnh hưởng như thế nào đến bảo trì?",
    "a": "Không ảnh hưởng gì.",
    "b": "Làm cho việc hiểu hệ thống, phân tích tác động thay đổi và sửa lỗi trở nên khó khăn và tốn kém hơn nhiều.",
    "c": "Giúp người bảo trì sáng tạo hơn.",
    "d": "Chỉ ảnh hưởng đến việc đào tạo người mới.",
    "answer": "B",
    "theory": "Tài liệu đầy đủ và cập nhật là vô cùng quan trọng cho việc bảo trì. Nếu thiếu tài liệu hoặc tài liệu không còn phản ánh đúng hệ thống, người bảo trì sẽ mất nhiều thời gian và công sức để hiểu mã nguồn, phân tích tác động của thay đổi, và sửa lỗi, làm tăng chi phí và rủi ro."
  },
  {
    "question": "74. Đâu là lý do chính khiến các hệ thống kế thừa vẫn tiếp tục được sử dụng dù khó bảo trì?",
    "a": "Vì chúng luôn có hiệu năng tốt nhất.",
    "b": "Vì chúng chứa đựng logic nghiệp vụ quan trọng, chi phí và rủi ro thay thế quá cao.",
    "c": "Vì không có công nghệ mới nào tốt hơn.",
    "d": "Vì người dùng không muốn thay đổi.",
    "answer": "B",
    "theory": "Nhiều hệ thống kế thừa vẫn được sử dụng vì chúng thực hiện các chức năng nghiệp vụ quan trọng mà tổ chức phụ thuộc vào. Việc thay thế chúng bằng một hệ thống mới có thể rất tốn kém, mất thời gian, và tiềm ẩn nhiều rủi ro, ngay cả khi việc bảo trì hệ thống cũ rất khó khăn."
  },
  {
    "question": "75. Quản lý cấu hình phần mềm (Software Configuration Management - SCM) hỗ trợ tiến hóa và bảo trì như thế nào?",
    "a": "Bằng cách quản lý các phiên bản của mã nguồn và tài liệu, kiểm soát thay đổi, và hỗ trợ việc tạo các bản build nhất quán.",
    "b": "Bằng cách tự động sửa lỗi.",
    "c": "Bằng cách viết tài liệu người dùng.",
    "d": "Bằng cách tối ưu hóa CSDL.",
    "answer": "A",
    "theory": "SCM là một tập hợp các hoạt động nhằm kiểm soát sự thay đổi trong suốt vòng đời phần mềm. Nó bao gồm quản lý phiên bản (version control), quản lý thay đổi (change control), quản lý build, và quản lý release. Điều này rất quan trọng để hỗ trợ quá trình tiến hóa và bảo trì một cách có trật tự."
  },
  {
    "question": "76. Công cụ SCM phổ biến hiện nay là gì?",
    "a": "Microsoft Excel.",
    "b": "Git, Subversion (SVN), Mercurial.",
    "c": "JUnit.",
    "d": "Jenkins.",
    "answer": "B",
    "theory": "Git, Subversion (SVN), và Mercurial là các hệ thống quản lý phiên bản (VCS) phổ biến, là một phần quan trọng của SCM. Chúng giúp theo dõi các thay đổi, quản lý các phiên bản, và hỗ trợ làm việc nhóm."
  },
  {
    "question": "77. Khái niệm \"Build\" và \"Release\" khác nhau như thế nào?",
    "a": "Build là quá trình tạo ra bản thực thi, Release là bản chính thức được phát hành cho người dùng. Một release thường dựa trên một bản build đã được kiểm thử kỹ lưỡng.",
    "b": "Build chỉ dành cho môi trường phát triển, Release chỉ dành cho môi trường kiểm thử.",
    "c": "Chúng là hai thuật ngữ đồng nghĩa.",
    "d": "Build luôn chứa nhiều lỗi hơn Release.",
    "answer": "A",
    "theory": "Một \"Build\" là kết quả của quá trình biên dịch và đóng gói mã nguồn thành một phiên bản có thể thực thi hoặc triển khai. Một \"Release\" là một phiên bản cụ thể của phần mềm được phát hành chính thức cho người dùng hoặc khách hàng, thường sau khi đã trải qua các giai đoạn kiểm thử và đảm bảo chất lượng."
  },
  {
    "question": "78. Hoạt động nào sau đây KHÔNG thuộc về tiến hóa phần mềm?",
    "a": "Sửa lỗi được báo cáo bởi người dùng.",
    "b": "Thêm một tính năng mới theo yêu cầu thị trường.",
    "c": "Phát triển hệ thống hoàn toàn mới từ đầu.",
    "d": "Điều chỉnh hệ thống để chạy trên phiên bản hệ điều hành mới.",
    "answer": "C",
    "theory": "Tiến hóa phần mềm là các thay đổi được thực hiện trên một hệ thống phần mềm hiện có. Việc phát triển một hệ thống hoàn toàn mới từ đầu là một dự án phát triển mới, không phải là tiến hóa của một hệ thống cũ."
  },
  {
    "question": "79. Tại sao việc đánh giá chất lượng kỹ thuật của hệ thống kế thừa lại quan trọng?",
    "a": "Để quyết định xem việc bảo trì, tái cấu trúc hay thay thế là phương án khả thi và hiệu quả nhất về mặt chi phí và rủi ro.",
    "b": "Chỉ để xác định ngôn ngữ lập trình đã cũ hay chưa.",
    "c": "Để tìm lý do đổ lỗi cho đội phát triển trước.",
    "d": "Không quan trọng bằng giá trị kinh doanh.",
    "answer": "A",
    "theory": "Đánh giá chất lượng kỹ thuật (ví dụ: cấu trúc, khả năng bảo trì, tài liệu) của một hệ thống kế thừa, cùng với giá trị kinh doanh của nó, giúp đưa ra quyết định chiến lược về tương lai của hệ thống đó: liệu có nên tiếp tục bảo trì, đầu tư tái cấu trúc, hay thay thế bằng một hệ thống mới."
  },
  {
    "question": "80. \"Code Clones\" (Mã nguồn trùng lặp) là một dấu hiệu xấu trong hiện thực vì sao?",
    "a": "Tăng kích thước mã nguồn không cần thiết, khi cần sửa lỗi hoặc thay đổi logic phải thực hiện ở nhiều nơi, dễ gây thiếu sót và không nhất quán.",
    "b": "Giúp mã nguồn dễ đọc hơn.",
    "c": "Là một kỹ thuật tối ưu hóa hiệu năng.",
    "d": "Không ảnh hưởng đến bảo trì.",
    "answer": "A",
    "theory": "Mã nguồn trùng lặp (Code Clones) là một \"code smell\" phổ biến. Nó làm tăng kích thước mã, gây khó khăn cho việc bảo trì (vì một thay đổi logic phải được áp dụng ở tất cả các bản sao), và tăng nguy cơ lỗi do sửa đổi không nhất quán."
  },
  {
    "question": "81. Kỹ thuật nào thường được sử dụng để loại bỏ Code Clones?",
    "a": "Thêm nhiều comment hơn.",
    "b": "Refactoring (ví dụ: tạo hàm/phương thức chung - Extract Method).",
    "c": "Viết lại toàn bộ module.",
    "d": "Sử dụng nhiều biến toàn cục hơn.",
    "answer": "B",
    "theory": "Refactoring là kỹ thuật chính để loại bỏ code clones. Ví dụ, nếu một đoạn mã lặp lại ở nhiều nơi, có thể trích xuất nó thành một phương thức (Extract Method) hoặc một lớp chung để tái sử dụng, giảm sự trùng lặp."
  },
  {
    "question": "82. Static Analysis Tools (Công cụ phân tích tĩnh) có thể giúp phát hiện loại vấn đề nào?",
    "a": "Lỗi hiệu năng khi chạy chương trình.",
    "b": "Các lỗi tiềm ẩn, code smell, không tuân thủ coding standard mà không cần thực thi mã nguồn.",
    "c": "Lỗi trong yêu cầu người dùng.",
    "d": "Vấn đề về giao diện người dùng.",
    "answer": "B",
    "theory": "Công cụ phân tích tĩnh (Static Analysis Tools) phân tích mã nguồn mà không cần chạy nó. Chúng có thể phát hiện các lỗi tiềm ẩn (như null pointer dereference), các \"code smells\" (như code trùng lặp, phương thức quá dài), và việc không tuân thủ các tiêu chuẩn mã hóa."
  },
  {
    "question": "83. Đâu là ví dụ về công cụ phân tích tĩnh?",
    "a": "JUnit.",
    "b": "Jenkins.",
    "c": "SonarQube, Checkstyle, PMD, FindBugs.",
    "d": "Git.",
    "answer": "C",
    "theory": "SonarQube, Checkstyle, PMD, và FindBugs là các ví dụ về công cụ phân tích tĩnh phổ biến. JUnit là framework kiểm thử đơn vị. Jenkins là server CI. Git là hệ thống quản lý phiên bản."
  },
  {
    "question": "84. Mối quan hệ giữa kiểm thử và đảm bảo chất lượng (Quality Assurance - QA) là gì?",
    "a": "Testing là hoạt động chính, QA chỉ là tên gọi khác.",
    "b": "QA là một quy trình rộng hơn bao gồm cả việc thiết lập tiêu chuẩn, quy trình và kiểm tra để đảm bảo chất lượng, trong đó Testing là một hoạt động quan trọng.",
    "c": "QA thực hiện trước Testing.",
    "d": "Testing không liên quan đến QA.",
    "answer": "B",
    "theory": "Đảm bảo chất lượng (QA) là một tập hợp các hoạt động và quy trình nhằm đảm bảo rằng sản phẩm hoặc dịch vụ đáp ứng các tiêu chuẩn chất lượng đã định. Kiểm thử (Testing) là một trong những hoạt động quan trọng nhất trong QA, nhưng QA còn bao gồm cả việc thiết lập quy trình, tiêu chuẩn, review, và các hoạt động khác."
  },
  {
    "question": "85. Mục tiêu cuối cùng của mọi hoạt động kiểm thử và tiến hóa là gì?",
    "a": "Viết được nhiều code nhất.",
    "b": "Kéo dài thời gian dự án.",
    "c": "Cung cấp giá trị cho người dùng và doanh nghiệp thông qua một phần mềm chất lượng, đáng tin cậy và đáp ứng nhu cầu thay đổi.",
    "d": "Tìm ra lỗi của các lập trình viên khác.",
    "answer": "C",
    "theory": "Mục tiêu cuối cùng của việc kiểm thử và tiến hóa phần mềm là để đảm bảo rằng phần mềm mang lại giá trị cho người dùng và tổ chức, bằng cách cung cấp một sản phẩm chất lượng cao, hoạt động đáng tin cậy, và có khả năng thích ứng với các nhu cầu và môi trường thay đổi theo thời gian."
  },
  {
    "question": "86. \"Test-Driven Development\" (TDD) là một quy trình phát triển trong đó:",
    "a": "Kiểm thử được viết sau khi code đã hoàn thành.",
    "b": "Kiểm thử đơn vị được viết trước khi viết mã nguồn chức năng, mã nguồn chỉ được viết đủ để vượt qua kiểm thử đó.",
    "c": "Không cần viết kiểm thử đơn vị.",
    "d": "Chỉ tập trung vào kiểm thử giao diện.",
    "answer": "B",
    "theory": "Trong TDD, chu trình phát triển ngắn bao gồm: viết một kiểm thử đơn vị thất bại (red), sau đó viết mã chức năng tối thiểu để kiểm thử đó thành công (green), và cuối cùng là tái cấu trúc mã (refactor). Điều này đảm bảo mã luôn có kiểm thử đi kèm và thiết kế được định hướng bởi kiểm thử."
  },
  {
    "question": "87. Behavior-Driven Development (BDD) mở rộng TDD bằng cách:",
    "a": "Tập trung vào kiểm thử hiệu năng.",
    "b": "Viết các kiểm thử dưới dạng mô tả hành vi mong muốn của hệ thống bằng ngôn ngữ gần với tự nhiên, dễ hiểu cho cả người không chuyên về kỹ thuật.",
    "c": "Chỉ sử dụng kiểm thử thủ công.",
    "d": "Loại bỏ hoàn toàn kiểm thử đơn vị.",
    "answer": "B",
    "theory": "BDD là một mở rộng của TDD, tập trung vào việc mô tả hành vi mong muốn của hệ thống từ góc nhìn của người dùng hoặc các bên liên quan, thường sử dụng một ngôn ngữ cấu trúc (như Gherkin: Given-When-Then) dễ hiểu cho cả đội ngũ kỹ thuật và nghiệp vụ. Các mô tả hành vi này sau đó được tự động hóa thành các kiểm thử."
  },
  {
    "question": "88. Công cụ như Cucumber, SpecFlow hỗ trợ phương pháp phát triển nào?",
    "a": "Test-Driven Development (TDD).",
    "b": "Behavior-Driven Development (BDD).",
    "c": "Waterfall Model.",
    "d": "Code Inspection.",
    "answer": "B",
    "theory": "Cucumber (cho Ruby, Java, và nhiều ngôn ngữ khác) và SpecFlow (cho .NET) là các công cụ phổ biến hỗ trợ BDD. Chúng cho phép viết các đặc tả hành vi bằng ngôn ngữ tự nhiên (ví dụ: Gherkin) và sau đó liên kết chúng với mã tự động hóa kiểm thử."
  },
  {
    "question": "89. Trong ngữ cảnh tiến hóa, \"Technical Refresh\" thường ám chỉ việc gì?",
    "a": "Thêm tính năng mới cho người dùng.",
    "b": "Nâng cấp cơ sở hạ tầng (phần cứng, hệ điều hành, CSDL) mà hệ thống đang chạy trên đó, đòi hỏi phải điều chỉnh phần mềm để tương thích.",
    "c": "Viết lại giao diện người dùng.",
    "d": "Đào tạo lại đội ngũ bảo trì.",
    "answer": "B",
    "theory": "\"Technical Refresh\" là quá trình nâng cấp các thành phần cơ sở hạ tầng (phần cứng, hệ điều hành, CSDL, thư viện) mà hệ thống phần mềm phụ thuộc. Điều này thường đòi hỏi phải thực hiện các thay đổi (bảo trì thích ứng) trong phần mềm để đảm bảo nó vẫn hoạt động tương thích với môi trường mới."
  },
  {
    "question": "90. Việc đo lường \"Mean Time Between Failures\" (MTBF) cung cấp thông tin về thuộc tính nào của phần mềm?",
    "a": "Hiệu năng (Performance).",
    "b": "Khả năng bảo trì (Maintainability).",
    "c": "Độ tin cậy (Reliability).",
    "d": "Tính dễ sử dụng (Usability).",
    "answer": "C",
    "theory": "MTBF (Thời gian trung bình giữa các lỗi) là một thước đo về độ tin cậy của một hệ thống hoặc thành phần. Nó cho biết khoảng thời gian trung bình mà hệ thống hoạt động không có lỗi trước khi một lỗi mới xảy ra."
  },
  {
    "question": "91. Việc đo lường \"Mean Time To Repair\" (MTTR) cung cấp thông tin về thuộc tính nào của phần mềm/quy trình?",
    "a": "Tốc độ xử lý giao dịch.",
    "b": "Khả năng bảo trì và hiệu quả của quy trình sửa lỗi.",
    "c": "Số lượng người dùng đồng thời.",
    "d": "Mức độ bao phủ mã.",
    "answer": "B",
    "theory": "MTTR (Thời gian trung bình để sửa chữa) đo lường khoảng thời gian trung bình cần thiết để sửa một lỗi sau khi nó được phát hiện. Nó phản ánh khả năng bảo trì của phần mềm (mã dễ sửa không) và hiệu quả của quy trình sửa lỗi (quy trình có nhanh chóng không)."
  },
  {
    "question": "92. Tại sao việc lập kế hoạch cho giai đoạn bảo trì ngay từ khi thiết kế lại quan trọng?",
    "a": "Các quyết định thiết kế (ví dụ: kiến trúc, module hóa, tài liệu hóa) ảnh hưởng trực tiếp đến chi phí và nỗ lực bảo trì sau này.",
    "b": "Chỉ để dự trù ngân sách.",
    "c": "Không quan trọng, bảo trì là việc của đội khác.",
    "d": "Để làm chậm giai đoạn thiết kế.",
    "answer": "A",
    "theory": "Tính dễ bảo trì (maintainability) là một thuộc tính chất lượng quan trọng cần được xem xét ngay từ giai đoạn thiết kế. Các quyết định về kiến trúc, cách module hóa, chất lượng mã nguồn, và tài liệu hóa đều ảnh hưởng trực tiếp đến việc bảo trì phần mềm sẽ dễ dàng hay khó khăn, tốn kém hay tiết kiệm trong tương lai."
  },
  {
    "question": "93. Kiểm thử hiệu năng khác kiểm thử chức năng ở điểm nào?",
    "a": "Kiểm thử chức năng kiểm tra \"hệ thống làm gì\", kiểm thử hiệu năng kiểm tra \"hệ thống làm tốt như thế nào\" (tốc độ, khả năng chịu tải,...).",
    "b": "Kiểm thử hiệu năng dễ hơn kiểm thử chức năng.",
    "c": "Chỉ hệ thống web mới cần kiểm thử hiệu năng.",
    "d": "Kiểm thử chức năng không cần dữ liệu kiểm thử.",
    "answer": "A",
    "theory": "Kiểm thử chức năng tập trung vào việc xác minh xem hệ thống có thực hiện đúng các chức năng được yêu cầu hay không (\"what it does\"). Kiểm thử hiệu năng tập trung vào các thuộc tính phi chức năng liên quan đến tốc độ, sự ổn định, và khả năng mở rộng của hệ thống dưới các điều kiện tải khác nhau (\"how well it does it\")."
  },
  {
    "question": "94. Đâu là một thách thức của việc kiểm thử các hệ thống phân tán (distributed systems)?",
    "a": "Khó khăn trong việc tái tạo lỗi do tính không đồng bộ và điều kiện mạng thay đổi.",
    "b": "Các hệ thống này thường đơn giản hơn.",
    "c": "Không cần kiểm thử giao diện giữa các thành phần.",
    "d": "Luôn dễ dàng gỡ lỗi hơn.",
    "answer": "A",
    "theory": "Kiểm thử hệ thống phân tán gặp nhiều thách thức do tính không đồng bộ của các tương tác, sự thay đổi của điều kiện mạng (độ trễ, mất gói), và sự phức tạp trong việc phối hợp và đồng bộ hóa trạng thái giữa nhiều thành phần. Việc tái tạo lỗi có thể rất khó khăn."
  },
  {
    "question": "95. Log file (tệp nhật ký) đóng vai trò gì trong kiểm thử và gỡ lỗi?",
    "a": "Không có vai trò gì.",
    "b": "Cung cấp thông tin chi tiết về các sự kiện, lỗi, trạng thái hệ thống xảy ra trong quá trình thực thi, hỗ trợ việc chẩn đoán vấn đề.",
    "c": "Chỉ dùng để lưu thông tin người dùng.",
    "d": "Chỉ ghi lại lỗi nghiêm trọng.",
    "answer": "B",
    "theory": "Log file ghi lại các thông tin quan trọng về hoạt động của hệ thống, bao gồm các sự kiện, thông báo lỗi, giá trị biến, và trạng thái. Chúng là một nguồn thông tin vô giá cho việc kiểm thử (để theo dõi hành vi) và đặc biệt là gỡ lỗi (để chẩn đoán nguyên nhân của vấn đề)."
  },
  {
    "question": "96. Tầm quan trọng của việc quản lý môi trường kiểm thử (Test Environment Management) là gì?",
    "a": "Đảm bảo môi trường kiểm thử ổn định, nhất quán và tương tự môi trường production nhất có thể để kết quả kiểm thử đáng tin cậy.",
    "b": "Không cần thiết, có thể kiểm thử trên máy của lập trình viên.",
    "c": "Chỉ cần một máy tính duy nhất cho tất cả các loại kiểm thử.",
    "d": "Chỉ áp dụng cho kiểm thử tự động.",
    "answer": "A",
    "theory": "Quản lý môi trường kiểm thử là rất quan trọng để đảm bảo rằng các kết quả kiểm thử là đáng tin cậy và có thể lặp lại. Môi trường kiểm thử cần được cấu hình đúng, ổn định, và càng giống với môi trường sản xuất (production) càng tốt để giảm thiểu các lỗi chỉ xảy ra trên một môi trường cụ thể."
  },
  {
    "question": "97. Khi thiết kế kiến trúc, việc cân bằng giữa các thuộc tính chất lượng (quality attributes) thường đối mặt với thách thức nào?",
    "a": "Các thuộc tính chất lượng luôn bổ trợ lẫn nhau một cách hoàn hảo.",
    "b": "Thường phải có sự đánh đổi (trade-offs), vì việc tối ưu một thuộc tính (ví dụ: hiệu năng) có thể ảnh hưởng tiêu cực đến thuộc tính khác (ví dụ: bảo mật, khả năng bảo trì).",
    "c": "Chỉ cần tập trung vào việc đáp ứng yêu cầu chức năng là đủ, các thuộc tính chất lượng không quan trọng bằng.",
    "d": "Các thuộc tính chất lượng chỉ quan trọng đối với giao diện người dùng.",
    "answer": "B",
    "theory": "Đây là câu hỏi lặp lại từ chương 5, 6 và đầu chương 8. Trong thiết kế kiến trúc, việc cố gắng tối ưu một thuộc tính chất lượng (ví dụ: tăng hiệu năng) thường dẫn đến sự đánh đổi với các thuộc tính chất lượng khác (ví dụ: có thể làm tăng độ phức tạp, giảm khả năng bảo trì hoặc tăng chi phí). Các kiến trúc sư phải tìm cách cân bằng các đánh đổi này."
  },
  {
    "question": "98. Việc đánh giá kiến trúc (Architectural Evaluation) nên được thực hiện vào thời điểm nào trong quá trình phát triển để mang lại hiệu quả cao nhất?",
    "a": "Chỉ sau khi hệ thống đã hoàn thành và sẵn sàng triển khai.",
    "b": "Chỉ trong giai đoạn kiểm thử cuối cùng.",
    "c": "Càng sớm càng tốt trong chu trình thiết kế (ngay sau khi có bản phác thảo kiến trúc) và có thể lặp lại khi kiến trúc được tinh chỉnh.",
    "d": "Chỉ khi có vấn đề nghiêm trọng xảy ra trong quá trình phát triển.",
    "answer": "C",
    "theory": "Đây là câu hỏi lặp lại từ chương 5, 6 và đầu chương 8. Đánh giá kiến trúc nên được thực hiện càng sớm càng tốt trong vòng đời phát triển, ngay khi có các bản phác thảo kiến trúc ban đầu. Việc phát hiện và sửa chữa các vấn đề kiến trúc sớm sẽ tốn ít chi phí hơn nhiều so với việc sửa chúng ở các giai đoạn sau."
  },
  {
    "question": "99. Hiện tượng \"Architectural Drift\" (hay \"Architectural Erosion\" - Xói mòn kiến trúc) mô tả điều gì?",
    "a": "Việc kiến trúc phần mềm trở nên quá phức tạp không cần thiết.",
    "b": "Sự sai lệch dần dần của cấu trúc hệ thống thực tế so với thiết kế kiến trúc ban đầu theo thời gian, thường do các thay đổi cục bộ không tuân thủ nguyên tắc kiến trúc.",
    "c": "Việc thay đổi hoàn toàn mẫu kiến trúc đã chọn giữa chừng dự án.",
    "d": "Việc thiếu hoàn toàn tài liệu mô tả kiến trúc.",
    "answer": "B",
    "theory": "Đây là câu hỏi lặp lại từ chương 5, 6 và đầu chương 8. Xói mòn kiến trúc (Architectural Drift/Erosion) là hiện tượng cấu trúc thực tế của hệ thống ngày càng sai lệch so với thiết kế kiến trúc ban đầu qua thời gian. Điều này thường xảy ra do các thay đổi, sửa lỗi, hoặc bổ sung tính năng được thực hiện mà không tuân thủ chặt chẽ các nguyên tắc và ràng buộc của kiến trúc đã định."
  },
  {
    "question": "100. \"Architectural Style\" (Kiểu kiến trúc) và \"Architectural Pattern\" (Mẫu kiến trúc) thường được phân biệt như thế nào?",
    "a": "Style là một giải pháp cụ thể, Pattern là một vấn đề chung chung.",
    "b": "Pattern mô tả một giải pháp đã được chứng minh cho một vấn đề thiết kế cụ thể, lặp đi lặp lại; Style mô tả một cách tiếp cận, một triết lý tổ chức hệ thống ở mức cao hơn, định hình cấu trúc tổng thể (ví dụ: Client-Server là một style, MVC là một pattern).",
    "c": "Không có sự khác biệt rõ ràng, chúng thường được dùng thay thế cho nhau.",
    "d": "Style chỉ áp dụng cho các hệ thống phân tán, Pattern áp dụng cho mọi hệ thống.",
    "answer": "B",
    "theory": "Đây là câu hỏi lặp lại từ chương 5, 6 và đầu chương 8. Architectural Style (Kiểu kiến trúc) là một tập hợp các nguyên tắc và ràng buộc về cách tổ chức hệ thống ở mức cao (ví dụ: Client-Server, Layered, Pipe-and-Filter). Architectural Pattern (Mẫu kiến trúc) là một giải pháp đã được kiểm chứng cho một vấn đề thiết kế cụ thể, thường có phạm vi nhỏ hơn Style (ví dụ: MVC, Repository). Một Style có thể được hiện thực hóa bằng nhiều Pattern khác nhau."
  },{
    "question": "98. Việc đánh giá kiến trúc (Architectural Evaluation) nên được thực hiện vào thời điểm nào trong quá trình phát triển để mang lại hiệu quả cao nhất?",
    "a": "Chỉ sau khi hệ thống đã hoàn thành và sẵn sàng triển khai.",
    "b": "Chỉ trong giai đoạn kiểm thử cuối cùng.",
    "c": "Càng sớm càng tốt trong chu trình thiết kế (ngay sau khi có bản phác thảo kiến trúc) và có thể lặp lại khi kiến trúc được tinh chỉnh.",
    "d": "Chỉ khi có vấn đề nghiêm trọng xảy ra trong quá trình phát triển.",
    "answer": "C",
    "theory": "Đây là câu hỏi lặp lại từ chương 5, 6 và đầu chương 8. Đánh giá kiến trúc nên được thực hiện càng sớm càng tốt trong vòng đời phát triển, ngay khi có các bản phác thảo kiến trúc ban đầu. Việc phát hiện và sửa chữa các vấn đề kiến trúc sớm sẽ tốn ít chi phí hơn nhiều so với việc sửa chúng ở các giai đoạn sau."
  },{
    "question": "77. Khái niệm \"Build\" và \"Release\" khác nhau như thế nào?",
    "a": "Build là quá trình tạo ra bản thực thi, Release là bản chính thức được phát hành cho người dùng. Một release thường dựa trên một bản build đã được kiểm thử kỹ lưỡng.",
    "b": "Build chỉ dành cho môi trường phát triển, Release chỉ dành cho môi trường kiểm thử.",
    "c": "Chúng là hai thuật ngữ đồng nghĩa.",
    "d": "Build luôn chứa nhiều lỗi hơn Release.",
    "answer": "A",
    "theory": "Một \"Build\" là kết quả của quá trình biên dịch và đóng gói mã nguồn thành một phiên bản có thể thực thi hoặc triển khai. Một \"Release\" là một phiên bản cụ thể của phần mềm được phát hành chính thức cho người dùng hoặc khách hàng, thường sau khi đã trải qua các giai đoạn kiểm thử và đảm bảo chất lượng."
  },{
    "question": "16. Kiểm thử trong khi xây dựng (Development testing) thường do ai thực hiện?",
    "a": "Khách hàng.",
    "b": "Đội ngũ kiểm thử độc lập.",
    "c": "Nhóm phát triển phần mềm (lập trình viên).",
    "d": "Người quản lý dự án.",
    "answer": "C",
    "theory": "Kiểm thử trong khi xây dựng (Development testing), bao gồm kiểm thử đơn vị (unit testing) và kiểm thử thành phần (component testing), thường được thực hiện bởi chính các lập trình viên hoặc nhóm phát triển trong quá trình họ xây dựng phần mềm."
  }
]


